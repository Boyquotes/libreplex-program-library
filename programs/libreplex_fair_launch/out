#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use anchor_lang::prelude::*;
pub mod instructions {
    pub mod initialise {
        use anchor_lang::prelude::*;
        use crate::{
            errors::FairLaunchError, Deployment, DeploymentConfig, NewDeploymentEvent,
            NewDeploymentV2, OFFCHAIN_URL_LIMIT, TEMPLATE_LIMIT, TICKER_LIMIT,
        };
        pub mod sysvar_instructions_program {
            use anchor_lang::declare_id;
            /// The static program ID
            pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                6u8,
                167u8,
                213u8,
                23u8,
                24u8,
                123u8,
                209u8,
                102u8,
                53u8,
                218u8,
                212u8,
                4u8,
                85u8,
                253u8,
                194u8,
                192u8,
                193u8,
                36u8,
                198u8,
                143u8,
                33u8,
                86u8,
                117u8,
                165u8,
                219u8,
                186u8,
                203u8,
                95u8,
                8u8,
                0u8,
                0u8,
                0u8,
            ]);
            /// Confirms that a given pubkey is equivalent to the program ID
            pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
                id == &ID
            }
            /// Returns the program ID
            pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                ID
            }
        }
        #[instruction(input:InitialiseInput)]
        pub struct InitialiseCtx<'info> {
            #[account(
                init,
                payer = payer,
                space = 8+Deployment::INIT_SPACE,
                seeds = ["deployment".as_ref(),
                input.ticker.as_ref()],
                bump
            )]
            pub deployment: Account<'info, Deployment>,
            #[account(mut)]
            pub payer: Signer<'info>,
            #[account()]
            pub system_program: Program<'info, System>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, InitialiseCtxBumps>
        for InitialiseCtx<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut InitialiseCtxBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let mut __ix_data = __ix_data;
                struct __Args {
                    input: InitialiseInput,
                }
                impl borsh::ser::BorshSerialize for __Args
                where
                    InitialiseInput: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.input, writer)?;
                        Ok(())
                    }
                }
                impl borsh::de::BorshDeserialize for __Args
                where
                    InitialiseInput: borsh::BorshDeserialize,
                {
                    fn deserialize_reader<R: borsh::maybestd::io::Read>(
                        reader: &mut R,
                    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                        Ok(Self {
                            input: borsh::BorshDeserialize::deserialize_reader(reader)?,
                        })
                    }
                }
                let __Args { input } = __Args::deserialize(&mut __ix_data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                    })?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let deployment = &__accounts[0];
                *__accounts = &__accounts[1..];
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["deployment".as_ref(), input.ticker.as_ref()],
                    __program_id,
                );
                __bumps.deployment = __bump;
                if deployment.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("deployment")
                            .with_pubkeys((deployment.key(), __pda_address)),
                    );
                }
                let deployment = {
                    let actual_field = AsRef::<AccountInfo>::as_ref(&deployment);
                    let actual_owner = actual_field.owner;
                    let space = 8 + Deployment::INIT_SPACE;
                    let pa: anchor_lang::accounts::account::Account<Deployment> = if !false
                        || actual_owner
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let __current_lamports = deployment.lamports();
                        if __current_lamports == 0 {
                            let space = space;
                            let lamports = __anchor_rent.minimum_balance(space);
                            let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                from: payer.to_account_info(),
                                to: deployment.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::create_account(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "deployment".as_ref(),
                                                input.ticker.as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                lamports,
                                space as u64,
                                __program_id,
                            )?;
                        } else {
                            if payer.key() == deployment.key() {
                                return Err(
                                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                            error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .name(),
                                            error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .into(),
                                            error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .to_string(),
                                            error_origin: Some(
                                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                    filename: "programs/libreplex_fair_launch/src/instructions/initialise.rs",
                                                    line: 28u32,
                                                }),
                                            ),
                                            compared_values: None,
                                        })
                                        .with_pubkeys((payer.key(), deployment.key())),
                                );
                            }
                            let required_lamports = __anchor_rent
                                .minimum_balance(space)
                                .max(1)
                                .saturating_sub(__current_lamports);
                            if required_lamports > 0 {
                                let cpi_accounts = anchor_lang::system_program::Transfer {
                                    from: payer.to_account_info(),
                                    to: deployment.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::transfer(
                                    cpi_context,
                                    required_lamports,
                                )?;
                            }
                            let cpi_accounts = anchor_lang::system_program::Allocate {
                                account_to_allocate: deployment.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::allocate(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "deployment".as_ref(),
                                                input.ticker.as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                space as u64,
                            )?;
                            let cpi_accounts = anchor_lang::system_program::Assign {
                                account_to_assign: deployment.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::assign(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "deployment".as_ref(),
                                                input.ticker.as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                __program_id,
                            )?;
                        }
                        match anchor_lang::accounts::account::Account::try_from_unchecked(
                            &deployment,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("deployment")),
                        }
                    } else {
                        match anchor_lang::accounts::account::Account::try_from(
                            &deployment,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("deployment")),
                        }
                    };
                    if false {
                        if space != actual_field.data_len() {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSpace,
                                    )
                                    .with_account_name("deployment")
                                    .with_values((space, actual_field.data_len())),
                            );
                        }
                        if actual_owner != __program_id {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintOwner,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((*actual_owner, *__program_id)),
                            );
                        }
                        {
                            let required_lamports = __anchor_rent.minimum_balance(space);
                            if pa.to_account_info().lamports() < required_lamports {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                        )
                                        .with_account_name("deployment"),
                                );
                            }
                        }
                    }
                    pa
                };
                if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        deployment.to_account_info().lamports(),
                        deployment.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("payer"),
                    );
                }
                Ok(InitialiseCtx {
                    deployment,
                    payer,
                    system_program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for InitialiseCtx<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.deployment.to_account_infos());
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for InitialiseCtx<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.deployment.to_account_metas(None));
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for InitialiseCtx<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                    .map_err(|e| e.with_account_name("deployment"))?;
                anchor_lang::AccountsExit::exit(&self.payer, program_id)
                    .map_err(|e| e.with_account_name("payer"))?;
                Ok(())
            }
        }
        pub struct InitialiseCtxBumps {
            pub deployment: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for InitialiseCtxBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "InitialiseCtxBumps",
                    "deployment",
                    &&self.deployment,
                )
            }
        }
        impl Default for InitialiseCtxBumps {
            fn default() -> Self {
                InitialiseCtxBumps {
                    deployment: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for InitialiseCtx<'info>
        where
            'info: 'info,
        {
            type Bumps = InitialiseCtxBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_initialise_ctx {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`InitialiseCtx`].
            pub struct InitialiseCtx {
                pub deployment: Pubkey,
                pub payer: Pubkey,
                pub system_program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for InitialiseCtx
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for InitialiseCtx {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_initialise_ctx {
            use super::*;
            /// Generated CPI struct of the accounts for [`InitialiseCtx`].
            pub struct InitialiseCtx<'info> {
                pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for InitialiseCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for InitialiseCtx<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub struct InitialiseInput {
            pub limit_per_mint: u64,
            pub max_number_of_tokens: u64,
            pub decimals: u8,
            pub ticker: String,
            pub deployment_template: String,
            pub mint_template: String,
            pub offchain_url: String,
            pub deployment_type: u8,
        }
        impl borsh::de::BorshDeserialize for InitialiseInput
        where
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            String: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    limit_per_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    max_number_of_tokens: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    decimals: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    ticker: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    deployment_template: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    mint_template: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    offchain_url: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    deployment_type: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        impl borsh::ser::BorshSerialize for InitialiseInput
        where
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            String: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.limit_per_mint, writer)?;
                borsh::BorshSerialize::serialize(&self.max_number_of_tokens, writer)?;
                borsh::BorshSerialize::serialize(&self.decimals, writer)?;
                borsh::BorshSerialize::serialize(&self.ticker, writer)?;
                borsh::BorshSerialize::serialize(&self.deployment_template, writer)?;
                borsh::BorshSerialize::serialize(&self.mint_template, writer)?;
                borsh::BorshSerialize::serialize(&self.offchain_url, writer)?;
                borsh::BorshSerialize::serialize(&self.deployment_type, writer)?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for InitialiseInput {
            #[inline]
            fn clone(&self) -> InitialiseInput {
                InitialiseInput {
                    limit_per_mint: ::core::clone::Clone::clone(&self.limit_per_mint),
                    max_number_of_tokens: ::core::clone::Clone::clone(
                        &self.max_number_of_tokens,
                    ),
                    decimals: ::core::clone::Clone::clone(&self.decimals),
                    ticker: ::core::clone::Clone::clone(&self.ticker),
                    deployment_template: ::core::clone::Clone::clone(
                        &self.deployment_template,
                    ),
                    mint_template: ::core::clone::Clone::clone(&self.mint_template),
                    offchain_url: ::core::clone::Clone::clone(&self.offchain_url),
                    deployment_type: ::core::clone::Clone::clone(&self.deployment_type),
                }
            }
        }
        pub fn initialise(
            ctx: Context<InitialiseCtx>,
            input: InitialiseInput,
        ) -> Result<()> {
            let deployment = &mut ctx.accounts.deployment;
            let payer = &ctx.accounts.payer;
            deployment.require_creator_cosign = false;
            deployment.use_inscriptions = true;
            deployment.deployment_type = input.deployment_type;
            initialise_logic(input, deployment, payer.key(), None)
        }
        pub fn initialise_logic(
            input: InitialiseInput,
            deployment: &mut Account<'_, Deployment>,
            creator: Pubkey,
            config: Option<&DeploymentConfig>,
        ) -> Result<()> {
            if input.ticker.len() > TICKER_LIMIT {
                return Err(FairLaunchError::TickerTooLong.into());
            }
            if input.offchain_url.len() > OFFCHAIN_URL_LIMIT {
                return Err(FairLaunchError::OffchainUrlTooLong.into());
            }
            if input.mint_template.len() > TEMPLATE_LIMIT {
                return Err(FairLaunchError::MintTemplateTooLong.into());
            }
            if input.deployment_template.len() > TEMPLATE_LIMIT {
                return Err(FairLaunchError::DeploymentTemplateTooLong.into());
            }
            deployment.require_creator_cosign = false;
            deployment.use_inscriptions = true;
            deployment.deployment_type = input.deployment_type;
            deployment.creator = creator;
            deployment.limit_per_mint = input.limit_per_mint;
            deployment.max_number_of_tokens = input.max_number_of_tokens;
            deployment.number_of_tokens_issued = 0;
            deployment.decimals = input.decimals;
            deployment.ticker = input.ticker;
            deployment.deployment_template = input.deployment_template;
            deployment.mint_template = input.mint_template;
            deployment.offchain_url = input.offchain_url;
            deployment.escrow_non_fungible_count = 0;
            deployment.migrated_from_legacy = false;
            (input.limit_per_mint)
                .checked_mul(input.max_number_of_tokens)
                .unwrap()
                .checked_mul((10_u64).checked_pow(input.decimals as u32).unwrap())
                .unwrap();
            emit_init(deployment, config);
            Ok(())
        }
        fn emit_init(deployment: &Deployment, config: Option<&DeploymentConfig>) {
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &NewDeploymentV2 {
                                creator: deployment.creator,
                                limit_per_mint: deployment.limit_per_mint,
                                max_number_of_tokens: deployment.max_number_of_tokens,
                                ticker: deployment.ticker.clone(),
                                off_chain_url: deployment.offchain_url.clone(),
                                require_co_sign: deployment.require_creator_cosign,
                                uses_inscriptions: deployment.use_inscriptions,
                                decimals: deployment.decimals,
                                deployment_template: deployment.deployment_template.clone(),
                                mint_template: deployment.mint_template.clone(),
                                deployment_type: deployment.deployment_type,
                                config: config.map(|o| { o.clone() }),
                            },
                        ),
                    ],
                );
            };
        }
    }
    pub use initialise::*;
    pub mod deploy_legacy {
        use anchor_lang::prelude::*;
        use anchor_spl::{associated_token::AssociatedToken, token::Token};
        use libreplex_inscriptions::{
            cpi::accounts::CreateInscriptionV3,
            cpi::accounts::MakeInscriptionImmutableV3,
            cpi::accounts::ResizeInscriptionV3, cpi::accounts::WriteToInscriptionV3,
            instructions::{SignerType, WriteToInscriptionInput},
        };
        use libreplex_shared::{
            create_mint_metadata_and_masteredition::create_mint_with_metadata_and_masteredition,
            MintAccounts,
        };
        use mpl_token_metadata::types::TokenStandard;
        use crate::{check_deploy_allowed, Deployment, DeploymentActive, Hashlist};
        pub mod sysvar_instructions_program {
            use anchor_lang::declare_id;
            /// The static program ID
            pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                6u8,
                167u8,
                213u8,
                23u8,
                24u8,
                123u8,
                209u8,
                102u8,
                53u8,
                218u8,
                212u8,
                4u8,
                85u8,
                253u8,
                194u8,
                192u8,
                193u8,
                36u8,
                198u8,
                143u8,
                33u8,
                86u8,
                117u8,
                165u8,
                219u8,
                186u8,
                203u8,
                95u8,
                8u8,
                0u8,
                0u8,
                0u8,
            ]);
            /// Confirms that a given pubkey is equivalent to the program ID
            pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
                id == &ID
            }
            /// Returns the program ID
            pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                ID
            }
        }
        pub struct DeployLegacyCtx<'info> {
            #[account(
                mut,
                constraint = deployment.creator = = payer.key(),
                seeds = ["deployment".as_bytes(),
                deployment.ticker.as_bytes()],
                bump
            )]
            pub deployment: Account<'info, Deployment>,
            #[account(
                init,
                seeds = ["hashlist".as_bytes(),
                deployment.key().as_ref()],
                bump,
                payer = payer,
                space = 8+32+4
            )]
            pub hashlist: Account<'info, Hashlist>,
            #[account(mut)]
            pub payer: Signer<'info>,
            #[account(mut)]
            pub fungible_mint: Signer<'info>,
            /// CHECK: checked in code
            #[account(mut)]
            pub fungible_escrow_token_account: UncheckedAccount<'info>,
            /// CHECK: gets created, passed into libreplex_fair_launch via  CPI
            #[account(mut)]
            pub fungible_metadata: UncheckedAccount<'info>,
            #[account(mut)]
            pub non_fungible_mint: Signer<'info>,
            /// CHECK: gets created, passed into libreplex_fair_launch via  CPI
            #[account(mut)]
            pub non_fungible_metadata: UncheckedAccount<'info>,
            /// CHECK: gets created, passed into libreplex_fair_launch via  CPI
            #[account(mut)]
            pub non_fungible_master_edition: UncheckedAccount<'info>,
            /// CHECK: gets created, passed into libreplex_fair_launch via  CPI
            #[account(mut)]
            pub non_fungible_token_account: UncheckedAccount<'info>,
            /// CHECK: passed in via CPI to libreplex_inscriptions program
            #[account(mut)]
            pub inscription_summary: UncheckedAccount<'info>,
            /// CHECK: passed in via CPI to libreplex_inscriptions program
            #[account(mut)]
            pub inscription: UncheckedAccount<'info>,
            /// CHECK: passed in via CPI to libreplex_inscriptions program
            #[account(mut)]
            pub inscription_v3: UncheckedAccount<'info>,
            /// CHECK: passed in via CPI to libreplex_inscriptions program
            #[account(mut)]
            pub inscription_data: UncheckedAccount<'info>,
            #[account()]
            pub token_program: Program<'info, Token>,
            #[account()]
            pub associated_token_program: Program<'info, AssociatedToken>,
            /// CHECK: ID checked via constraint
            #[account(
                constraint = inscriptions_program.key()= = libreplex_inscriptions::ID
            )]
            pub inscriptions_program: UncheckedAccount<'info>,
            #[account()]
            pub system_program: Program<'info, System>,
            /// CHECK: Id checked in constraint
            #[account(constraint = metadata_program.key()= = mpl_token_metadata::ID)]
            #[account()]
            pub metadata_program: UncheckedAccount<'info>,
            /// CHECK: Id checked in constraint
            #[account(
                constraint = sysvar_instructions.key()= = sysvar_instructions_program::ID
            )]
            #[account()]
            pub sysvar_instructions: UncheckedAccount<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, DeployLegacyCtxBumps>
        for DeployLegacyCtx<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut DeployLegacyCtxBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let deployment: anchor_lang::accounts::account::Account<Deployment> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("deployment"))?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let hashlist = &__accounts[0];
                *__accounts = &__accounts[1..];
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let fungible_mint: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                let fungible_escrow_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_escrow_token_account"))?;
                let fungible_metadata: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_metadata"))?;
                let non_fungible_mint: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                let non_fungible_metadata: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_metadata"))?;
                let non_fungible_master_edition: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_master_edition"))?;
                let non_fungible_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_token_account"))?;
                let inscription_summary: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription_summary"))?;
                let inscription: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription"))?;
                let inscription_v3: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription_v3"))?;
                let inscription_data: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription_data"))?;
                let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let associated_token_program: anchor_lang::accounts::program::Program<
                    AssociatedToken,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("associated_token_program"))?;
                let inscriptions_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscriptions_program"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let metadata_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("metadata_program"))?;
                let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["hashlist".as_bytes(), deployment.key().as_ref()],
                    __program_id,
                );
                __bumps.hashlist = __bump;
                if hashlist.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("hashlist")
                            .with_pubkeys((hashlist.key(), __pda_address)),
                    );
                }
                let hashlist = {
                    let actual_field = AsRef::<AccountInfo>::as_ref(&hashlist);
                    let actual_owner = actual_field.owner;
                    let space = 8 + 32 + 4;
                    let pa: anchor_lang::accounts::account::Account<Hashlist> = if !false
                        || actual_owner
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let __current_lamports = hashlist.lamports();
                        if __current_lamports == 0 {
                            let space = space;
                            let lamports = __anchor_rent.minimum_balance(space);
                            let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                from: payer.to_account_info(),
                                to: hashlist.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::create_account(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist".as_bytes(),
                                                deployment.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                lamports,
                                space as u64,
                                __program_id,
                            )?;
                        } else {
                            if payer.key() == hashlist.key() {
                                return Err(
                                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                            error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .name(),
                                            error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .into(),
                                            error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .to_string(),
                                            error_origin: Some(
                                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                    filename: "programs/libreplex_fair_launch/src/instructions/deploy_legacy.rs",
                                                    line: 34u32,
                                                }),
                                            ),
                                            compared_values: None,
                                        })
                                        .with_pubkeys((payer.key(), hashlist.key())),
                                );
                            }
                            let required_lamports = __anchor_rent
                                .minimum_balance(space)
                                .max(1)
                                .saturating_sub(__current_lamports);
                            if required_lamports > 0 {
                                let cpi_accounts = anchor_lang::system_program::Transfer {
                                    from: payer.to_account_info(),
                                    to: hashlist.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::transfer(
                                    cpi_context,
                                    required_lamports,
                                )?;
                            }
                            let cpi_accounts = anchor_lang::system_program::Allocate {
                                account_to_allocate: hashlist.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::allocate(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist".as_bytes(),
                                                deployment.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                space as u64,
                            )?;
                            let cpi_accounts = anchor_lang::system_program::Assign {
                                account_to_assign: hashlist.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::assign(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist".as_bytes(),
                                                deployment.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                __program_id,
                            )?;
                        }
                        match anchor_lang::accounts::account::Account::try_from_unchecked(
                            &hashlist,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("hashlist")),
                        }
                    } else {
                        match anchor_lang::accounts::account::Account::try_from(
                            &hashlist,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("hashlist")),
                        }
                    };
                    if false {
                        if space != actual_field.data_len() {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSpace,
                                    )
                                    .with_account_name("hashlist")
                                    .with_values((space, actual_field.data_len())),
                            );
                        }
                        if actual_owner != __program_id {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintOwner,
                                    )
                                    .with_account_name("hashlist")
                                    .with_pubkeys((*actual_owner, *__program_id)),
                            );
                        }
                        {
                            let required_lamports = __anchor_rent.minimum_balance(space);
                            if pa.to_account_info().lamports() < required_lamports {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                        )
                                        .with_account_name("hashlist"),
                                );
                            }
                        }
                    }
                    pa
                };
                if !AsRef::<AccountInfo>::as_ref(&hashlist).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("hashlist"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        hashlist.to_account_info().lamports(),
                        hashlist.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("hashlist"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["deployment".as_bytes(), deployment.ticker.as_bytes()],
                    &__program_id,
                );
                __bumps.deployment = __bump;
                if deployment.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("deployment")
                            .with_pubkeys((deployment.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !(deployment.creator == payer.key()) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("payer"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_escrow_token_account)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_escrow_token_account"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_metadata).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_metadata"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_metadata).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_metadata"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_master_edition)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_master_edition"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_token_account).is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_token_account"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription_summary).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription_summary"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription_v3).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription_v3"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription_data).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription_data"),
                    );
                }
                if !(inscriptions_program.key() == libreplex_inscriptions::ID) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("inscriptions_program"),
                    );
                }
                if !(metadata_program.key() == mpl_token_metadata::ID) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("metadata_program"),
                    );
                }
                if !(sysvar_instructions.key() == sysvar_instructions_program::ID) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("sysvar_instructions"),
                    );
                }
                Ok(DeployLegacyCtx {
                    deployment,
                    hashlist,
                    payer,
                    fungible_mint,
                    fungible_escrow_token_account,
                    fungible_metadata,
                    non_fungible_mint,
                    non_fungible_metadata,
                    non_fungible_master_edition,
                    non_fungible_token_account,
                    inscription_summary,
                    inscription,
                    inscription_v3,
                    inscription_data,
                    token_program,
                    associated_token_program,
                    inscriptions_program,
                    system_program,
                    metadata_program,
                    sysvar_instructions,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for DeployLegacyCtx<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.deployment.to_account_infos());
                account_infos.extend(self.hashlist.to_account_infos());
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.fungible_mint.to_account_infos());
                account_infos
                    .extend(self.fungible_escrow_token_account.to_account_infos());
                account_infos.extend(self.fungible_metadata.to_account_infos());
                account_infos.extend(self.non_fungible_mint.to_account_infos());
                account_infos.extend(self.non_fungible_metadata.to_account_infos());
                account_infos
                    .extend(self.non_fungible_master_edition.to_account_infos());
                account_infos.extend(self.non_fungible_token_account.to_account_infos());
                account_infos.extend(self.inscription_summary.to_account_infos());
                account_infos.extend(self.inscription.to_account_infos());
                account_infos.extend(self.inscription_v3.to_account_infos());
                account_infos.extend(self.inscription_data.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.associated_token_program.to_account_infos());
                account_infos.extend(self.inscriptions_program.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.metadata_program.to_account_infos());
                account_infos.extend(self.sysvar_instructions.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for DeployLegacyCtx<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.deployment.to_account_metas(None));
                account_metas.extend(self.hashlist.to_account_metas(None));
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.fungible_mint.to_account_metas(None));
                account_metas
                    .extend(self.fungible_escrow_token_account.to_account_metas(None));
                account_metas.extend(self.fungible_metadata.to_account_metas(None));
                account_metas.extend(self.non_fungible_mint.to_account_metas(None));
                account_metas.extend(self.non_fungible_metadata.to_account_metas(None));
                account_metas
                    .extend(self.non_fungible_master_edition.to_account_metas(None));
                account_metas
                    .extend(self.non_fungible_token_account.to_account_metas(None));
                account_metas.extend(self.inscription_summary.to_account_metas(None));
                account_metas.extend(self.inscription.to_account_metas(None));
                account_metas.extend(self.inscription_v3.to_account_metas(None));
                account_metas.extend(self.inscription_data.to_account_metas(None));
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas
                    .extend(self.associated_token_program.to_account_metas(None));
                account_metas.extend(self.inscriptions_program.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.metadata_program.to_account_metas(None));
                account_metas.extend(self.sysvar_instructions.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for DeployLegacyCtx<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                    .map_err(|e| e.with_account_name("deployment"))?;
                anchor_lang::AccountsExit::exit(&self.hashlist, program_id)
                    .map_err(|e| e.with_account_name("hashlist"))?;
                anchor_lang::AccountsExit::exit(&self.payer, program_id)
                    .map_err(|e| e.with_account_name("payer"))?;
                anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.fungible_escrow_token_account,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("fungible_escrow_token_account"))?;
                anchor_lang::AccountsExit::exit(&self.fungible_metadata, program_id)
                    .map_err(|e| e.with_account_name("fungible_metadata"))?;
                anchor_lang::AccountsExit::exit(&self.non_fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                anchor_lang::AccountsExit::exit(&self.non_fungible_metadata, program_id)
                    .map_err(|e| e.with_account_name("non_fungible_metadata"))?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_master_edition,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_master_edition"))?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_token_account,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_token_account"))?;
                anchor_lang::AccountsExit::exit(&self.inscription_summary, program_id)
                    .map_err(|e| e.with_account_name("inscription_summary"))?;
                anchor_lang::AccountsExit::exit(&self.inscription, program_id)
                    .map_err(|e| e.with_account_name("inscription"))?;
                anchor_lang::AccountsExit::exit(&self.inscription_v3, program_id)
                    .map_err(|e| e.with_account_name("inscription_v3"))?;
                anchor_lang::AccountsExit::exit(&self.inscription_data, program_id)
                    .map_err(|e| e.with_account_name("inscription_data"))?;
                Ok(())
            }
        }
        pub struct DeployLegacyCtxBumps {
            pub deployment: u8,
            pub hashlist: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DeployLegacyCtxBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DeployLegacyCtxBumps",
                    "deployment",
                    &self.deployment,
                    "hashlist",
                    &&self.hashlist,
                )
            }
        }
        impl Default for DeployLegacyCtxBumps {
            fn default() -> Self {
                DeployLegacyCtxBumps {
                    deployment: u8::MAX,
                    hashlist: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for DeployLegacyCtx<'info>
        where
            'info: 'info,
        {
            type Bumps = DeployLegacyCtxBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_deploy_legacy_ctx {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`DeployLegacyCtx`].
            pub struct DeployLegacyCtx {
                pub deployment: Pubkey,
                pub hashlist: Pubkey,
                pub payer: Pubkey,
                pub fungible_mint: Pubkey,
                pub fungible_escrow_token_account: Pubkey,
                pub fungible_metadata: Pubkey,
                pub non_fungible_mint: Pubkey,
                pub non_fungible_metadata: Pubkey,
                pub non_fungible_master_edition: Pubkey,
                pub non_fungible_token_account: Pubkey,
                pub inscription_summary: Pubkey,
                pub inscription: Pubkey,
                pub inscription_v3: Pubkey,
                pub inscription_data: Pubkey,
                pub token_program: Pubkey,
                pub associated_token_program: Pubkey,
                pub inscriptions_program: Pubkey,
                pub system_program: Pubkey,
                pub metadata_program: Pubkey,
                pub sysvar_instructions: Pubkey,
            }
            impl borsh::ser::BorshSerialize for DeployLegacyCtx
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                    borsh::BorshSerialize::serialize(&self.hashlist, writer)?;
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.fungible_escrow_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.fungible_metadata, writer)?;
                    borsh::BorshSerialize::serialize(&self.non_fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_metadata,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_master_edition,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.inscription_summary, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscription, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscription_v3, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscription_data, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.associated_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.inscriptions_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.metadata_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.sysvar_instructions, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for DeployLegacyCtx {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.hashlist,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_mint,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_escrow_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_metadata,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_mint,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_metadata,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_master_edition,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription_summary,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription_v3,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription_data,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.associated_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.inscriptions_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.metadata_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.sysvar_instructions,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_deploy_legacy_ctx {
            use super::*;
            /// Generated CPI struct of the accounts for [`DeployLegacyCtx`].
            pub struct DeployLegacyCtx<'info> {
                pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub hashlist: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_escrow_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_metadata: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_metadata: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_master_edition: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription_summary: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription_v3: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription_data: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscriptions_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub metadata_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for DeployLegacyCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.hashlist),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_mint),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_escrow_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_metadata),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_mint),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_metadata),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_master_edition),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription_summary),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription_v3),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription_data),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.associated_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.inscriptions_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.metadata_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.sysvar_instructions),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for DeployLegacyCtx<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.hashlist),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_escrow_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_metadata,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_metadata,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_master_edition,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription_summary,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription_v3,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription_data,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.associated_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscriptions_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.metadata_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.sysvar_instructions,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub fn deploy<'f>(
            ctx: Context<'_, '_, '_, 'f, DeployLegacyCtx<'f>>,
        ) -> Result<()> {
            let hashlist = &mut ctx.accounts.hashlist;
            let deployment = &mut ctx.accounts.deployment;
            if deployment.require_creator_cosign {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Only launches without creator cosign can currently use v1 methods",
                        ),
                    );
                }
            }
            let system_program = &ctx.accounts.system_program;
            let payer = &ctx.accounts.payer;
            let inscriptions_program = &ctx.accounts.inscriptions_program;
            let inscription_summary = &ctx.accounts.inscription_summary;
            let inscription_v3 = &ctx.accounts.inscription_v3;
            let inscription_data = &ctx.accounts.inscription_data;
            let fungible_mint = &ctx.accounts.fungible_mint;
            let fungible_metadata = &ctx.accounts.fungible_metadata;
            let non_fungible_mint = &ctx.accounts.non_fungible_mint;
            let non_fungible_metadata = &ctx.accounts.non_fungible_metadata;
            let non_fungible_master_edition = &ctx.accounts.non_fungible_master_edition;
            let non_fungible_token_account = &ctx.accounts.non_fungible_token_account;
            let sysvar_instructions = &ctx.accounts.sysvar_instructions;
            let token_program = &ctx.accounts.token_program;
            let metadata_program = &ctx.accounts.metadata_program;
            let associated_token_program = &ctx.accounts.associated_token_program;
            let fungible_escrow_token_account = &ctx
                .accounts
                .fungible_escrow_token_account;
            deploy_legacy_logic(
                hashlist,
                deployment,
                fungible_mint,
                payer,
                fungible_metadata,
                fungible_escrow_token_account,
                metadata_program,
                token_program,
                associated_token_program,
                system_program,
                sysvar_instructions,
                non_fungible_mint,
                non_fungible_metadata,
                non_fungible_master_edition,
                non_fungible_token_account,
                ctx.bumps.deployment,
            )?;
            deploy_legacy_inscriptions(
                inscriptions_program,
                inscription_summary,
                non_fungible_mint,
                inscription_v3,
                system_program,
                payer,
                inscription_data,
                deployment,
            )?;
            Ok(())
        }
        pub fn deploy_legacy_inscriptions<'f>(
            inscriptions_program: &UncheckedAccount<'f>,
            inscription_summary: &UncheckedAccount<'f>,
            non_fungible_mint: &Signer<'f>,
            inscription_v3: &UncheckedAccount<'f>,
            system_program: &Program<'f, System>,
            payer: &Signer<'f>,
            inscription_data: &UncheckedAccount<'f>,
            deployment: &mut Account<'f, Deployment>,
        ) -> Result<()> {
            libreplex_inscriptions::cpi::create_inscription_v3(
                CpiContext::new(
                    inscriptions_program.to_account_info(),
                    CreateInscriptionV3 {
                        inscription_summary: inscription_summary.to_account_info(),
                        root: non_fungible_mint.to_account_info(),
                        signer: non_fungible_mint.to_account_info(),
                        inscription_v3: inscription_v3.to_account_info(),
                        system_program: system_program.to_account_info(),
                        payer: payer.to_account_info(),
                        inscription_data: inscription_data.to_account_info(),
                    },
                ),
                libreplex_inscriptions::instructions::CreateInscriptionInputV3 {
                    authority: Some(payer.key()),
                    signer_type: SignerType::Root,
                    validation_hash: None,
                },
            )?;
            let data_bytes = deployment.deployment_template.clone().into_bytes();
            libreplex_inscriptions::cpi::resize_inscription_v3(
                CpiContext::new(
                    inscriptions_program.to_account_info(),
                    ResizeInscriptionV3 {
                        authority: payer.to_account_info(),
                        system_program: system_program.to_account_info(),
                        payer: payer.to_account_info(),
                        inscription_data: inscription_data.to_account_info(),
                        inscription_v3: inscription_v3.to_account_info(),
                    },
                ),
                libreplex_inscriptions::instructions::ResizeInscriptionInput {
                    change: data_bytes.len() as i32 - 8,
                    expected_start_size: 8,
                    target_size: data_bytes.len() as u32,
                },
            )?;
            libreplex_inscriptions::cpi::write_to_inscription_v3(
                CpiContext::new(
                    inscriptions_program.to_account_info(),
                    WriteToInscriptionV3 {
                        authority: payer.to_account_info(),
                        payer: payer.to_account_info(),
                        inscription_v3: inscription_v3.to_account_info(),
                        system_program: system_program.to_account_info(),
                        inscription_data: inscription_data.to_account_info(),
                    },
                ),
                WriteToInscriptionInput {
                    data: data_bytes,
                    start_pos: 0,
                    media_type: Some("text/plain".to_owned()),
                    encoding_type: Some("ascii".to_owned()),
                },
            )?;
            libreplex_inscriptions::cpi::make_inscription_immutable_v3(
                CpiContext::new(
                    inscriptions_program.to_account_info(),
                    MakeInscriptionImmutableV3 {
                        payer: payer.to_account_info(),
                        authority: payer.to_account_info(),
                        inscription_summary: inscription_summary.to_account_info(),
                        inscription_v3: inscription_v3.to_account_info(),
                        system_program: system_program.to_account_info(),
                    },
                ),
            )?;
            Ok(())
        }
        pub fn deploy_legacy_logic<'f>(
            hashlist: &mut Account<'f, Hashlist>,
            deployment: &mut Account<'f, Deployment>,
            fungible_mint: &Signer<'f>,
            payer: &Signer<'f>,
            fungible_metadata: &UncheckedAccount<'f>,
            fungible_escrow_token_account: &UncheckedAccount<'f>,
            metadata_program: &UncheckedAccount<'f>,
            token_program: &Program<'f, Token>,
            associated_token_program: &Program<'f, AssociatedToken>,
            system_program: &Program<'f, System>,
            sysvar_instructions: &UncheckedAccount<'f>,
            non_fungible_mint: &Signer<'f>,
            non_fungible_metadata: &UncheckedAccount<'f>,
            non_fungible_master_edition: &UncheckedAccount<'f>,
            non_fungible_token_account: &UncheckedAccount<'f>,
            deployment_bump: u8,
        ) -> Result<()> {
            hashlist.deployment = deployment.key();
            deployment.require_creator_cosign = false;
            deployment.use_inscriptions = true;
            deployment.fungible_mint = fungible_mint.key();
            let deployment_seeds: &[&[u8]] = &[
                "deployment".as_bytes(),
                deployment.ticker.as_ref(),
                &[deployment_bump],
            ];
            check_deploy_allowed(deployment);
            create_mint_with_metadata_and_masteredition(
                MintAccounts {
                    authority_pda: deployment.to_account_info(),
                    payer: payer.to_account_info(),
                    nft_owner: deployment.to_account_info(),
                    nft_mint: fungible_mint.to_account_info(),
                    nft_mint_authority: deployment.to_account_info(),
                    nft_metadata: fungible_metadata.to_account_info(),
                    nft_master_edition: None,
                    token: Some(fungible_escrow_token_account.to_account_info()),
                    token_metadata_program: metadata_program.to_account_info(),
                    spl_token_program: token_program.to_account_info(),
                    spl_ata_program: associated_token_program.to_account_info(),
                    system_program: system_program.to_account_info(),
                    sysvar_instructions: sysvar_instructions.to_account_info(),
                },
                deployment_seeds,
                deployment.ticker.clone(),
                "".to_owned(),
                0,
                deployment.offchain_url.clone(),
                None,
                0,
                false,
                0,
                deployment.decimals,
                TokenStandard::Fungible,
            )?;
            create_mint_with_metadata_and_masteredition(
                MintAccounts {
                    authority_pda: deployment.to_account_info(),
                    payer: payer.to_account_info(),
                    nft_owner: deployment.to_account_info(),
                    nft_mint: non_fungible_mint.to_account_info(),
                    nft_mint_authority: deployment.to_account_info(),
                    nft_metadata: non_fungible_metadata.to_account_info(),
                    nft_master_edition: Some(
                        non_fungible_master_edition.to_account_info(),
                    ),
                    token: Some(non_fungible_token_account.to_account_info()),
                    token_metadata_program: metadata_program.to_account_info(),
                    spl_token_program: token_program.to_account_info(),
                    spl_ata_program: associated_token_program.to_account_info(),
                    system_program: system_program.to_account_info(),
                    sysvar_instructions: sysvar_instructions.to_account_info(),
                },
                deployment_seeds,
                deployment.ticker.clone(),
                "".to_owned(),
                0,
                deployment.offchain_url.clone(),
                None,
                0,
                false,
                1,
                0,
                TokenStandard::NonFungible,
            )?;
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &DeploymentActive {
                                ticker: deployment.ticker.clone(),
                                fungible_mint: fungible_mint.key(),
                            },
                        ),
                    ],
                );
            };
            Ok(())
        }
    }
    pub use deploy_legacy::*;
    pub mod switch_deployment_type {
        use std::str::FromStr;
        use anchor_lang::{prelude::*, system_program};
        use crate::{
            check_deploy_allowed, Deployment, DeploymentConfig, HYBRID_DEPLOYMENT_TYPE,
        };
        pub mod sysvar_instructions_program {
            use anchor_lang::declare_id;
            /// The static program ID
            pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                6u8,
                167u8,
                213u8,
                23u8,
                24u8,
                123u8,
                209u8,
                102u8,
                53u8,
                218u8,
                212u8,
                4u8,
                85u8,
                253u8,
                194u8,
                192u8,
                193u8,
                36u8,
                198u8,
                143u8,
                33u8,
                86u8,
                117u8,
                165u8,
                219u8,
                186u8,
                203u8,
                95u8,
                8u8,
                0u8,
                0u8,
                0u8,
            ]);
            /// Confirms that a given pubkey is equivalent to the program ID
            pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
                id == &ID
            }
            /// Returns the program ID
            pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                ID
            }
        }
        #[instruction(deployment_type:u8)]
        pub struct SwitchDeploymentTypeCtx<'info> {
            #[account(mut)]
            pub deployment: Account<'info, Deployment>,
            #[account(
                mut,
                seeds = ["deployment_config".as_bytes(),
                deployment.key().as_ref()],
                bump,
                constraint = deployment_config.cosigner_program_id.eq(
                    &Pubkey::from_str(
                        "LiquGRWGrp8JKspo8zDDu6qpRmX1p6U3PX2USqiE1eg"
                    ).unwrap()
                )
            )]
            pub deployment_config: Account<'info, DeploymentConfig>,
            #[account(mut)]
            pub payer: Signer<'info>,
            #[account()]
            pub system_program: Program<'info, System>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, SwitchDeploymentTypeCtxBumps>
        for SwitchDeploymentTypeCtx<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut SwitchDeploymentTypeCtxBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let mut __ix_data = __ix_data;
                struct __Args {
                    deployment_type: u8,
                }
                impl borsh::ser::BorshSerialize for __Args
                where
                    u8: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.deployment_type, writer)?;
                        Ok(())
                    }
                }
                impl borsh::de::BorshDeserialize for __Args
                where
                    u8: borsh::BorshDeserialize,
                {
                    fn deserialize_reader<R: borsh::maybestd::io::Read>(
                        reader: &mut R,
                    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                        Ok(Self {
                            deployment_type: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                        })
                    }
                }
                let __Args { deployment_type } = __Args::deserialize(&mut __ix_data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                    })?;
                let deployment: anchor_lang::accounts::account::Account<Deployment> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("deployment"))?;
                let deployment_config: anchor_lang::accounts::account::Account<
                    DeploymentConfig,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("deployment_config"))?;
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["deployment_config".as_bytes(), deployment.key().as_ref()],
                    &__program_id,
                );
                __bumps.deployment_config = __bump;
                if deployment_config.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("deployment_config")
                            .with_pubkeys((deployment_config.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&deployment_config).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment_config"),
                    );
                }
                if !(deployment_config
                    .cosigner_program_id
                    .eq(
                        &Pubkey::from_str("LiquGRWGrp8JKspo8zDDu6qpRmX1p6U3PX2USqiE1eg")
                            .unwrap(),
                    ))
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("deployment_config"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("payer"),
                    );
                }
                Ok(SwitchDeploymentTypeCtx {
                    deployment,
                    deployment_config,
                    payer,
                    system_program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for SwitchDeploymentTypeCtx<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.deployment.to_account_infos());
                account_infos.extend(self.deployment_config.to_account_infos());
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for SwitchDeploymentTypeCtx<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.deployment.to_account_metas(None));
                account_metas.extend(self.deployment_config.to_account_metas(None));
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for SwitchDeploymentTypeCtx<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                    .map_err(|e| e.with_account_name("deployment"))?;
                anchor_lang::AccountsExit::exit(&self.deployment_config, program_id)
                    .map_err(|e| e.with_account_name("deployment_config"))?;
                anchor_lang::AccountsExit::exit(&self.payer, program_id)
                    .map_err(|e| e.with_account_name("payer"))?;
                Ok(())
            }
        }
        pub struct SwitchDeploymentTypeCtxBumps {
            pub deployment_config: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SwitchDeploymentTypeCtxBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SwitchDeploymentTypeCtxBumps",
                    "deployment_config",
                    &&self.deployment_config,
                )
            }
        }
        impl Default for SwitchDeploymentTypeCtxBumps {
            fn default() -> Self {
                SwitchDeploymentTypeCtxBumps {
                    deployment_config: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for SwitchDeploymentTypeCtx<'info>
        where
            'info: 'info,
        {
            type Bumps = SwitchDeploymentTypeCtxBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_switch_deployment_type_ctx {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`SwitchDeploymentTypeCtx`].
            pub struct SwitchDeploymentTypeCtx {
                pub deployment: Pubkey,
                pub deployment_config: Pubkey,
                pub payer: Pubkey,
                pub system_program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for SwitchDeploymentTypeCtx
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                    borsh::BorshSerialize::serialize(&self.deployment_config, writer)?;
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for SwitchDeploymentTypeCtx {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment_config,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_switch_deployment_type_ctx {
            use super::*;
            /// Generated CPI struct of the accounts for [`SwitchDeploymentTypeCtx`].
            pub struct SwitchDeploymentTypeCtx<'info> {
                pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub deployment_config: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for SwitchDeploymentTypeCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment_config),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info>
            for SwitchDeploymentTypeCtx<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment_config,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub fn switch_deployment_type(
            ctx: Context<SwitchDeploymentTypeCtx>,
            deployment_type: u8,
        ) -> Result<()> {
            let deployment = &mut ctx.accounts.deployment;
            if deployment_type != HYBRID_DEPLOYMENT_TYPE {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("Can only switch to hybrid at the moment"),
                    );
                }
            }
            check_deploy_allowed(deployment);
            deployment.deployment_type = deployment_type;
            deployment.fungible_mint = system_program::ID;
            Ok(())
        }
    }
    pub use switch_deployment_type::*;
    pub mod mint_legacy {
        use anchor_lang::prelude::*;
        use anchor_spl::{associated_token::AssociatedToken, token::{Mint, Token}};
        use libreplex_inscriptions::InscriptionSummary;
        use libreplex_shared::sysvar_instructions_program;
        use crate::{
            errors::FairLaunchError, Deployment, HashlistMarker, mint_legacy_logic,
        };
        pub struct MintLegacyCtx<'info> {
            #[account(
                mut,
                seeds = ["deployment".as_ref(),
                deployment.ticker.as_ref()],
                bump
            )]
            pub deployment: Account<'info, Deployment>,
            /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
            #[account(
                mut,
                seeds = ["hashlist".as_bytes(),
                deployment.key().as_ref()],
                bump,
            )]
            pub hashlist: UncheckedAccount<'info>,
            #[account(
                init,
                space = 8,
                payer = payer,
                seeds = ["hashlist_marker".as_bytes(),
                deployment.key().as_ref(),
                non_fungible_mint.key().as_ref()],
                bump,
            )]
            pub hashlist_marker: Account<'info, HashlistMarker>,
            #[account(mut)]
            pub payer: Signer<'info>,
            /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
            #[account(mut)]
            pub inscriber: UncheckedAccount<'info>,
            #[account(
                mut,
                constraint = deployment.fungible_mint = = fungible_mint.key()
            )]
            pub fungible_mint: Account<'info, Mint>,
            /// CHECK: Checked in logic, created as necessary
            #[account(mut)]
            pub fungible_token_account_escrow: UncheckedAccount<'info>,
            #[account(
                init,
                payer = payer,
                mint::decimals = 0,
                mint::freeze_authority = deployment,
                mint::authority = deployment
            )]
            pub non_fungible_mint: Account<'info, Mint>,
            /// CHECK: passed in via CPI to mpl_token_metadata program
            #[account(mut)]
            pub non_fungible_token_account: UncheckedAccount<'info>,
            /// CHECK: passed in via CPI to mpl_token_metadata program
            #[account(mut)]
            pub non_fungible_metadata: UncheckedAccount<'info>,
            /// CHECK: passed in via CPI to mpl_token_metadata program
            #[account(mut)]
            pub non_fungible_masteredition: UncheckedAccount<'info>,
            #[account(mut)]
            pub inscription_summary: Account<'info, InscriptionSummary>,
            /// CHECK: passed in via CPI to libreplex_inscriptions program
            #[account(mut)]
            pub inscription: UncheckedAccount<'info>,
            /// CHECK: passed in via CPI to libreplex_inscriptions program
            #[account(mut)]
            pub inscription_v3: UncheckedAccount<'info>,
            /// CHECK: sent via CPI to libreplex_inscriptions_program
            #[account(mut)]
            pub inscription_data: UncheckedAccount<'info>,
            #[account()]
            pub token_program: Program<'info, Token>,
            #[account()]
            pub associated_token_program: Program<'info, AssociatedToken>,
            /// CHECK: Checked in constraint
            #[account(
                constraint = inscriptions_program.key()= = libreplex_inscriptions::ID
            )]
            pub inscriptions_program: UncheckedAccount<'info>,
            #[account()]
            pub system_program: Program<'info, System>,
            /// CHECK: Checked in constraint
            #[account(
                constraint = sysvar_instructions.key()= = sysvar_instructions_program::ID
            )]
            sysvar_instructions: UncheckedAccount<'info>,
            /// CHECK: address checked
            #[account(address = mpl_token_metadata::ID)]
            pub metadata_program: UncheckedAccount<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, MintLegacyCtxBumps>
        for MintLegacyCtx<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut MintLegacyCtxBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let deployment: anchor_lang::accounts::account::Account<Deployment> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("deployment"))?;
                let hashlist: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("hashlist"))?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let hashlist_marker = &__accounts[0];
                *__accounts = &__accounts[1..];
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let inscriber: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscriber"))?;
                let fungible_mint: anchor_lang::accounts::account::Account<Mint> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                let fungible_token_account_escrow: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_token_account_escrow"))?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let non_fungible_mint = &__accounts[0];
                *__accounts = &__accounts[1..];
                let non_fungible_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_token_account"))?;
                let non_fungible_metadata: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_metadata"))?;
                let non_fungible_masteredition: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_masteredition"))?;
                let inscription_summary: anchor_lang::accounts::account::Account<
                    InscriptionSummary,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription_summary"))?;
                let inscription: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription"))?;
                let inscription_v3: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription_v3"))?;
                let inscription_data: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription_data"))?;
                let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let associated_token_program: anchor_lang::accounts::program::Program<
                    AssociatedToken,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("associated_token_program"))?;
                let inscriptions_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscriptions_program"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                let metadata_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("metadata_program"))?;
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        "hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref(),
                    ],
                    __program_id,
                );
                __bumps.hashlist_marker = __bump;
                if hashlist_marker.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("hashlist_marker")
                            .with_pubkeys((hashlist_marker.key(), __pda_address)),
                    );
                }
                let hashlist_marker = {
                    let actual_field = AsRef::<AccountInfo>::as_ref(&hashlist_marker);
                    let actual_owner = actual_field.owner;
                    let space = 8;
                    let pa: anchor_lang::accounts::account::Account<HashlistMarker> = if !false
                        || actual_owner
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let __current_lamports = hashlist_marker.lamports();
                        if __current_lamports == 0 {
                            let space = space;
                            let lamports = __anchor_rent.minimum_balance(space);
                            let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                from: payer.to_account_info(),
                                to: hashlist_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::create_account(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist_marker".as_bytes(),
                                                deployment.key().as_ref(),
                                                non_fungible_mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                lamports,
                                space as u64,
                                __program_id,
                            )?;
                        } else {
                            if payer.key() == hashlist_marker.key() {
                                return Err(
                                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                            error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .name(),
                                            error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .into(),
                                            error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .to_string(),
                                            error_origin: Some(
                                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                    filename: "programs/libreplex_fair_launch/src/instructions/mint_legacy.rs",
                                                    line: 20u32,
                                                }),
                                            ),
                                            compared_values: None,
                                        })
                                        .with_pubkeys((payer.key(), hashlist_marker.key())),
                                );
                            }
                            let required_lamports = __anchor_rent
                                .minimum_balance(space)
                                .max(1)
                                .saturating_sub(__current_lamports);
                            if required_lamports > 0 {
                                let cpi_accounts = anchor_lang::system_program::Transfer {
                                    from: payer.to_account_info(),
                                    to: hashlist_marker.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::transfer(
                                    cpi_context,
                                    required_lamports,
                                )?;
                            }
                            let cpi_accounts = anchor_lang::system_program::Allocate {
                                account_to_allocate: hashlist_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::allocate(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist_marker".as_bytes(),
                                                deployment.key().as_ref(),
                                                non_fungible_mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                space as u64,
                            )?;
                            let cpi_accounts = anchor_lang::system_program::Assign {
                                account_to_assign: hashlist_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::assign(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist_marker".as_bytes(),
                                                deployment.key().as_ref(),
                                                non_fungible_mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                __program_id,
                            )?;
                        }
                        match anchor_lang::accounts::account::Account::try_from_unchecked(
                            &hashlist_marker,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("hashlist_marker")),
                        }
                    } else {
                        match anchor_lang::accounts::account::Account::try_from(
                            &hashlist_marker,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("hashlist_marker")),
                        }
                    };
                    if false {
                        if space != actual_field.data_len() {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSpace,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_values((space, actual_field.data_len())),
                            );
                        }
                        if actual_owner != __program_id {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintOwner,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_pubkeys((*actual_owner, *__program_id)),
                            );
                        }
                        {
                            let required_lamports = __anchor_rent.minimum_balance(space);
                            if pa.to_account_info().lamports() < required_lamports {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                        )
                                        .with_account_name("hashlist_marker"),
                                );
                            }
                        }
                    }
                    pa
                };
                if !AsRef::<AccountInfo>::as_ref(&hashlist_marker).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("hashlist_marker"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        hashlist_marker.to_account_info().lamports(),
                        hashlist_marker.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("hashlist_marker"),
                    );
                }
                let __anchor_rent = Rent::get()?;
                let non_fungible_mint: anchor_lang::accounts::account::Account<Mint> = {
                    let owner_program = AsRef::<AccountInfo>::as_ref(&non_fungible_mint)
                        .owner;
                    if !false
                        || owner_program
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let __current_lamports = non_fungible_mint.lamports();
                        if __current_lamports == 0 {
                            let space = ::anchor_spl::token::Mint::LEN;
                            let lamports = __anchor_rent.minimum_balance(space);
                            let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                from: payer.to_account_info(),
                                to: non_fungible_mint.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::create_account(
                                cpi_context.with_signer(&[]),
                                lamports,
                                space as u64,
                                &token_program.key(),
                            )?;
                        } else {
                            if payer.key() == non_fungible_mint.key() {
                                return Err(
                                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                            error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .name(),
                                            error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .into(),
                                            error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .to_string(),
                                            error_origin: Some(
                                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                    filename: "programs/libreplex_fair_launch/src/instructions/mint_legacy.rs",
                                                    line: 20u32,
                                                }),
                                            ),
                                            compared_values: None,
                                        })
                                        .with_pubkeys((payer.key(), non_fungible_mint.key())),
                                );
                            }
                            let required_lamports = __anchor_rent
                                .minimum_balance(::anchor_spl::token::Mint::LEN)
                                .max(1)
                                .saturating_sub(__current_lamports);
                            if required_lamports > 0 {
                                let cpi_accounts = anchor_lang::system_program::Transfer {
                                    from: payer.to_account_info(),
                                    to: non_fungible_mint.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::transfer(
                                    cpi_context,
                                    required_lamports,
                                )?;
                            }
                            let cpi_accounts = anchor_lang::system_program::Allocate {
                                account_to_allocate: non_fungible_mint.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::allocate(
                                cpi_context.with_signer(&[]),
                                ::anchor_spl::token::Mint::LEN as u64,
                            )?;
                            let cpi_accounts = anchor_lang::system_program::Assign {
                                account_to_assign: non_fungible_mint.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::assign(
                                cpi_context.with_signer(&[]),
                                &token_program.key(),
                            )?;
                        }
                        let cpi_program = token_program.to_account_info();
                        let accounts = ::anchor_spl::token_interface::InitializeMint2 {
                            mint: non_fungible_mint.to_account_info(),
                        };
                        let cpi_ctx = anchor_lang::context::CpiContext::new(
                            cpi_program,
                            accounts,
                        );
                        ::anchor_spl::token_interface::initialize_mint2(
                            cpi_ctx,
                            0,
                            &deployment.key(),
                            Option::<
                                &anchor_lang::prelude::Pubkey,
                            >::Some(&deployment.key()),
                        )?;
                    }
                    let pa: anchor_lang::accounts::account::Account<Mint> = match anchor_lang::accounts::account::Account::try_from_unchecked(
                        &non_fungible_mint,
                    ) {
                        Ok(val) => val,
                        Err(e) => return Err(e.with_account_name("non_fungible_mint")),
                    };
                    if false {
                        if pa.mint_authority
                            != anchor_lang::solana_program::program_option::COption::Some(
                                deployment.key(),
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMintMintAuthority,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        if pa
                            .freeze_authority
                            .as_ref()
                            .map(|fa| {
                                Option::<
                                    &anchor_lang::prelude::Pubkey,
                                >::Some(&deployment.key())
                                    .as_ref()
                                    .map(|expected_fa| fa != *expected_fa)
                                    .unwrap_or(true)
                            })
                            .unwrap_or(
                                Option::<
                                    &anchor_lang::prelude::Pubkey,
                                >::Some(&deployment.key())
                                    .is_some(),
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMintFreezeAuthority,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        if pa.decimals != 0 {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMintDecimals,
                                    )
                                    .with_account_name("non_fungible_mint")
                                    .with_values((pa.decimals, 0)),
                            );
                        }
                        if owner_program != &token_program.key() {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMintTokenProgram,
                                    )
                                    .with_account_name("non_fungible_mint")
                                    .with_pubkeys((*owner_program, token_program.key())),
                            );
                        }
                    }
                    pa
                };
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_signer {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSigner,
                            )
                            .with_account_name("non_fungible_mint"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        non_fungible_mint.to_account_info().lamports(),
                        non_fungible_mint.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("non_fungible_mint"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["deployment".as_ref(), deployment.ticker.as_ref()],
                    &__program_id,
                );
                __bumps.deployment = __bump;
                if deployment.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("deployment")
                            .with_pubkeys((deployment.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["hashlist".as_bytes(), deployment.key().as_ref()],
                    &__program_id,
                );
                __bumps.hashlist = __bump;
                if hashlist.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("hashlist")
                            .with_pubkeys((hashlist.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&hashlist).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("hashlist"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("payer"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscriber).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscriber"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_mint"),
                    );
                }
                if !(deployment.fungible_mint == fungible_mint.key()) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("fungible_mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_token_account_escrow)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_token_account_escrow"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_token_account).is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_token_account"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_metadata).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_metadata"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_masteredition).is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_masteredition"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription_summary).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription_summary"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription_v3).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription_v3"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription_data).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription_data"),
                    );
                }
                if !(inscriptions_program.key() == libreplex_inscriptions::ID) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("inscriptions_program"),
                    );
                }
                if !(sysvar_instructions.key() == sysvar_instructions_program::ID) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("sysvar_instructions"),
                    );
                }
                {
                    let actual = metadata_program.key();
                    let expected = mpl_token_metadata::ID;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("metadata_program")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                Ok(MintLegacyCtx {
                    deployment,
                    hashlist,
                    hashlist_marker,
                    payer,
                    inscriber,
                    fungible_mint,
                    fungible_token_account_escrow,
                    non_fungible_mint,
                    non_fungible_token_account,
                    non_fungible_metadata,
                    non_fungible_masteredition,
                    inscription_summary,
                    inscription,
                    inscription_v3,
                    inscription_data,
                    token_program,
                    associated_token_program,
                    inscriptions_program,
                    system_program,
                    sysvar_instructions,
                    metadata_program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for MintLegacyCtx<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.deployment.to_account_infos());
                account_infos.extend(self.hashlist.to_account_infos());
                account_infos.extend(self.hashlist_marker.to_account_infos());
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.inscriber.to_account_infos());
                account_infos.extend(self.fungible_mint.to_account_infos());
                account_infos
                    .extend(self.fungible_token_account_escrow.to_account_infos());
                account_infos.extend(self.non_fungible_mint.to_account_infos());
                account_infos.extend(self.non_fungible_token_account.to_account_infos());
                account_infos.extend(self.non_fungible_metadata.to_account_infos());
                account_infos.extend(self.non_fungible_masteredition.to_account_infos());
                account_infos.extend(self.inscription_summary.to_account_infos());
                account_infos.extend(self.inscription.to_account_infos());
                account_infos.extend(self.inscription_v3.to_account_infos());
                account_infos.extend(self.inscription_data.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.associated_token_program.to_account_infos());
                account_infos.extend(self.inscriptions_program.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.sysvar_instructions.to_account_infos());
                account_infos.extend(self.metadata_program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for MintLegacyCtx<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.deployment.to_account_metas(None));
                account_metas.extend(self.hashlist.to_account_metas(None));
                account_metas.extend(self.hashlist_marker.to_account_metas(None));
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.inscriber.to_account_metas(None));
                account_metas.extend(self.fungible_mint.to_account_metas(None));
                account_metas
                    .extend(self.fungible_token_account_escrow.to_account_metas(None));
                account_metas
                    .extend(self.non_fungible_mint.to_account_metas(Some(true)));
                account_metas
                    .extend(self.non_fungible_token_account.to_account_metas(None));
                account_metas.extend(self.non_fungible_metadata.to_account_metas(None));
                account_metas
                    .extend(self.non_fungible_masteredition.to_account_metas(None));
                account_metas.extend(self.inscription_summary.to_account_metas(None));
                account_metas.extend(self.inscription.to_account_metas(None));
                account_metas.extend(self.inscription_v3.to_account_metas(None));
                account_metas.extend(self.inscription_data.to_account_metas(None));
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas
                    .extend(self.associated_token_program.to_account_metas(None));
                account_metas.extend(self.inscriptions_program.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.sysvar_instructions.to_account_metas(None));
                account_metas.extend(self.metadata_program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for MintLegacyCtx<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                    .map_err(|e| e.with_account_name("deployment"))?;
                anchor_lang::AccountsExit::exit(&self.hashlist, program_id)
                    .map_err(|e| e.with_account_name("hashlist"))?;
                anchor_lang::AccountsExit::exit(&self.hashlist_marker, program_id)
                    .map_err(|e| e.with_account_name("hashlist_marker"))?;
                anchor_lang::AccountsExit::exit(&self.payer, program_id)
                    .map_err(|e| e.with_account_name("payer"))?;
                anchor_lang::AccountsExit::exit(&self.inscriber, program_id)
                    .map_err(|e| e.with_account_name("inscriber"))?;
                anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.fungible_token_account_escrow,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("fungible_token_account_escrow"))?;
                anchor_lang::AccountsExit::exit(&self.non_fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_token_account,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_token_account"))?;
                anchor_lang::AccountsExit::exit(&self.non_fungible_metadata, program_id)
                    .map_err(|e| e.with_account_name("non_fungible_metadata"))?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_masteredition,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_masteredition"))?;
                anchor_lang::AccountsExit::exit(&self.inscription_summary, program_id)
                    .map_err(|e| e.with_account_name("inscription_summary"))?;
                anchor_lang::AccountsExit::exit(&self.inscription, program_id)
                    .map_err(|e| e.with_account_name("inscription"))?;
                anchor_lang::AccountsExit::exit(&self.inscription_v3, program_id)
                    .map_err(|e| e.with_account_name("inscription_v3"))?;
                anchor_lang::AccountsExit::exit(&self.inscription_data, program_id)
                    .map_err(|e| e.with_account_name("inscription_data"))?;
                Ok(())
            }
        }
        pub struct MintLegacyCtxBumps {
            pub deployment: u8,
            pub hashlist: u8,
            pub hashlist_marker: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MintLegacyCtxBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "MintLegacyCtxBumps",
                    "deployment",
                    &self.deployment,
                    "hashlist",
                    &self.hashlist,
                    "hashlist_marker",
                    &&self.hashlist_marker,
                )
            }
        }
        impl Default for MintLegacyCtxBumps {
            fn default() -> Self {
                MintLegacyCtxBumps {
                    deployment: u8::MAX,
                    hashlist: u8::MAX,
                    hashlist_marker: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for MintLegacyCtx<'info>
        where
            'info: 'info,
        {
            type Bumps = MintLegacyCtxBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_mint_legacy_ctx {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`MintLegacyCtx`].
            pub struct MintLegacyCtx {
                pub deployment: Pubkey,
                pub hashlist: Pubkey,
                pub hashlist_marker: Pubkey,
                pub payer: Pubkey,
                pub inscriber: Pubkey,
                pub fungible_mint: Pubkey,
                pub fungible_token_account_escrow: Pubkey,
                pub non_fungible_mint: Pubkey,
                pub non_fungible_token_account: Pubkey,
                pub non_fungible_metadata: Pubkey,
                pub non_fungible_masteredition: Pubkey,
                pub inscription_summary: Pubkey,
                pub inscription: Pubkey,
                pub inscription_v3: Pubkey,
                pub inscription_data: Pubkey,
                pub token_program: Pubkey,
                pub associated_token_program: Pubkey,
                pub inscriptions_program: Pubkey,
                pub system_program: Pubkey,
                pub sysvar_instructions: Pubkey,
                pub metadata_program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for MintLegacyCtx
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                    borsh::BorshSerialize::serialize(&self.hashlist, writer)?;
                    borsh::BorshSerialize::serialize(&self.hashlist_marker, writer)?;
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscriber, writer)?;
                    borsh::BorshSerialize::serialize(&self.fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.fungible_token_account_escrow,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.non_fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_metadata,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_masteredition,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.inscription_summary, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscription, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscription_v3, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscription_data, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.associated_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.inscriptions_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.sysvar_instructions, writer)?;
                    borsh::BorshSerialize::serialize(&self.metadata_program, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for MintLegacyCtx {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.hashlist,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.hashlist_marker,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscriber,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_token_account_escrow,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_mint,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_metadata,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_masteredition,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription_summary,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription_v3,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription_data,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.associated_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.inscriptions_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.sysvar_instructions,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.metadata_program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_mint_legacy_ctx {
            use super::*;
            /// Generated CPI struct of the accounts for [`MintLegacyCtx`].
            pub struct MintLegacyCtx<'info> {
                pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub hashlist: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub inscriber: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_token_account_escrow: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_metadata: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_masteredition: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription_summary: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription_v3: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscription_data: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub inscriptions_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub metadata_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for MintLegacyCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.hashlist),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.hashlist_marker),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscriber),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_token_account_escrow),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_mint),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_metadata),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_masteredition),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription_summary),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription_v3),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription_data),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.associated_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.inscriptions_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.sysvar_instructions),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.metadata_program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for MintLegacyCtx<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.hashlist),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.hashlist_marker,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscriber,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_token_account_escrow,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_metadata,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_masteredition,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription_summary,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription_v3,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription_data,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.associated_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscriptions_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.sysvar_instructions,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.metadata_program,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub fn mint_legacy<'info>(
            ctx: Context<'_, '_, '_, 'info, MintLegacyCtx<'info>>,
        ) -> Result<()> {
            let deployment = &mut ctx.accounts.deployment;
            if deployment.require_creator_cosign {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Only launches without creator cosign can currently use v1 methods",
                        ),
                    );
                }
            }
            if deployment.number_of_tokens_issued >= deployment.max_number_of_tokens {
                return Err(FairLaunchError::MintedOut.into());
            }
            if deployment.migrated_from_legacy {
                return Err(FairLaunchError::LegacyMigrationsAreMintedOut.into());
            }
            let hashlist = &mut ctx.accounts.hashlist;
            let inscription_summary = &ctx.accounts.inscription_summary;
            let payer = &ctx.accounts.payer;
            let fungible_mint = &ctx.accounts.fungible_mint;
            let non_fungible_metadata = &ctx.accounts.non_fungible_metadata;
            let non_fungible_masteredition = &ctx.accounts.non_fungible_masteredition;
            let non_fungible_token_account = &ctx.accounts.non_fungible_token_account;
            let inscriptions_program = &ctx.accounts.inscriptions_program;
            let non_fungible_mint = &ctx.accounts.non_fungible_mint;
            let inscription_v3 = &ctx.accounts.inscription_v3;
            let inscription_data = &ctx.accounts.inscription_data;
            let fungible_token_account_escrow = &ctx
                .accounts
                .fungible_token_account_escrow;
            let token_program = &ctx.accounts.token_program;
            let system_program = &ctx.accounts.system_program;
            let metadata_program = &ctx.accounts.metadata_program;
            let inscriber = &ctx.accounts.inscriber;
            let associated_token_program = &ctx.accounts.associated_token_program;
            let sysvar_instructions_program = &ctx.accounts.sysvar_instructions;
            mint_legacy_logic(
                deployment,
                inscriptions_program,
                inscription_summary,
                non_fungible_mint,
                inscription_v3,
                system_program,
                payer,
                inscription_data,
                fungible_mint,
                fungible_token_account_escrow,
                associated_token_program,
                token_program,
                inscriber,
                non_fungible_token_account,
                non_fungible_metadata,
                non_fungible_masteredition,
                metadata_program,
                sysvar_instructions_program,
                hashlist,
                ctx.bumps.deployment,
            )?;
            Ok(())
        }
    }
    pub use mint_legacy::*;
    pub mod mint_legacy_logic {
        use anchor_lang::prelude::*;
        use anchor_spl::{
            associated_token::AssociatedToken,
            token::{
                mint_to, Mint, MintTo, Token, set_authority, SetAuthority,
                spl_token::instruction::AuthorityType,
            },
        };
        use libreplex_inscriptions::InscriptionSummary;
        use libreplex_inscriptions::{
            cpi::accounts::CreateInscriptionV3,
            cpi::accounts::MakeInscriptionImmutableV3,
            cpi::accounts::ResizeInscriptionV3, cpi::accounts::WriteToInscriptionV3,
            instructions::{SignerType, WriteToInscriptionInput},
        };
        use libreplex_shared::{
            SharedError,
            create_mint_metadata_and_masteredition::create_mint_with_metadata_and_masteredition,
            MintAccounts,
        };
        use mpl_token_metadata::types::{Creator, TokenStandard};
        use crate::{
            add_to_hashlist, errors::FairLaunchError, Deployment, MintEvent,
            STANDARD_DEPLOYMENT_TYPE,
        };
        pub fn mint_legacy_logic<'info>(
            deployment: &mut Account<'info, Deployment>,
            inscriptions_program: &UncheckedAccount<'info>,
            inscription_summary: &Account<'info, InscriptionSummary>,
            non_fungible_mint: &Account<'info, Mint>,
            inscription_v3: &UncheckedAccount<'info>,
            system_program: &Program<'info, System>,
            payer: &Signer<'info>,
            inscription_data: &UncheckedAccount<'info>,
            fungible_mint: &Account<'info, Mint>,
            fungible_token_account_escrow: &UncheckedAccount<'info>,
            associated_token_program: &Program<'info, AssociatedToken>,
            token_program: &Program<'info, Token>,
            inscriber: &UncheckedAccount<'info>,
            non_fungible_token_account: &UncheckedAccount<'info>,
            non_fungible_metadata: &UncheckedAccount<'info>,
            non_fungible_masteredition: &UncheckedAccount<'info>,
            metadata_program: &UncheckedAccount<'info>,
            sysvar_instructions_program: &UncheckedAccount<'info>,
            hashlist: &mut UncheckedAccount<'info>,
            bump_deployment: u8,
        ) -> Result<()> {
            if deployment.deployment_type != STANDARD_DEPLOYMENT_TYPE {
                return Err(FairLaunchError::IncorrectMintType.into());
            }
            deployment.number_of_tokens_issued += 1;
            if deployment.use_inscriptions {
                libreplex_inscriptions::cpi::create_inscription_v3(
                    CpiContext::new(
                        inscriptions_program.to_account_info(),
                        CreateInscriptionV3 {
                            inscription_summary: inscription_summary.to_account_info(),
                            root: non_fungible_mint.to_account_info(),
                            signer: non_fungible_mint.to_account_info(),
                            inscription_v3: inscription_v3.to_account_info(),
                            system_program: system_program.to_account_info(),
                            payer: payer.to_account_info(),
                            inscription_data: inscription_data.to_account_info(),
                        },
                    ),
                    libreplex_inscriptions::instructions::CreateInscriptionInputV3 {
                        authority: Some(payer.key()),
                        signer_type: SignerType::Root,
                        validation_hash: None,
                    },
                )?;
                let data_bytes = deployment.mint_template.clone().into_bytes();
                libreplex_inscriptions::cpi::resize_inscription_v3(
                    CpiContext::new(
                        inscriptions_program.to_account_info(),
                        ResizeInscriptionV3 {
                            authority: payer.to_account_info(),
                            system_program: system_program.to_account_info(),
                            payer: payer.to_account_info(),
                            inscription_data: inscription_data.to_account_info(),
                            inscription_v3: inscription_v3.to_account_info(),
                        },
                    ),
                    libreplex_inscriptions::instructions::ResizeInscriptionInput {
                        change: data_bytes.len() as i32 - 8,
                        expected_start_size: 8,
                        target_size: data_bytes.len() as u32,
                    },
                )?;
                libreplex_inscriptions::cpi::write_to_inscription_v3(
                    CpiContext::new(
                        inscriptions_program.to_account_info(),
                        WriteToInscriptionV3 {
                            authority: payer.to_account_info(),
                            payer: payer.to_account_info(),
                            inscription_v3: inscription_v3.to_account_info(),
                            system_program: system_program.to_account_info(),
                            inscription_data: inscription_data.to_account_info(),
                        },
                    ),
                    WriteToInscriptionInput {
                        data: data_bytes,
                        start_pos: 0,
                        media_type: Some("text/plain".to_owned()),
                        encoding_type: Some("ascii".to_owned()),
                    },
                )?;
                libreplex_inscriptions::cpi::make_inscription_immutable_v3(
                    CpiContext::new(
                        inscriptions_program.to_account_info(),
                        MakeInscriptionImmutableV3 {
                            payer: payer.to_account_info(),
                            authority: payer.to_account_info(),
                            inscription_summary: inscription_summary.to_account_info(),
                            inscription_v3: inscription_v3.to_account_info(),
                            system_program: system_program.to_account_info(),
                        },
                    ),
                )?;
            }
            let deployment_seeds: &[&[u8]] = &[
                "deployment".as_bytes(),
                deployment.ticker.as_ref(),
                &[bump_deployment],
            ];
            let expected_token_account = anchor_spl::associated_token::get_associated_token_address(
                &deployment.key(),
                &fungible_mint.key(),
            );
            if expected_token_account != fungible_token_account_escrow.key() {
                return Err(SharedError::InvalidTokenAccount.into());
            }
            if fungible_token_account_escrow.to_account_info().data_is_empty() {
                anchor_spl::associated_token::create(
                    CpiContext::new(
                        associated_token_program.to_account_info(),
                        anchor_spl::associated_token::Create {
                            payer: payer.to_account_info(),
                            associated_token: fungible_token_account_escrow
                                .to_account_info(),
                            authority: deployment.to_account_info(),
                            mint: fungible_mint.to_account_info(),
                            system_program: system_program.to_account_info(),
                            token_program: token_program.to_account_info(),
                        },
                    ),
                )?;
            }
            let expected_non_fungible_token_account = anchor_spl::associated_token::get_associated_token_address(
                &inscriber.key(),
                &non_fungible_mint.key(),
            );
            if expected_non_fungible_token_account != non_fungible_token_account.key() {
                return Err(SharedError::InvalidTokenAccount.into());
            }
            if non_fungible_token_account.to_account_info().data_is_empty() {
                anchor_spl::associated_token::create(
                    CpiContext::new(
                        associated_token_program.to_account_info(),
                        anchor_spl::associated_token::Create {
                            payer: payer.to_account_info(),
                            associated_token: non_fungible_token_account
                                .to_account_info(),
                            authority: inscriber.to_account_info(),
                            mint: non_fungible_mint.to_account_info(),
                            system_program: system_program.to_account_info(),
                            token_program: token_program.to_account_info(),
                        },
                    ),
                )?;
            }
            mint_to(
                CpiContext::new_with_signer(
                    token_program.to_account_info(),
                    MintTo {
                        mint: fungible_mint.to_account_info(),
                        to: fungible_token_account_escrow.to_account_info(),
                        authority: deployment.to_account_info(),
                    },
                    &[deployment_seeds],
                ),
                deployment.get_fungible_mint_amount(),
            )?;
            create_mint_with_metadata_and_masteredition(
                MintAccounts {
                    authority_pda: deployment.to_account_info(),
                    payer: payer.to_account_info(),
                    nft_owner: inscriber.to_account_info(),
                    nft_mint: non_fungible_mint.to_account_info(),
                    nft_mint_authority: deployment.to_account_info(),
                    nft_metadata: non_fungible_metadata.to_account_info(),
                    nft_master_edition: Some(
                        non_fungible_masteredition.to_account_info(),
                    ),
                    token: Some(non_fungible_token_account.to_account_info()),
                    token_metadata_program: metadata_program.to_account_info(),
                    spl_token_program: token_program.to_account_info(),
                    spl_ata_program: associated_token_program.to_account_info(),
                    system_program: system_program.to_account_info(),
                    sysvar_instructions: sysvar_instructions_program.to_account_info(),
                },
                deployment_seeds,
                deployment.ticker.clone(),
                "".to_owned(),
                0,
                deployment.offchain_url.clone(),
                Some(
                    [
                        Creator {
                            address: deployment.key(),
                            verified: true,
                            share: 100,
                        },
                    ]
                        .to_vec(),
                ),
                0,
                false,
                1,
                0,
                TokenStandard::NonFungible,
            )?;
            if deployment.number_of_tokens_issued == deployment.max_number_of_tokens {
                if fungible_mint.freeze_authority.is_some() {
                    set_authority(
                        CpiContext::new_with_signer(
                            token_program.to_account_info(),
                            SetAuthority {
                                current_authority: deployment.to_account_info(),
                                account_or_mint: fungible_mint.to_account_info(),
                            },
                            &[deployment_seeds],
                        ),
                        AuthorityType::FreezeAccount,
                        None,
                    )?;
                }
                if fungible_mint.mint_authority.is_some() {
                    set_authority(
                        CpiContext::new_with_signer(
                            token_program.to_account_info(),
                            SetAuthority {
                                current_authority: deployment.to_account_info(),
                                account_or_mint: fungible_mint.to_account_info(),
                            },
                            &[deployment_seeds],
                        ),
                        AuthorityType::MintTokens,
                        None,
                    )?;
                }
            }
            if deployment.number_of_tokens_issued <= 262144 {
                add_to_hashlist(
                    deployment.number_of_tokens_issued as u32,
                    hashlist,
                    payer,
                    system_program,
                    &non_fungible_mint.key(),
                    &deployment.key(),
                    inscription_summary.inscription_count_total,
                )?;
            }
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &MintEvent {
                                mint: non_fungible_mint.key(),
                                ticker: deployment.ticker.clone(),
                                tokens_minted: deployment.number_of_tokens_issued,
                                max_number_of_tokens: deployment.max_number_of_tokens,
                            },
                        ),
                    ],
                );
            };
            Ok(())
        }
    }
    pub use mint_legacy_logic::*;
    pub mod migrate_to_hashlist {
        use anchor_lang::prelude::*;
        use anchor_spl::{
            token::{
                mint_to, Mint, MintTo, Token, TokenAccount, set_authority, SetAuthority,
                spl_token::instruction::AuthorityType,
            },
            associated_token::AssociatedToken,
        };
        use libreplex_inscriptions::InscriptionV3;
        use libreplex_shared::SharedError;
        use crate::{
            Deployment, MigrationMarker, HashlistMarker, add_to_hashlist,
            MigrationCounter,
        };
        pub struct HashlistEvent {
            pub mint: Pubkey,
            pub deployment: Pubkey,
        }
        impl borsh::ser::BorshSerialize for HashlistEvent
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.mint, writer)?;
                borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for HashlistEvent
        where
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    deployment: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        impl anchor_lang::Event for HashlistEvent {
            fn data(&self) -> Vec<u8> {
                let mut d = [192, 81, 175, 215, 17, 88, 186, 52].to_vec();
                d.append(&mut self.try_to_vec().unwrap());
                d
            }
        }
        impl anchor_lang::Discriminator for HashlistEvent {
            const DISCRIMINATOR: [u8; 8] = [192, 81, 175, 215, 17, 88, 186, 52];
        }
        pub mod sysvar_instructions_program {
            use anchor_lang::declare_id;
            /// The static program ID
            pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                6u8,
                167u8,
                213u8,
                23u8,
                24u8,
                123u8,
                209u8,
                102u8,
                53u8,
                218u8,
                212u8,
                4u8,
                85u8,
                253u8,
                194u8,
                192u8,
                193u8,
                36u8,
                198u8,
                143u8,
                33u8,
                86u8,
                117u8,
                165u8,
                219u8,
                186u8,
                203u8,
                95u8,
                8u8,
                0u8,
                0u8,
                0u8,
            ]);
            /// Confirms that a given pubkey is equivalent to the program ID
            pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
                id == &ID
            }
            /// Returns the program ID
            pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                ID
            }
        }
        pub struct MigrateToHashlistCtx<'info> {
            #[account(
                mut,
                seeds = ["deployment".as_ref(),
                deployment.ticker.as_ref()],
                bump
            )]
            pub deployment: Account<'info, Deployment>,
            #[account(
                init,
                space = 8,
                payer = payer,
                seeds = ["migration_marker".as_ref(),
                mint.key().as_ref()],
                bump
            )]
            pub migration_marker: Account<'info, MigrationMarker>,
            #[account(
                init_if_needed,
                space = 8+32+8,
                payer = payer,
                seeds = ["migration_counter".as_ref(),
                deployment.key().as_ref()],
                bump
            )]
            pub migration_counter: Account<'info, MigrationCounter>,
            #[account(mut)]
            pub payer: Signer<'info>,
            #[account(
                mut,
                constraint = signer.key(

                ).to_string(

                )= = *"4aAifU9ck88koMhSK6fnUSQHMzpyuLzGa6q7nfvqA6vx".to_owned()
            )]
            pub signer: Signer<'info>,
            /// CHECK: checked via PDA
            #[account(
                mut,
                seeds = ["hashlist".as_bytes(),
                deployment.key().as_ref()],
                bump,
            )]
            pub hashlist: UncheckedAccount<'info>,
            #[account(
                init,
                space = 8,
                payer = payer,
                seeds = ["hashlist_marker".as_bytes(),
                deployment.key().as_ref(),
                mint.key().as_ref()],
                bump,
            )]
            pub hashlist_marker: Account<'info, HashlistMarker>,
            #[account(mut)]
            pub mint: Account<'info, Mint>,
            #[account(mut)]
            pub inscription_v3: Account<'info, InscriptionV3>,
            #[account(
                mut,
                constraint = deployment.fungible_mint = = fungible_mint.key()
            )]
            pub fungible_mint: Account<'info, Mint>,
            /// CHECK: Id checked in constraint
            #[account(
                mut,
                token::authority = deployment.key(),
                token::mint = fungible_mint.key()
            )]
            pub fungible_token_account_escrow: Account<'info, TokenAccount>,
            #[account()]
            pub system_program: Program<'info, System>,
            #[account()]
            pub token_program: Program<'info, Token>,
            #[account()]
            pub associated_token_program: Program<'info, AssociatedToken>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, MigrateToHashlistCtxBumps>
        for MigrateToHashlistCtx<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut MigrateToHashlistCtxBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let deployment: anchor_lang::accounts::account::Account<Deployment> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("deployment"))?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let migration_marker = &__accounts[0];
                *__accounts = &__accounts[1..];
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let migration_counter = &__accounts[0];
                *__accounts = &__accounts[1..];
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let signer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("signer"))?;
                let hashlist: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("hashlist"))?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let hashlist_marker = &__accounts[0];
                *__accounts = &__accounts[1..];
                let mint: anchor_lang::accounts::account::Account<Mint> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("mint"))?;
                let inscription_v3: anchor_lang::accounts::account::Account<
                    InscriptionV3,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("inscription_v3"))?;
                let fungible_mint: anchor_lang::accounts::account::Account<Mint> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                let fungible_token_account_escrow: anchor_lang::accounts::account::Account<
                    TokenAccount,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_token_account_escrow"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let associated_token_program: anchor_lang::accounts::program::Program<
                    AssociatedToken,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("associated_token_program"))?;
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["migration_marker".as_ref(), mint.key().as_ref()],
                    __program_id,
                );
                __bumps.migration_marker = __bump;
                if migration_marker.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("migration_marker")
                            .with_pubkeys((migration_marker.key(), __pda_address)),
                    );
                }
                let migration_marker = {
                    let actual_field = AsRef::<AccountInfo>::as_ref(&migration_marker);
                    let actual_owner = actual_field.owner;
                    let space = 8;
                    let pa: anchor_lang::accounts::account::Account<MigrationMarker> = if !false
                        || actual_owner
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let __current_lamports = migration_marker.lamports();
                        if __current_lamports == 0 {
                            let space = space;
                            let lamports = __anchor_rent.minimum_balance(space);
                            let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                from: payer.to_account_info(),
                                to: migration_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::create_account(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "migration_marker".as_ref(),
                                                mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                lamports,
                                space as u64,
                                __program_id,
                            )?;
                        } else {
                            if payer.key() == migration_marker.key() {
                                return Err(
                                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                            error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .name(),
                                            error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .into(),
                                            error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .to_string(),
                                            error_origin: Some(
                                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                    filename: "programs/libreplex_fair_launch/src/instructions/migrate_to_hashlist.rs",
                                                    line: 37u32,
                                                }),
                                            ),
                                            compared_values: None,
                                        })
                                        .with_pubkeys((payer.key(), migration_marker.key())),
                                );
                            }
                            let required_lamports = __anchor_rent
                                .minimum_balance(space)
                                .max(1)
                                .saturating_sub(__current_lamports);
                            if required_lamports > 0 {
                                let cpi_accounts = anchor_lang::system_program::Transfer {
                                    from: payer.to_account_info(),
                                    to: migration_marker.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::transfer(
                                    cpi_context,
                                    required_lamports,
                                )?;
                            }
                            let cpi_accounts = anchor_lang::system_program::Allocate {
                                account_to_allocate: migration_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::allocate(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "migration_marker".as_ref(),
                                                mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                space as u64,
                            )?;
                            let cpi_accounts = anchor_lang::system_program::Assign {
                                account_to_assign: migration_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::assign(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "migration_marker".as_ref(),
                                                mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                __program_id,
                            )?;
                        }
                        match anchor_lang::accounts::account::Account::try_from_unchecked(
                            &migration_marker,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("migration_marker")),
                        }
                    } else {
                        match anchor_lang::accounts::account::Account::try_from(
                            &migration_marker,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("migration_marker")),
                        }
                    };
                    if false {
                        if space != actual_field.data_len() {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSpace,
                                    )
                                    .with_account_name("migration_marker")
                                    .with_values((space, actual_field.data_len())),
                            );
                        }
                        if actual_owner != __program_id {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintOwner,
                                    )
                                    .with_account_name("migration_marker")
                                    .with_pubkeys((*actual_owner, *__program_id)),
                            );
                        }
                        {
                            let required_lamports = __anchor_rent.minimum_balance(space);
                            if pa.to_account_info().lamports() < required_lamports {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                        )
                                        .with_account_name("migration_marker"),
                                );
                            }
                        }
                    }
                    pa
                };
                if !AsRef::<AccountInfo>::as_ref(&migration_marker).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("migration_marker"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        migration_marker.to_account_info().lamports(),
                        migration_marker.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("migration_marker"),
                    );
                }
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["migration_counter".as_ref(), deployment.key().as_ref()],
                    __program_id,
                );
                __bumps.migration_counter = __bump;
                if migration_counter.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("migration_counter")
                            .with_pubkeys((migration_counter.key(), __pda_address)),
                    );
                }
                let migration_counter = {
                    let actual_field = AsRef::<AccountInfo>::as_ref(&migration_counter);
                    let actual_owner = actual_field.owner;
                    let space = 8 + 32 + 8;
                    let pa: anchor_lang::accounts::account::Account<MigrationCounter> = if !true
                        || actual_owner
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let __current_lamports = migration_counter.lamports();
                        if __current_lamports == 0 {
                            let space = space;
                            let lamports = __anchor_rent.minimum_balance(space);
                            let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                from: payer.to_account_info(),
                                to: migration_counter.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::create_account(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "migration_counter".as_ref(),
                                                deployment.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                lamports,
                                space as u64,
                                __program_id,
                            )?;
                        } else {
                            if payer.key() == migration_counter.key() {
                                return Err(
                                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                            error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .name(),
                                            error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .into(),
                                            error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .to_string(),
                                            error_origin: Some(
                                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                    filename: "programs/libreplex_fair_launch/src/instructions/migrate_to_hashlist.rs",
                                                    line: 37u32,
                                                }),
                                            ),
                                            compared_values: None,
                                        })
                                        .with_pubkeys((payer.key(), migration_counter.key())),
                                );
                            }
                            let required_lamports = __anchor_rent
                                .minimum_balance(space)
                                .max(1)
                                .saturating_sub(__current_lamports);
                            if required_lamports > 0 {
                                let cpi_accounts = anchor_lang::system_program::Transfer {
                                    from: payer.to_account_info(),
                                    to: migration_counter.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::transfer(
                                    cpi_context,
                                    required_lamports,
                                )?;
                            }
                            let cpi_accounts = anchor_lang::system_program::Allocate {
                                account_to_allocate: migration_counter.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::allocate(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "migration_counter".as_ref(),
                                                deployment.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                space as u64,
                            )?;
                            let cpi_accounts = anchor_lang::system_program::Assign {
                                account_to_assign: migration_counter.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::assign(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "migration_counter".as_ref(),
                                                deployment.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                __program_id,
                            )?;
                        }
                        match anchor_lang::accounts::account::Account::try_from_unchecked(
                            &migration_counter,
                        ) {
                            Ok(val) => val,
                            Err(e) => {
                                return Err(e.with_account_name("migration_counter"));
                            }
                        }
                    } else {
                        match anchor_lang::accounts::account::Account::try_from(
                            &migration_counter,
                        ) {
                            Ok(val) => val,
                            Err(e) => {
                                return Err(e.with_account_name("migration_counter"));
                            }
                        }
                    };
                    if true {
                        if space != actual_field.data_len() {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSpace,
                                    )
                                    .with_account_name("migration_counter")
                                    .with_values((space, actual_field.data_len())),
                            );
                        }
                        if actual_owner != __program_id {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintOwner,
                                    )
                                    .with_account_name("migration_counter")
                                    .with_pubkeys((*actual_owner, *__program_id)),
                            );
                        }
                        {
                            let required_lamports = __anchor_rent.minimum_balance(space);
                            if pa.to_account_info().lamports() < required_lamports {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                        )
                                        .with_account_name("migration_counter"),
                                );
                            }
                        }
                    }
                    pa
                };
                if !AsRef::<AccountInfo>::as_ref(&migration_counter).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("migration_counter"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        migration_counter.to_account_info().lamports(),
                        migration_counter.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("migration_counter"),
                    );
                }
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        "hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        mint.key().as_ref(),
                    ],
                    __program_id,
                );
                __bumps.hashlist_marker = __bump;
                if hashlist_marker.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("hashlist_marker")
                            .with_pubkeys((hashlist_marker.key(), __pda_address)),
                    );
                }
                let hashlist_marker = {
                    let actual_field = AsRef::<AccountInfo>::as_ref(&hashlist_marker);
                    let actual_owner = actual_field.owner;
                    let space = 8;
                    let pa: anchor_lang::accounts::account::Account<HashlistMarker> = if !false
                        || actual_owner
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let __current_lamports = hashlist_marker.lamports();
                        if __current_lamports == 0 {
                            let space = space;
                            let lamports = __anchor_rent.minimum_balance(space);
                            let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                from: payer.to_account_info(),
                                to: hashlist_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::create_account(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist_marker".as_bytes(),
                                                deployment.key().as_ref(),
                                                mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                lamports,
                                space as u64,
                                __program_id,
                            )?;
                        } else {
                            if payer.key() == hashlist_marker.key() {
                                return Err(
                                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                            error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .name(),
                                            error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .into(),
                                            error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                .to_string(),
                                            error_origin: Some(
                                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                    filename: "programs/libreplex_fair_launch/src/instructions/migrate_to_hashlist.rs",
                                                    line: 37u32,
                                                }),
                                            ),
                                            compared_values: None,
                                        })
                                        .with_pubkeys((payer.key(), hashlist_marker.key())),
                                );
                            }
                            let required_lamports = __anchor_rent
                                .minimum_balance(space)
                                .max(1)
                                .saturating_sub(__current_lamports);
                            if required_lamports > 0 {
                                let cpi_accounts = anchor_lang::system_program::Transfer {
                                    from: payer.to_account_info(),
                                    to: hashlist_marker.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::transfer(
                                    cpi_context,
                                    required_lamports,
                                )?;
                            }
                            let cpi_accounts = anchor_lang::system_program::Allocate {
                                account_to_allocate: hashlist_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::allocate(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist_marker".as_bytes(),
                                                deployment.key().as_ref(),
                                                mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                space as u64,
                            )?;
                            let cpi_accounts = anchor_lang::system_program::Assign {
                                account_to_assign: hashlist_marker.to_account_info(),
                            };
                            let cpi_context = anchor_lang::context::CpiContext::new(
                                system_program.to_account_info(),
                                cpi_accounts,
                            );
                            anchor_lang::system_program::assign(
                                cpi_context
                                    .with_signer(
                                        &[
                                            &[
                                                "hashlist_marker".as_bytes(),
                                                deployment.key().as_ref(),
                                                mint.key().as_ref(),
                                                &[__bump][..],
                                            ][..],
                                        ],
                                    ),
                                __program_id,
                            )?;
                        }
                        match anchor_lang::accounts::account::Account::try_from_unchecked(
                            &hashlist_marker,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("hashlist_marker")),
                        }
                    } else {
                        match anchor_lang::accounts::account::Account::try_from(
                            &hashlist_marker,
                        ) {
                            Ok(val) => val,
                            Err(e) => return Err(e.with_account_name("hashlist_marker")),
                        }
                    };
                    if false {
                        if space != actual_field.data_len() {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSpace,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_values((space, actual_field.data_len())),
                            );
                        }
                        if actual_owner != __program_id {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintOwner,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_pubkeys((*actual_owner, *__program_id)),
                            );
                        }
                        {
                            let required_lamports = __anchor_rent.minimum_balance(space);
                            if pa.to_account_info().lamports() < required_lamports {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                        )
                                        .with_account_name("hashlist_marker"),
                                );
                            }
                        }
                    }
                    pa
                };
                if !AsRef::<AccountInfo>::as_ref(&hashlist_marker).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("hashlist_marker"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        hashlist_marker.to_account_info().lamports(),
                        hashlist_marker.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("hashlist_marker"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["deployment".as_ref(), deployment.ticker.as_ref()],
                    &__program_id,
                );
                __bumps.deployment = __bump;
                if deployment.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("deployment")
                            .with_pubkeys((deployment.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("payer"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&signer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("signer"),
                    );
                }
                if !(signer.key().to_string()
                    == *"4aAifU9ck88koMhSK6fnUSQHMzpyuLzGa6q7nfvqA6vx".to_owned())
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("signer"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["hashlist".as_bytes(), deployment.key().as_ref()],
                    &__program_id,
                );
                __bumps.hashlist = __bump;
                if hashlist.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("hashlist")
                            .with_pubkeys((hashlist.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&hashlist).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("hashlist"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&inscription_v3).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("inscription_v3"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_mint"),
                    );
                }
                if !(deployment.fungible_mint == fungible_mint.key()) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("fungible_mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_token_account_escrow)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_token_account_escrow"),
                    );
                }
                {
                    if fungible_token_account_escrow.owner != deployment.key().key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if fungible_token_account_escrow.mint != fungible_mint.key().key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                Ok(MigrateToHashlistCtx {
                    deployment,
                    migration_marker,
                    migration_counter,
                    payer,
                    signer,
                    hashlist,
                    hashlist_marker,
                    mint,
                    inscription_v3,
                    fungible_mint,
                    fungible_token_account_escrow,
                    system_program,
                    token_program,
                    associated_token_program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for MigrateToHashlistCtx<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.deployment.to_account_infos());
                account_infos.extend(self.migration_marker.to_account_infos());
                account_infos.extend(self.migration_counter.to_account_infos());
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.signer.to_account_infos());
                account_infos.extend(self.hashlist.to_account_infos());
                account_infos.extend(self.hashlist_marker.to_account_infos());
                account_infos.extend(self.mint.to_account_infos());
                account_infos.extend(self.inscription_v3.to_account_infos());
                account_infos.extend(self.fungible_mint.to_account_infos());
                account_infos
                    .extend(self.fungible_token_account_escrow.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.associated_token_program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for MigrateToHashlistCtx<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.deployment.to_account_metas(None));
                account_metas.extend(self.migration_marker.to_account_metas(None));
                account_metas.extend(self.migration_counter.to_account_metas(None));
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.signer.to_account_metas(None));
                account_metas.extend(self.hashlist.to_account_metas(None));
                account_metas.extend(self.hashlist_marker.to_account_metas(None));
                account_metas.extend(self.mint.to_account_metas(None));
                account_metas.extend(self.inscription_v3.to_account_metas(None));
                account_metas.extend(self.fungible_mint.to_account_metas(None));
                account_metas
                    .extend(self.fungible_token_account_escrow.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas
                    .extend(self.associated_token_program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for MigrateToHashlistCtx<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                    .map_err(|e| e.with_account_name("deployment"))?;
                anchor_lang::AccountsExit::exit(&self.migration_marker, program_id)
                    .map_err(|e| e.with_account_name("migration_marker"))?;
                anchor_lang::AccountsExit::exit(&self.migration_counter, program_id)
                    .map_err(|e| e.with_account_name("migration_counter"))?;
                anchor_lang::AccountsExit::exit(&self.payer, program_id)
                    .map_err(|e| e.with_account_name("payer"))?;
                anchor_lang::AccountsExit::exit(&self.signer, program_id)
                    .map_err(|e| e.with_account_name("signer"))?;
                anchor_lang::AccountsExit::exit(&self.hashlist, program_id)
                    .map_err(|e| e.with_account_name("hashlist"))?;
                anchor_lang::AccountsExit::exit(&self.hashlist_marker, program_id)
                    .map_err(|e| e.with_account_name("hashlist_marker"))?;
                anchor_lang::AccountsExit::exit(&self.mint, program_id)
                    .map_err(|e| e.with_account_name("mint"))?;
                anchor_lang::AccountsExit::exit(&self.inscription_v3, program_id)
                    .map_err(|e| e.with_account_name("inscription_v3"))?;
                anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.fungible_token_account_escrow,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("fungible_token_account_escrow"))?;
                Ok(())
            }
        }
        pub struct MigrateToHashlistCtxBumps {
            pub deployment: u8,
            pub migration_marker: u8,
            pub migration_counter: u8,
            pub hashlist: u8,
            pub hashlist_marker: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MigrateToHashlistCtxBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "MigrateToHashlistCtxBumps",
                    "deployment",
                    &self.deployment,
                    "migration_marker",
                    &self.migration_marker,
                    "migration_counter",
                    &self.migration_counter,
                    "hashlist",
                    &self.hashlist,
                    "hashlist_marker",
                    &&self.hashlist_marker,
                )
            }
        }
        impl Default for MigrateToHashlistCtxBumps {
            fn default() -> Self {
                MigrateToHashlistCtxBumps {
                    deployment: u8::MAX,
                    migration_marker: u8::MAX,
                    migration_counter: u8::MAX,
                    hashlist: u8::MAX,
                    hashlist_marker: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for MigrateToHashlistCtx<'info>
        where
            'info: 'info,
        {
            type Bumps = MigrateToHashlistCtxBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_migrate_to_hashlist_ctx {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`MigrateToHashlistCtx`].
            pub struct MigrateToHashlistCtx {
                pub deployment: Pubkey,
                pub migration_marker: Pubkey,
                pub migration_counter: Pubkey,
                pub payer: Pubkey,
                pub signer: Pubkey,
                pub hashlist: Pubkey,
                pub hashlist_marker: Pubkey,
                pub mint: Pubkey,
                pub inscription_v3: Pubkey,
                pub fungible_mint: Pubkey,
                pub fungible_token_account_escrow: Pubkey,
                pub system_program: Pubkey,
                pub token_program: Pubkey,
                pub associated_token_program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for MigrateToHashlistCtx
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                    borsh::BorshSerialize::serialize(&self.migration_marker, writer)?;
                    borsh::BorshSerialize::serialize(&self.migration_counter, writer)?;
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.signer, writer)?;
                    borsh::BorshSerialize::serialize(&self.hashlist, writer)?;
                    borsh::BorshSerialize::serialize(&self.hashlist_marker, writer)?;
                    borsh::BorshSerialize::serialize(&self.mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.inscription_v3, writer)?;
                    borsh::BorshSerialize::serialize(&self.fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.fungible_token_account_escrow,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.associated_token_program,
                        writer,
                    )?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for MigrateToHashlistCtx {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.migration_marker,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.migration_counter,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.signer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.hashlist,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.hashlist_marker,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.inscription_v3,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_token_account_escrow,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.associated_token_program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_migrate_to_hashlist_ctx {
            use super::*;
            /// Generated CPI struct of the accounts for [`MigrateToHashlistCtx`].
            pub struct MigrateToHashlistCtx<'info> {
                pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub migration_marker: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub migration_counter: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub signer: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub hashlist: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub inscription_v3: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_token_account_escrow: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for MigrateToHashlistCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.migration_marker),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.migration_counter),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.signer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.hashlist),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.hashlist_marker),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.inscription_v3),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_token_account_escrow),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.associated_token_program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info>
            for MigrateToHashlistCtx<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.migration_marker,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.migration_counter,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.signer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.hashlist),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.hashlist_marker,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.mint),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.inscription_v3,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_token_account_escrow,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.associated_token_program,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub fn migrate_to_hashlist(ctx: Context<MigrateToHashlistCtx>) -> Result<()> {
            let deployment = &mut ctx.accounts.deployment;
            let hashlist = &mut ctx.accounts.hashlist;
            let mint: &mut Account<'_, Mint> = &mut ctx.accounts.mint;
            let inscription_v3 = &ctx.accounts.inscription_v3;
            let token_program = &ctx.accounts.token_program;
            let fungible_mint = &ctx.accounts.fungible_mint;
            let fungible_token_account_escrow = &ctx
                .accounts
                .fungible_token_account_escrow;
            let system_program = &ctx.accounts.system_program;
            let payer = &ctx.accounts.payer;
            let migration_counter = &mut ctx.accounts.migration_counter;
            migration_counter.migration_count += 1;
            migration_counter.deployment = deployment.key();
            let deployment_seeds: &[&[u8]] = &[
                "deployment".as_bytes(),
                deployment.ticker.as_ref(),
                &[ctx.bumps.deployment],
            ];
            if !deployment.migrated_from_legacy {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("Cannot migrate to this deployment"),
                    );
                }
            }
            let expected_token_account = anchor_spl::associated_token::get_associated_token_address(
                &deployment.key(),
                &fungible_mint.key(),
            );
            if expected_token_account != fungible_token_account_escrow.key() {
                return Err(SharedError::InvalidTokenAccount.into());
            }
            let current_mint_amount = fungible_mint.supply;
            let final_mint_amount = deployment.get_max_fungible_mint_amount();
            if current_mint_amount < final_mint_amount {
                ::solana_program::log::sol_log(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("current_mint_amount {0}", current_mint_amount),
                        );
                        res
                    },
                );
                ::solana_program::log::sol_log(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("final_mint_amount {0}", final_mint_amount),
                        );
                        res
                    },
                );
                if fungible_mint.mint_authority.is_some() {
                    mint_to(
                        CpiContext::new_with_signer(
                            token_program.to_account_info(),
                            MintTo {
                                mint: fungible_mint.to_account_info(),
                                to: fungible_token_account_escrow.to_account_info(),
                                authority: deployment.to_account_info(),
                            },
                            &[deployment_seeds],
                        ),
                        final_mint_amount - current_mint_amount,
                    )?;
                }
                if fungible_mint.freeze_authority.is_some() {
                    set_authority(
                        CpiContext::new_with_signer(
                            token_program.to_account_info(),
                            SetAuthority {
                                current_authority: deployment.to_account_info(),
                                account_or_mint: fungible_mint.to_account_info(),
                            },
                            &[deployment_seeds],
                        ),
                        AuthorityType::FreezeAccount,
                        None,
                    )?;
                }
                if fungible_mint.mint_authority.is_some() {
                    set_authority(
                        CpiContext::new_with_signer(
                            token_program.to_account_info(),
                            SetAuthority {
                                current_authority: deployment.to_account_info(),
                                account_or_mint: fungible_mint.to_account_info(),
                            },
                            &[deployment_seeds],
                        ),
                        AuthorityType::MintTokens,
                        None,
                    )?;
                }
            }
            add_to_hashlist(
                migration_counter.migration_count as u32,
                hashlist,
                payer,
                system_program,
                &mint.key(),
                &deployment.key(),
                inscription_v3.order,
            )?;
            Ok(())
        }
    }
    pub use migrate_to_hashlist::*;
    pub mod add_to_hashlist {
        use anchor_lang::prelude::*;
        use anchor_lang::{
            accounts::{
                unchecked_account::UncheckedAccount, signer::Signer, program::Program,
            },
            system_program::System,
        };
        use solana_program::program::invoke;
        use solana_program::pubkey::Pubkey;
        use solana_program::system_instruction;
        use crate::HashlistEvent;
        pub fn add_to_hashlist<'a>(
            new_number_of_mints: u32,
            hashlist: &mut UncheckedAccount<'a>,
            payer: &Signer<'a>,
            system_program: &Program<'a, System>,
            mint: &Pubkey,
            deployment: &Pubkey,
            order_number: u64,
        ) -> Result<()> {
            ::solana_program::log::sol_log("add_to_hashlist called");
            let new_size = 8 + 32 + 4 + (new_number_of_mints) * (32 + 8);
            let rent = Rent::get()?;
            let new_minimum_balance = rent.minimum_balance(new_size as usize);
            let lamports_diff = new_minimum_balance.saturating_sub(hashlist.lamports());
            if lamports_diff > 0 {
                invoke(
                    &system_instruction::transfer(
                        &payer.key(),
                        hashlist.key,
                        lamports_diff,
                    ),
                    &[
                        payer.to_account_info(),
                        hashlist.to_account_info(),
                        system_program.to_account_info(),
                    ],
                )?;
            }
            hashlist.realloc(new_size as usize, false)?;
            let hashlist_account_info = hashlist.to_account_info();
            let mut hashlist_data = hashlist_account_info.data.borrow_mut();
            hashlist_data[40..44].copy_from_slice(&new_number_of_mints.to_le_bytes());
            let mint_start_pos: usize = (44 + (new_number_of_mints - 1) * 40) as usize;
            hashlist_data[mint_start_pos..(mint_start_pos + 32)]
                .copy_from_slice(mint.key().as_ref());
            hashlist_data[mint_start_pos + 32..mint_start_pos + 40]
                .copy_from_slice(&order_number.to_le_bytes());
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &HashlistEvent {
                                mint: mint.key(),
                                deployment: deployment.key(),
                            },
                        ),
                    ],
                );
            };
            Ok(())
        }
    }
    pub use add_to_hashlist::*;
    pub use swap_to_fungible::*;
    pub mod swap_to_fungible {
        use anchor_lang::prelude::*;
        use anchor_spl::{
            associated_token::AssociatedToken, token::{Mint, TokenAccount, self},
            token_2022,
        };
        use libreplex_shared::operations::transfer_non_pnft;
        use crate::{Deployment, HashlistMarker, move_fungible_out_of_escrow};
        pub mod sysvar_instructions_program {
            use anchor_lang::declare_id;
            /// The static program ID
            pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                6u8,
                167u8,
                213u8,
                23u8,
                24u8,
                123u8,
                209u8,
                102u8,
                53u8,
                218u8,
                212u8,
                4u8,
                85u8,
                253u8,
                194u8,
                192u8,
                193u8,
                36u8,
                198u8,
                143u8,
                33u8,
                86u8,
                117u8,
                165u8,
                219u8,
                186u8,
                203u8,
                95u8,
                8u8,
                0u8,
                0u8,
                0u8,
            ]);
            /// Confirms that a given pubkey is equivalent to the program ID
            pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
                id == &ID
            }
            /// Returns the program ID
            pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                ID
            }
        }
        pub struct SwapLegacyToFungibleCtx<'info> {
            #[account(
                mut,
                constraint = deployment.fungible_mint = = fungible_mint.key(),
                seeds = ["deployment".as_ref(),
                deployment.ticker.as_ref()],
                bump
            )]
            pub deployment: Box<Account<'info, Deployment>>,
            #[account(mut)]
            pub payer: Signer<'info>,
            #[account(mut)]
            pub fungible_mint: Box<Account<'info, Mint>>,
            #[account(
                seeds = ["hashlist_marker".as_bytes(),
                deployment.key().as_ref(),
                non_fungible_mint.key().as_ref()],
                bump,
            )]
            pub hashlist_marker: Account<'info, HashlistMarker>,
            /// this always exists so we can specify the account type explicitly
            #[account(mut, token::mint = fungible_mint, token::authority = deployment)]
            pub fungible_source_token_account: Box<Account<'info, TokenAccount>>,
            /// CHECK: derivation checked in Logic. May not exist so created as required.
            #[account(mut)]
            pub fungible_target_token_account: UncheckedAccount<'info>,
            #[account(mut)]
            pub non_fungible_mint: Box<Account<'info, Mint>>,
            /// this always exists (otherwise we couldn't swap), so we can specify the account
            /// type explicitly
            #[account(mut, token::mint = non_fungible_mint, token::authority = payer)]
            pub non_fungible_source_token_account: Box<Account<'info, TokenAccount>>,
            /// CHECK: derivation checked in Logic. Will be created as needed
            #[account(mut)]
            pub non_fungible_target_token_account: UncheckedAccount<'info>,
            /// CHECK: Checked in constraint
            #[account(
                constraint = token_program.key(

                )= = token_2022::ID||token_program.key()= = token::ID
            )]
            pub token_program: UncheckedAccount<'info>,
            #[account()]
            pub associated_token_program: Program<'info, AssociatedToken>,
            #[account()]
            pub system_program: Program<'info, System>,
            /// CHECK: Checked in constraint
            #[account(
                constraint = sysvar_instructions.key()= = sysvar_instructions_program::ID
            )]
            sysvar_instructions: UncheckedAccount<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, SwapLegacyToFungibleCtxBumps>
        for SwapLegacyToFungibleCtx<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut SwapLegacyToFungibleCtxBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let deployment: Box<
                    anchor_lang::accounts::account::Account<Deployment>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("deployment"))?;
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let fungible_mint: Box<anchor_lang::accounts::account::Account<Mint>> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                let hashlist_marker: anchor_lang::accounts::account::Account<
                    HashlistMarker,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("hashlist_marker"))?;
                let fungible_source_token_account: Box<
                    anchor_lang::accounts::account::Account<TokenAccount>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_source_token_account"))?;
                let fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_target_token_account"))?;
                let non_fungible_mint: Box<
                    anchor_lang::accounts::account::Account<Mint>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                let non_fungible_source_token_account: Box<
                    anchor_lang::accounts::account::Account<TokenAccount>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_source_token_account")
                    })?;
                let non_fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_target_token_account")
                    })?;
                let token_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let associated_token_program: anchor_lang::accounts::program::Program<
                    AssociatedToken,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("associated_token_program"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["deployment".as_ref(), deployment.ticker.as_ref()],
                    &__program_id,
                );
                __bumps.deployment = __bump;
                if deployment.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("deployment")
                            .with_pubkeys((deployment.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(deployment.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !(deployment.fungible_mint == fungible_mint.key()) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("payer"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(fungible_mint.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_mint"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        "hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.hashlist_marker = __bump;
                if hashlist_marker.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("hashlist_marker")
                            .with_pubkeys((hashlist_marker.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(fungible_source_token_account.as_ref())
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_source_token_account"),
                    );
                }
                {
                    if fungible_source_token_account.owner != deployment.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if fungible_source_token_account.mint != fungible_mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_target_token_account)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_target_token_account"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(non_fungible_mint.as_ref()).is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_mint"),
                    );
                }
                if !AsRef::<
                    AccountInfo,
                >::as_ref(non_fungible_source_token_account.as_ref())
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_source_token_account"),
                    );
                }
                {
                    if non_fungible_source_token_account.owner != payer.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if non_fungible_source_token_account.mint != non_fungible_mint.key()
                    {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_target_token_account)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_target_token_account"),
                    );
                }
                if !(token_program.key() == token_2022::ID
                    || token_program.key() == token::ID)
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("token_program"),
                    );
                }
                if !(sysvar_instructions.key() == sysvar_instructions_program::ID) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("sysvar_instructions"),
                    );
                }
                Ok(SwapLegacyToFungibleCtx {
                    deployment,
                    payer,
                    fungible_mint,
                    hashlist_marker,
                    fungible_source_token_account,
                    fungible_target_token_account,
                    non_fungible_mint,
                    non_fungible_source_token_account,
                    non_fungible_target_token_account,
                    token_program,
                    associated_token_program,
                    system_program,
                    sysvar_instructions,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for SwapLegacyToFungibleCtx<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.deployment.to_account_infos());
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.fungible_mint.to_account_infos());
                account_infos.extend(self.hashlist_marker.to_account_infos());
                account_infos
                    .extend(self.fungible_source_token_account.to_account_infos());
                account_infos
                    .extend(self.fungible_target_token_account.to_account_infos());
                account_infos.extend(self.non_fungible_mint.to_account_infos());
                account_infos
                    .extend(self.non_fungible_source_token_account.to_account_infos());
                account_infos
                    .extend(self.non_fungible_target_token_account.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.associated_token_program.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.sysvar_instructions.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for SwapLegacyToFungibleCtx<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.deployment.to_account_metas(None));
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.fungible_mint.to_account_metas(None));
                account_metas.extend(self.hashlist_marker.to_account_metas(None));
                account_metas
                    .extend(self.fungible_source_token_account.to_account_metas(None));
                account_metas
                    .extend(self.fungible_target_token_account.to_account_metas(None));
                account_metas.extend(self.non_fungible_mint.to_account_metas(None));
                account_metas
                    .extend(
                        self.non_fungible_source_token_account.to_account_metas(None),
                    );
                account_metas
                    .extend(
                        self.non_fungible_target_token_account.to_account_metas(None),
                    );
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas
                    .extend(self.associated_token_program.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.sysvar_instructions.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for SwapLegacyToFungibleCtx<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                    .map_err(|e| e.with_account_name("deployment"))?;
                anchor_lang::AccountsExit::exit(&self.payer, program_id)
                    .map_err(|e| e.with_account_name("payer"))?;
                anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.fungible_source_token_account,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("fungible_source_token_account"))?;
                anchor_lang::AccountsExit::exit(
                        &self.fungible_target_token_account,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("fungible_target_token_account"))?;
                anchor_lang::AccountsExit::exit(&self.non_fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_source_token_account,
                        program_id,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_source_token_account")
                    })?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_target_token_account,
                        program_id,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_target_token_account")
                    })?;
                Ok(())
            }
        }
        pub struct SwapLegacyToFungibleCtxBumps {
            pub deployment: u8,
            pub hashlist_marker: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SwapLegacyToFungibleCtxBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SwapLegacyToFungibleCtxBumps",
                    "deployment",
                    &self.deployment,
                    "hashlist_marker",
                    &&self.hashlist_marker,
                )
            }
        }
        impl Default for SwapLegacyToFungibleCtxBumps {
            fn default() -> Self {
                SwapLegacyToFungibleCtxBumps {
                    deployment: u8::MAX,
                    hashlist_marker: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for SwapLegacyToFungibleCtx<'info>
        where
            'info: 'info,
        {
            type Bumps = SwapLegacyToFungibleCtxBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_swap_legacy_to_fungible_ctx {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`SwapLegacyToFungibleCtx`].
            pub struct SwapLegacyToFungibleCtx {
                pub deployment: Pubkey,
                pub payer: Pubkey,
                pub fungible_mint: Pubkey,
                pub hashlist_marker: Pubkey,
                ///this always exists so we can specify the account type explicitly
                pub fungible_source_token_account: Pubkey,
                pub fungible_target_token_account: Pubkey,
                pub non_fungible_mint: Pubkey,
                ///this always exists (otherwise we couldn't swap), so we can specify the account
                ///type explicitly
                pub non_fungible_source_token_account: Pubkey,
                pub non_fungible_target_token_account: Pubkey,
                pub token_program: Pubkey,
                pub associated_token_program: Pubkey,
                pub system_program: Pubkey,
                pub sysvar_instructions: Pubkey,
            }
            impl borsh::ser::BorshSerialize for SwapLegacyToFungibleCtx
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.hashlist_marker, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.fungible_source_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.fungible_target_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.non_fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_source_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_target_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.associated_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.sysvar_instructions, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for SwapLegacyToFungibleCtx {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.hashlist_marker,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_source_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_target_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_source_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_target_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.associated_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.sysvar_instructions,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_swap_legacy_to_fungible_ctx {
            use super::*;
            /// Generated CPI struct of the accounts for [`SwapLegacyToFungibleCtx`].
            pub struct SwapLegacyToFungibleCtx<'info> {
                pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///this always exists so we can specify the account type explicitly
                pub fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///this always exists (otherwise we couldn't swap), so we can specify the account
                ///type explicitly
                pub non_fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for SwapLegacyToFungibleCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.hashlist_marker),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_source_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_target_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(
                                    &self.non_fungible_source_token_account,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(
                                    &self.non_fungible_target_token_account,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.associated_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.sysvar_instructions),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info>
            for SwapLegacyToFungibleCtx<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.hashlist_marker,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_source_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_target_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_source_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_target_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.associated_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.sysvar_instructions,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub fn swap_metaplex_to_fungible(
            ctx: Context<SwapLegacyToFungibleCtx>,
        ) -> Result<()> {
            let token_program = &ctx.accounts.token_program;
            let payer = &ctx.accounts.payer;
            let non_fungible_source_token_account = &ctx
                .accounts
                .non_fungible_source_token_account;
            let non_fungible_target_token_account = &ctx
                .accounts
                .non_fungible_target_token_account;
            let non_fungible_mint = &ctx.accounts.non_fungible_mint;
            let fungible_source_token_account = &ctx
                .accounts
                .fungible_source_token_account;
            let fungible_target_token_account = &ctx
                .accounts
                .fungible_target_token_account;
            let fungible_mint = &ctx.accounts.fungible_mint;
            let deployment = &mut ctx.accounts.deployment;
            let associated_token_program = &ctx.accounts.associated_token_program;
            let system_program = &ctx.accounts.system_program;
            if deployment.require_creator_cosign {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Only launches without creator cosign can currently use v1 methods",
                        ),
                    );
                }
            }
            transfer_non_pnft(
                &token_program.to_account_info(),
                &non_fungible_source_token_account.to_account_info(),
                &non_fungible_target_token_account.to_account_info(),
                &payer.to_account_info(),
                &non_fungible_mint.to_account_info(),
                &deployment.to_account_info(),
                &associated_token_program.to_account_info(),
                &system_program.to_account_info(),
                None,
                &payer.to_account_info(),
                1,
            )?;
            let ticker = deployment.ticker.clone();
            let authority_seeds = &[
                "deployment".as_bytes(),
                ticker.as_ref(),
                &[ctx.bumps.deployment],
            ];
            move_fungible_out_of_escrow(
                token_program,
                fungible_source_token_account,
                fungible_target_token_account,
                deployment,
                fungible_mint,
                payer,
                associated_token_program,
                system_program,
                authority_seeds,
            )?;
            Ok(())
        }
    }
    pub use swap_to_non_fungible::*;
    pub mod swap_to_non_fungible {
        use crate::{move_fungible_into_escrow, HashlistMarker};
        use anchor_lang::prelude::*;
        use anchor_spl::{
            associated_token::AssociatedToken, token::{Mint, TokenAccount, self},
            token_2022,
        };
        use libreplex_shared::operations::transfer_non_pnft;
        use crate::Deployment;
        pub mod sysvar_instructions_program {
            use anchor_lang::declare_id;
            /// The static program ID
            pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                6u8,
                167u8,
                213u8,
                23u8,
                24u8,
                123u8,
                209u8,
                102u8,
                53u8,
                218u8,
                212u8,
                4u8,
                85u8,
                253u8,
                194u8,
                192u8,
                193u8,
                36u8,
                198u8,
                143u8,
                33u8,
                86u8,
                117u8,
                165u8,
                219u8,
                186u8,
                203u8,
                95u8,
                8u8,
                0u8,
                0u8,
                0u8,
            ]);
            /// Confirms that a given pubkey is equivalent to the program ID
            pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
                id == &ID
            }
            /// Returns the program ID
            pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                ID
            }
        }
        pub struct SwapFungibleToLegacyCtx<'info> {
            #[account(
                mut,
                constraint = deployment.fungible_mint = = fungible_mint.key(),
                seeds = ["deployment".as_ref(),
                deployment.ticker.as_ref()],
                bump
            )]
            pub deployment: Account<'info, Deployment>,
            #[account(mut)]
            pub payer: Signer<'info>,
            #[account(mut)]
            pub fungible_mint: Account<'info, Mint>,
            #[account(mut, token::mint = fungible_mint, token::authority = payer)]
            pub fungible_source_token_account: Account<'info, TokenAccount>,
            /// CHECK: Checked in transfer logic
            #[account(mut)]
            pub fungible_target_token_account: UncheckedAccount<'info>,
            #[account(mut)]
            pub non_fungible_mint: Account<'info, Mint>,
            #[account(
                mut,
                token::mint = non_fungible_mint,
                token::authority = deployment,
            )]
            pub non_fungible_source_token_account: Account<'info, TokenAccount>,
            #[account(
                seeds = ["hashlist_marker".as_bytes(),
                deployment.key().as_ref(),
                non_fungible_mint.key().as_ref()],
                bump,
            )]
            pub hashlist_marker: Account<'info, HashlistMarker>,
            /// CHECK: Checked in transfer logic
            #[account(mut)]
            pub non_fungible_target_token_account: UncheckedAccount<'info>,
            /// CHECK: Checked in constraint
            #[account(
                constraint = token_program.key(

                )= = token_2022::ID||token_program.key()= = token::ID
            )]
            pub token_program: UncheckedAccount<'info>,
            #[account()]
            pub associated_token_program: Program<'info, AssociatedToken>,
            #[account()]
            pub system_program: Program<'info, System>,
            /// CHECK: Checked in constraint
            #[account(
                constraint = sysvar_instructions.key()= = sysvar_instructions_program::ID
            )]
            sysvar_instructions: UncheckedAccount<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, SwapFungibleToLegacyCtxBumps>
        for SwapFungibleToLegacyCtx<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut SwapFungibleToLegacyCtxBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let deployment: anchor_lang::accounts::account::Account<Deployment> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("deployment"))?;
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let fungible_mint: anchor_lang::accounts::account::Account<Mint> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                let fungible_source_token_account: anchor_lang::accounts::account::Account<
                    TokenAccount,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_source_token_account"))?;
                let fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("fungible_target_token_account"))?;
                let non_fungible_mint: anchor_lang::accounts::account::Account<Mint> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                let non_fungible_source_token_account: anchor_lang::accounts::account::Account<
                    TokenAccount,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_source_token_account")
                    })?;
                let hashlist_marker: anchor_lang::accounts::account::Account<
                    HashlistMarker,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("hashlist_marker"))?;
                let non_fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_target_token_account")
                    })?;
                let token_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let associated_token_program: anchor_lang::accounts::program::Program<
                    AssociatedToken,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("associated_token_program"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &["deployment".as_ref(), deployment.ticker.as_ref()],
                    &__program_id,
                );
                __bumps.deployment = __bump;
                if deployment.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("deployment")
                            .with_pubkeys((deployment.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !(deployment.fungible_mint == fungible_mint.key()) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("deployment"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("payer"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_source_token_account)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_source_token_account"),
                    );
                }
                {
                    if fungible_source_token_account.owner != payer.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if fungible_source_token_account.mint != fungible_mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(&fungible_target_token_account)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("fungible_target_token_account"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_mint"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_source_token_account)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_source_token_account"),
                    );
                }
                {
                    if non_fungible_source_token_account.owner != deployment.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if non_fungible_source_token_account.mint != non_fungible_mint.key()
                    {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        "hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.hashlist_marker = __bump;
                if hashlist_marker.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("hashlist_marker")
                            .with_pubkeys((hashlist_marker.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&non_fungible_target_token_account)
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("non_fungible_target_token_account"),
                    );
                }
                if !(token_program.key() == token_2022::ID
                    || token_program.key() == token::ID)
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("token_program"),
                    );
                }
                if !(sysvar_instructions.key() == sysvar_instructions_program::ID) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("sysvar_instructions"),
                    );
                }
                Ok(SwapFungibleToLegacyCtx {
                    deployment,
                    payer,
                    fungible_mint,
                    fungible_source_token_account,
                    fungible_target_token_account,
                    non_fungible_mint,
                    non_fungible_source_token_account,
                    hashlist_marker,
                    non_fungible_target_token_account,
                    token_program,
                    associated_token_program,
                    system_program,
                    sysvar_instructions,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for SwapFungibleToLegacyCtx<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.deployment.to_account_infos());
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.fungible_mint.to_account_infos());
                account_infos
                    .extend(self.fungible_source_token_account.to_account_infos());
                account_infos
                    .extend(self.fungible_target_token_account.to_account_infos());
                account_infos.extend(self.non_fungible_mint.to_account_infos());
                account_infos
                    .extend(self.non_fungible_source_token_account.to_account_infos());
                account_infos.extend(self.hashlist_marker.to_account_infos());
                account_infos
                    .extend(self.non_fungible_target_token_account.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.associated_token_program.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.sysvar_instructions.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for SwapFungibleToLegacyCtx<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.deployment.to_account_metas(None));
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.fungible_mint.to_account_metas(None));
                account_metas
                    .extend(self.fungible_source_token_account.to_account_metas(None));
                account_metas
                    .extend(self.fungible_target_token_account.to_account_metas(None));
                account_metas.extend(self.non_fungible_mint.to_account_metas(None));
                account_metas
                    .extend(
                        self.non_fungible_source_token_account.to_account_metas(None),
                    );
                account_metas.extend(self.hashlist_marker.to_account_metas(None));
                account_metas
                    .extend(
                        self.non_fungible_target_token_account.to_account_metas(None),
                    );
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas
                    .extend(self.associated_token_program.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.sysvar_instructions.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for SwapFungibleToLegacyCtx<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                    .map_err(|e| e.with_account_name("deployment"))?;
                anchor_lang::AccountsExit::exit(&self.payer, program_id)
                    .map_err(|e| e.with_account_name("payer"))?;
                anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.fungible_source_token_account,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("fungible_source_token_account"))?;
                anchor_lang::AccountsExit::exit(
                        &self.fungible_target_token_account,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("fungible_target_token_account"))?;
                anchor_lang::AccountsExit::exit(&self.non_fungible_mint, program_id)
                    .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_source_token_account,
                        program_id,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_source_token_account")
                    })?;
                anchor_lang::AccountsExit::exit(
                        &self.non_fungible_target_token_account,
                        program_id,
                    )
                    .map_err(|e| {
                        e.with_account_name("non_fungible_target_token_account")
                    })?;
                Ok(())
            }
        }
        pub struct SwapFungibleToLegacyCtxBumps {
            pub deployment: u8,
            pub hashlist_marker: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SwapFungibleToLegacyCtxBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SwapFungibleToLegacyCtxBumps",
                    "deployment",
                    &self.deployment,
                    "hashlist_marker",
                    &&self.hashlist_marker,
                )
            }
        }
        impl Default for SwapFungibleToLegacyCtxBumps {
            fn default() -> Self {
                SwapFungibleToLegacyCtxBumps {
                    deployment: u8::MAX,
                    hashlist_marker: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for SwapFungibleToLegacyCtx<'info>
        where
            'info: 'info,
        {
            type Bumps = SwapFungibleToLegacyCtxBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_swap_fungible_to_legacy_ctx {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`SwapFungibleToLegacyCtx`].
            pub struct SwapFungibleToLegacyCtx {
                pub deployment: Pubkey,
                pub payer: Pubkey,
                pub fungible_mint: Pubkey,
                pub fungible_source_token_account: Pubkey,
                pub fungible_target_token_account: Pubkey,
                pub non_fungible_mint: Pubkey,
                pub non_fungible_source_token_account: Pubkey,
                pub hashlist_marker: Pubkey,
                pub non_fungible_target_token_account: Pubkey,
                pub token_program: Pubkey,
                pub associated_token_program: Pubkey,
                pub system_program: Pubkey,
                pub sysvar_instructions: Pubkey,
            }
            impl borsh::ser::BorshSerialize for SwapFungibleToLegacyCtx
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.fungible_source_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.fungible_target_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.non_fungible_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_source_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.hashlist_marker, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.non_fungible_target_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.associated_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.sysvar_instructions, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for SwapFungibleToLegacyCtx {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.deployment,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_source_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.fungible_target_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_source_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.hashlist_marker,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.non_fungible_target_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.associated_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.sysvar_instructions,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_swap_fungible_to_legacy_ctx {
            use super::*;
            /// Generated CPI struct of the accounts for [`SwapFungibleToLegacyCtx`].
            pub struct SwapFungibleToLegacyCtx<'info> {
                pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub non_fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for SwapFungibleToLegacyCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.deployment),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_source_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.fungible_target_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.non_fungible_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(
                                    &self.non_fungible_source_token_account,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.hashlist_marker),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(
                                    &self.non_fungible_target_token_account,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.associated_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.sysvar_instructions),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info>
            for SwapFungibleToLegacyCtx<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.deployment,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_source_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.fungible_target_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_source_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.hashlist_marker,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.non_fungible_target_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.associated_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.sysvar_instructions,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub fn swap_to_nonfungible(ctx: Context<SwapFungibleToLegacyCtx>) -> Result<()> {
            let token_program = &ctx.accounts.token_program;
            let payer = &ctx.accounts.payer;
            let non_fungible_source_token_account = &ctx
                .accounts
                .non_fungible_source_token_account;
            let non_fungible_target_token_account = &ctx
                .accounts
                .non_fungible_target_token_account;
            let non_fungible_mint = &ctx.accounts.non_fungible_mint;
            let source_wallet = &ctx.accounts.payer;
            let fungible_source_token_account = &ctx
                .accounts
                .fungible_source_token_account;
            let fungible_target_token_account = &ctx
                .accounts
                .fungible_target_token_account;
            let fungible_mint = &ctx.accounts.fungible_mint;
            let deployment = &mut ctx.accounts.deployment;
            let associated_token_program = &ctx.accounts.associated_token_program;
            let system_program = &ctx.accounts.system_program;
            if deployment.require_creator_cosign {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Only launches without creator cosign can currently use v1 methods",
                        ),
                    );
                }
            }
            move_fungible_into_escrow(
                token_program,
                fungible_source_token_account,
                fungible_target_token_account,
                source_wallet,
                fungible_mint,
                deployment,
                associated_token_program,
                system_program,
                payer,
            )?;
            let authority_seeds = &[
                "deployment".as_bytes(),
                deployment.ticker.as_ref(),
                &[ctx.bumps.deployment],
            ];
            transfer_non_pnft(
                &token_program.to_account_info(),
                &non_fungible_source_token_account.to_account_info(),
                &non_fungible_target_token_account.to_account_info(),
                &deployment.to_account_info(),
                &non_fungible_mint.to_account_info(),
                &source_wallet.to_account_info(),
                &associated_token_program.to_account_info(),
                &system_program.to_account_info(),
                Some(&[authority_seeds]),
                &payer.to_account_info(),
                1,
            )?;
            Ok(())
        }
    }
    pub mod v2 {
        pub mod token_2022 {
            pub mod mint_2022 {
                use anchor_lang::prelude::*;
                use anchor_spl::{
                    associated_token::AssociatedToken, token_2022, token_interface::Mint,
                };
                use libreplex_shared::SharedError;
                use crate::{
                    errors::FairLaunchError, Deployment, HashlistMarker,
                    TOKEN2022_DEPLOYMENT_TYPE, HYBRID_DEPLOYMENT_TYPE,
                    mint_token2022_logic, DeploymentConfig,
                };
                pub struct MintToken2022Ctx<'info> {
                    #[account(
                        mut,
                        seeds = ["deployment".as_ref(),
                        deployment.ticker.as_ref()],
                        bump
                    )]
                    pub deployment: Account<'info, Deployment>,
                    #[account(
                        mut,
                        seeds = ["deployment_config".as_ref(),
                        deployment.key().as_ref()],
                        bump
                    )]
                    pub deployment_config: Account<'info, DeploymentConfig>,
                    /// CHECK: checked in constraint
                    #[account(
                        mut,
                        constraint = deployment_config.creator_fee_treasury = = creator_fee_treasury.key(

                        )
                    )]
                    pub creator_fee_treasury: UncheckedAccount<'info>,
                    /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
                    #[account(
                        mut,
                        seeds = ["hashlist".as_bytes(),
                        deployment.key().as_ref()],
                        bump,
                    )]
                    pub hashlist: UncheckedAccount<'info>,
                    #[account(
                        init,
                        space = 8+HashlistMarker::INIT_SPACE,
                        payer = payer,
                        seeds = ["hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref()],
                        bump,
                    )]
                    pub hashlist_marker: Account<'info, HashlistMarker>,
                    #[account(mut)]
                    pub payer: Signer<'info>,
                    #[account(mut)]
                    pub signer: Signer<'info>,
                    #[account(mut)]
                    pub fungible_mint: InterfaceAccount<'info, Mint>,
                    /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
                    #[account(mut)]
                    pub minter: UncheckedAccount<'info>,
                    /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
                    #[account(mut)]
                    pub non_fungible_mint: Signer<'info>,
                    /// CHECK: passed in via CPI to mpl_token_metadata program
                    #[account(mut)]
                    pub non_fungible_token_account: UncheckedAccount<'info>,
                    /// CHECK: Checked in constraint
                    #[account(constraint = token_program.key()= = token_2022::ID)]
                    pub token_program: UncheckedAccount<'info>,
                    #[account()]
                    pub associated_token_program: Program<'info, AssociatedToken>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, MintToken2022CtxBumps>
                for MintToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut MintToken2022CtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: anchor_lang::accounts::account::Account<
                            Deployment,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        let deployment_config: anchor_lang::accounts::account::Account<
                            DeploymentConfig,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment_config"))?;
                        let creator_fee_treasury: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("creator_fee_treasury"))?;
                        let hashlist: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("hashlist"))?;
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let hashlist_marker = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        let payer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("payer"))?;
                        let signer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("signer"))?;
                        let fungible_mint: anchor_lang::accounts::interface_account::InterfaceAccount<
                            Mint,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        let minter: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("minter"))?;
                        let non_fungible_mint: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        let non_fungible_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_token_account")
                            })?;
                        let token_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program"))?;
                        let associated_token_program: anchor_lang::accounts::program::Program<
                            AssociatedToken,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("associated_token_program")
                            })?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let __anchor_rent = Rent::get()?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &[
                                "hashlist_marker".as_bytes(),
                                deployment.key().as_ref(),
                                non_fungible_mint.key().as_ref(),
                            ],
                            __program_id,
                        );
                        __bumps.hashlist_marker = __bump;
                        if hashlist_marker.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_pubkeys((hashlist_marker.key(), __pda_address)),
                            );
                        }
                        let hashlist_marker = {
                            let actual_field = AsRef::<
                                AccountInfo,
                            >::as_ref(&hashlist_marker);
                            let actual_owner = actual_field.owner;
                            let space = 8 + HashlistMarker::INIT_SPACE;
                            let pa: anchor_lang::accounts::account::Account<
                                HashlistMarker,
                            > = if !false
                                || actual_owner
                                    == &anchor_lang::solana_program::system_program::ID
                            {
                                let __current_lamports = hashlist_marker.lamports();
                                if __current_lamports == 0 {
                                    let space = space;
                                    let lamports = __anchor_rent.minimum_balance(space);
                                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                        from: payer.to_account_info(),
                                        to: hashlist_marker.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::create_account(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist_marker".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        non_fungible_mint.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        lamports,
                                        space as u64,
                                        __program_id,
                                    )?;
                                } else {
                                    if payer.key() == hashlist_marker.key() {
                                        return Err(
                                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                    error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .name(),
                                                    error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .into(),
                                                    error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .to_string(),
                                                    error_origin: Some(
                                                        anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                            filename: "programs/libreplex_fair_launch/src/instructions/v2/token_2022/mint_2022.rs",
                                                            line: 18u32,
                                                        }),
                                                    ),
                                                    compared_values: None,
                                                })
                                                .with_pubkeys((payer.key(), hashlist_marker.key())),
                                        );
                                    }
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space)
                                        .max(1)
                                        .saturating_sub(__current_lamports);
                                    if required_lamports > 0 {
                                        let cpi_accounts = anchor_lang::system_program::Transfer {
                                            from: payer.to_account_info(),
                                            to: hashlist_marker.to_account_info(),
                                        };
                                        let cpi_context = anchor_lang::context::CpiContext::new(
                                            system_program.to_account_info(),
                                            cpi_accounts,
                                        );
                                        anchor_lang::system_program::transfer(
                                            cpi_context,
                                            required_lamports,
                                        )?;
                                    }
                                    let cpi_accounts = anchor_lang::system_program::Allocate {
                                        account_to_allocate: hashlist_marker.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::allocate(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist_marker".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        non_fungible_mint.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        space as u64,
                                    )?;
                                    let cpi_accounts = anchor_lang::system_program::Assign {
                                        account_to_assign: hashlist_marker.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::assign(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist_marker".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        non_fungible_mint.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        __program_id,
                                    )?;
                                }
                                match anchor_lang::accounts::account::Account::try_from_unchecked(
                                    &hashlist_marker,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist_marker")),
                                }
                            } else {
                                match anchor_lang::accounts::account::Account::try_from(
                                    &hashlist_marker,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist_marker")),
                                }
                            };
                            if false {
                                if space != actual_field.data_len() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintSpace,
                                            )
                                            .with_account_name("hashlist_marker")
                                            .with_values((space, actual_field.data_len())),
                                    );
                                }
                                if actual_owner != __program_id {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintOwner,
                                            )
                                            .with_account_name("hashlist_marker")
                                            .with_pubkeys((*actual_owner, *__program_id)),
                                    );
                                }
                                {
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space);
                                    if pa.to_account_info().lamports() < required_lamports {
                                        return Err(
                                            anchor_lang::error::Error::from(
                                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                                )
                                                .with_account_name("hashlist_marker"),
                                        );
                                    }
                                }
                            }
                            pa
                        };
                        if !AsRef::<AccountInfo>::as_ref(&hashlist_marker).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("hashlist_marker"),
                            );
                        }
                        if !__anchor_rent
                            .is_exempt(
                                hashlist_marker.to_account_info().lamports(),
                                hashlist_marker.to_account_info().try_data_len()?,
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                    )
                                    .with_account_name("hashlist_marker"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_ref(), deployment.ticker.as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment_config".as_ref(), deployment.key().as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment_config = __bump;
                        if deployment_config.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment_config")
                                    .with_pubkeys((deployment_config.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment_config).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment_config"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&creator_fee_treasury)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("creator_fee_treasury"),
                            );
                        }
                        if !(deployment_config.creator_fee_treasury
                            == creator_fee_treasury.key())
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("creator_fee_treasury"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["hashlist".as_bytes(), deployment.key().as_ref()],
                            &__program_id,
                        );
                        __bumps.hashlist = __bump;
                        if hashlist.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist")
                                    .with_pubkeys((hashlist.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&hashlist).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("hashlist"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("payer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&signer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("signer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&minter).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("minter"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&non_fungible_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_token_account"),
                            );
                        }
                        if !(token_program.key() == token_2022::ID) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("token_program"),
                            );
                        }
                        Ok(MintToken2022Ctx {
                            deployment,
                            deployment_config,
                            creator_fee_treasury,
                            hashlist,
                            hashlist_marker,
                            payer,
                            signer,
                            fungible_mint,
                            minter,
                            non_fungible_mint,
                            non_fungible_token_account,
                            token_program,
                            associated_token_program,
                            system_program,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for MintToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.deployment_config.to_account_infos());
                        account_infos
                            .extend(self.creator_fee_treasury.to_account_infos());
                        account_infos.extend(self.hashlist.to_account_infos());
                        account_infos.extend(self.hashlist_marker.to_account_infos());
                        account_infos.extend(self.payer.to_account_infos());
                        account_infos.extend(self.signer.to_account_infos());
                        account_infos.extend(self.fungible_mint.to_account_infos());
                        account_infos.extend(self.minter.to_account_infos());
                        account_infos.extend(self.non_fungible_mint.to_account_infos());
                        account_infos
                            .extend(self.non_fungible_token_account.to_account_infos());
                        account_infos.extend(self.token_program.to_account_infos());
                        account_infos
                            .extend(self.associated_token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for MintToken2022Ctx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas
                            .extend(self.deployment_config.to_account_metas(None));
                        account_metas
                            .extend(self.creator_fee_treasury.to_account_metas(None));
                        account_metas.extend(self.hashlist.to_account_metas(None));
                        account_metas
                            .extend(self.hashlist_marker.to_account_metas(None));
                        account_metas.extend(self.payer.to_account_metas(None));
                        account_metas.extend(self.signer.to_account_metas(None));
                        account_metas.extend(self.fungible_mint.to_account_metas(None));
                        account_metas.extend(self.minter.to_account_metas(None));
                        account_metas
                            .extend(self.non_fungible_mint.to_account_metas(None));
                        account_metas
                            .extend(
                                self.non_fungible_token_account.to_account_metas(None),
                            );
                        account_metas.extend(self.token_program.to_account_metas(None));
                        account_metas
                            .extend(
                                self.associated_token_program.to_account_metas(None),
                            );
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info> for MintToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.deployment_config,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("deployment_config"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.creator_fee_treasury,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("creator_fee_treasury"))?;
                        anchor_lang::AccountsExit::exit(&self.hashlist, program_id)
                            .map_err(|e| e.with_account_name("hashlist"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.hashlist_marker,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("hashlist_marker"))?;
                        anchor_lang::AccountsExit::exit(&self.payer, program_id)
                            .map_err(|e| e.with_account_name("payer"))?;
                        anchor_lang::AccountsExit::exit(&self.signer, program_id)
                            .map_err(|e| e.with_account_name("signer"))?;
                        anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(&self.minter, program_id)
                            .map_err(|e| e.with_account_name("minter"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_mint,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_token_account")
                            })?;
                        Ok(())
                    }
                }
                pub struct MintToken2022CtxBumps {
                    pub deployment: u8,
                    pub deployment_config: u8,
                    pub hashlist: u8,
                    pub hashlist_marker: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for MintToken2022CtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "MintToken2022CtxBumps",
                            "deployment",
                            &self.deployment,
                            "deployment_config",
                            &self.deployment_config,
                            "hashlist",
                            &self.hashlist,
                            "hashlist_marker",
                            &&self.hashlist_marker,
                        )
                    }
                }
                impl Default for MintToken2022CtxBumps {
                    fn default() -> Self {
                        MintToken2022CtxBumps {
                            deployment: u8::MAX,
                            deployment_config: u8::MAX,
                            hashlist: u8::MAX,
                            hashlist_marker: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for MintToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = MintToken2022CtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_mint_token2022_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`MintToken2022Ctx`].
                    pub struct MintToken2022Ctx {
                        pub deployment: Pubkey,
                        pub deployment_config: Pubkey,
                        pub creator_fee_treasury: Pubkey,
                        pub hashlist: Pubkey,
                        pub hashlist_marker: Pubkey,
                        pub payer: Pubkey,
                        pub signer: Pubkey,
                        pub fungible_mint: Pubkey,
                        pub minter: Pubkey,
                        pub non_fungible_mint: Pubkey,
                        pub non_fungible_token_account: Pubkey,
                        pub token_program: Pubkey,
                        pub associated_token_program: Pubkey,
                        pub system_program: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for MintToken2022Ctx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.deployment_config,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.creator_fee_treasury,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.hashlist, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.hashlist_marker,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.payer, writer)?;
                            borsh::BorshSerialize::serialize(&self.signer, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.minter, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.associated_token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for MintToken2022Ctx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment_config,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.creator_fee_treasury,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.hashlist,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.hashlist_marker,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.payer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.signer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.minter,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_mint,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.associated_token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_mint_token2022_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`MintToken2022Ctx`].
                    pub struct MintToken2022Ctx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub deployment_config: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub creator_fee_treasury: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub signer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub minter: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas for MintToken2022Ctx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment_config),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.creator_fee_treasury),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.hashlist),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.hashlist_marker),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.payer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.signer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.minter),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.non_fungible_mint),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.non_fungible_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.associated_token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info>
                    for MintToken2022Ctx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment_config,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.creator_fee_treasury,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist_marker,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.signer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.minter),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.associated_token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub struct MintInput {}
                impl borsh::ser::BorshSerialize for MintInput {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        Ok(())
                    }
                }
                impl AnchorDeserialize for MintInput {
                    fn deserialize_reader<R: std::io::prelude::Read>(
                        reader: &mut R,
                    ) -> std::io::Result<Self> {
                        ::core::panicking::panic("not yet implemented")
                    }
                }
                pub fn mint_token2022<'info>(
                    ctx: Context<'_, '_, '_, 'info, MintToken2022Ctx<'info>>,
                    input: MintInput,
                ) -> Result<()> {
                    let payer = &ctx.accounts.payer;
                    let signer = &ctx.accounts.signer;
                    let minter = &ctx.accounts.minter;
                    let non_fungible_mint = &ctx.accounts.non_fungible_mint;
                    let non_fungible_token_account = &ctx
                        .accounts
                        .non_fungible_token_account;
                    let token_program = &ctx.accounts.token_program;
                    let associated_token_program = &ctx
                        .accounts
                        .associated_token_program;
                    let system_program = &ctx.accounts.system_program;
                    let fungible_mint = &ctx.accounts.fungible_mint;
                    let deployment = &mut ctx.accounts.deployment;
                    let deployment_config = &mut ctx.accounts.deployment_config;
                    let creator_fee_treasury = &mut ctx.accounts.creator_fee_treasury;
                    let hashlist = &mut ctx.accounts.hashlist;
                    mint_token2022_logic(
                        deployment,
                        deployment_config,
                        creator_fee_treasury,
                        &fungible_mint.to_account_info(),
                        non_fungible_mint,
                        system_program,
                        payer,
                        associated_token_program,
                        token_program,
                        minter,
                        non_fungible_token_account,
                        hashlist,
                        ctx.bumps.deployment,
                        ctx.remaining_accounts,
                        &signer,
                        true,
                    )?;
                    Ok(())
                }
            }
            pub use mint_2022::*;
            pub mod deploy_token_2022 {
                use anchor_lang::prelude::*;
                use anchor_spl::associated_token::AssociatedToken;
                use crate::{
                    check_deploy_allowed, deploy_token_2022_logic, Deployment,
                    DeploymentConfig, Hashlist, TOKEN2022_DEPLOYMENT_TYPE,
                };
                pub mod sysvar_instructions_program {
                    use anchor_lang::declare_id;
                    /// The static program ID
                    pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                        6u8,
                        167u8,
                        213u8,
                        23u8,
                        24u8,
                        123u8,
                        209u8,
                        102u8,
                        53u8,
                        218u8,
                        212u8,
                        4u8,
                        85u8,
                        253u8,
                        194u8,
                        192u8,
                        193u8,
                        36u8,
                        198u8,
                        143u8,
                        33u8,
                        86u8,
                        117u8,
                        165u8,
                        219u8,
                        186u8,
                        203u8,
                        95u8,
                        8u8,
                        0u8,
                        0u8,
                        0u8,
                    ]);
                    /// Confirms that a given pubkey is equivalent to the program ID
                    pub fn check_id(
                        id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> bool {
                        id == &ID
                    }
                    /// Returns the program ID
                    pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                        ID
                    }
                }
                pub struct DeployV2Input {
                    pub require_creator_cosign: bool,
                    pub use_inscriptions: bool,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for DeployV2Input {
                    #[inline]
                    fn clone(&self) -> DeployV2Input {
                        DeployV2Input {
                            require_creator_cosign: ::core::clone::Clone::clone(
                                &self.require_creator_cosign,
                            ),
                            use_inscriptions: ::core::clone::Clone::clone(
                                &self.use_inscriptions,
                            ),
                        }
                    }
                }
                impl borsh::de::BorshDeserialize for DeployV2Input
                where
                    bool: borsh::BorshDeserialize,
                    bool: borsh::BorshDeserialize,
                {
                    fn deserialize_reader<R: borsh::maybestd::io::Read>(
                        reader: &mut R,
                    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                        Ok(Self {
                            require_creator_cosign: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                            use_inscriptions: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                        })
                    }
                }
                impl borsh::ser::BorshSerialize for DeployV2Input
                where
                    bool: borsh::ser::BorshSerialize,
                    bool: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(
                            &self.require_creator_cosign,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.use_inscriptions,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                pub struct DeployToken2022Ctx<'info> {
                    #[account(
                        mut,
                        seeds = ["deployment".as_bytes(),
                        deployment.ticker.as_bytes()],
                        bump
                    )]
                    pub deployment: Account<'info, Deployment>,
                    #[account(
                        seeds = ["deployment_config".as_bytes(),
                        deployment.key().as_ref()],
                        bump
                    )]
                    pub deployment_config: Account<'info, DeploymentConfig>,
                    #[account(
                        init,
                        seeds = ["hashlist".as_bytes(),
                        deployment.key().as_ref()],
                        bump,
                        payer = payer,
                        space = 8+32+4
                    )]
                    pub hashlist: Account<'info, Hashlist>,
                    #[account(mut)]
                    pub payer: Signer<'info>,
                    #[account(mut)]
                    pub creator: Signer<'info>,
                    #[account(mut)]
                    pub fungible_mint: Signer<'info>,
                    /// CHECK: checked in code
                    #[account(mut)]
                    pub fungible_escrow_token_account: UncheckedAccount<'info>,
                    /// CHECK: passed in via CPI to libreplex_inscriptions program
                    #[account(
                        constraint = token_program_2022.key()= = spl_token_2022::ID
                    )]
                    pub token_program_2022: UncheckedAccount<'info>,
                    #[account()]
                    pub associated_token_program: Program<'info, AssociatedToken>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                    #[account()]
                    pub rent: Sysvar<'info, Rent>,
                    /// CHECK: Id checked in constraint
                    #[account(
                        constraint = sysvar_instructions.key(

                        )= = sysvar_instructions_program::ID
                    )]
                    #[account()]
                    pub sysvar_instructions: UncheckedAccount<'info>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, DeployToken2022CtxBumps>
                for DeployToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut DeployToken2022CtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: anchor_lang::accounts::account::Account<
                            Deployment,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        let deployment_config: anchor_lang::accounts::account::Account<
                            DeploymentConfig,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment_config"))?;
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let hashlist = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        let payer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("payer"))?;
                        let creator: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("creator"))?;
                        let fungible_mint: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        let fungible_escrow_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_escrow_token_account")
                            })?;
                        let token_program_2022: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program_2022"))?;
                        let associated_token_program: anchor_lang::accounts::program::Program<
                            AssociatedToken,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("associated_token_program")
                            })?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let rent: Sysvar<Rent> = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("rent"))?;
                        let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                        let __anchor_rent = Rent::get()?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["hashlist".as_bytes(), deployment.key().as_ref()],
                            __program_id,
                        );
                        __bumps.hashlist = __bump;
                        if hashlist.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist")
                                    .with_pubkeys((hashlist.key(), __pda_address)),
                            );
                        }
                        let hashlist = {
                            let actual_field = AsRef::<AccountInfo>::as_ref(&hashlist);
                            let actual_owner = actual_field.owner;
                            let space = 8 + 32 + 4;
                            let pa: anchor_lang::accounts::account::Account<Hashlist> = if !false
                                || actual_owner
                                    == &anchor_lang::solana_program::system_program::ID
                            {
                                let __current_lamports = hashlist.lamports();
                                if __current_lamports == 0 {
                                    let space = space;
                                    let lamports = __anchor_rent.minimum_balance(space);
                                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                        from: payer.to_account_info(),
                                        to: hashlist.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::create_account(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        lamports,
                                        space as u64,
                                        __program_id,
                                    )?;
                                } else {
                                    if payer.key() == hashlist.key() {
                                        return Err(
                                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                    error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .name(),
                                                    error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .into(),
                                                    error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .to_string(),
                                                    error_origin: Some(
                                                        anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                            filename: "programs/libreplex_fair_launch/src/instructions/v2/token_2022/deploy_token_2022.rs",
                                                            line: 31u32,
                                                        }),
                                                    ),
                                                    compared_values: None,
                                                })
                                                .with_pubkeys((payer.key(), hashlist.key())),
                                        );
                                    }
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space)
                                        .max(1)
                                        .saturating_sub(__current_lamports);
                                    if required_lamports > 0 {
                                        let cpi_accounts = anchor_lang::system_program::Transfer {
                                            from: payer.to_account_info(),
                                            to: hashlist.to_account_info(),
                                        };
                                        let cpi_context = anchor_lang::context::CpiContext::new(
                                            system_program.to_account_info(),
                                            cpi_accounts,
                                        );
                                        anchor_lang::system_program::transfer(
                                            cpi_context,
                                            required_lamports,
                                        )?;
                                    }
                                    let cpi_accounts = anchor_lang::system_program::Allocate {
                                        account_to_allocate: hashlist.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::allocate(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        space as u64,
                                    )?;
                                    let cpi_accounts = anchor_lang::system_program::Assign {
                                        account_to_assign: hashlist.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::assign(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        __program_id,
                                    )?;
                                }
                                match anchor_lang::accounts::account::Account::try_from_unchecked(
                                    &hashlist,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist")),
                                }
                            } else {
                                match anchor_lang::accounts::account::Account::try_from(
                                    &hashlist,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist")),
                                }
                            };
                            if false {
                                if space != actual_field.data_len() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintSpace,
                                            )
                                            .with_account_name("hashlist")
                                            .with_values((space, actual_field.data_len())),
                                    );
                                }
                                if actual_owner != __program_id {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintOwner,
                                            )
                                            .with_account_name("hashlist")
                                            .with_pubkeys((*actual_owner, *__program_id)),
                                    );
                                }
                                {
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space);
                                    if pa.to_account_info().lamports() < required_lamports {
                                        return Err(
                                            anchor_lang::error::Error::from(
                                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                                )
                                                .with_account_name("hashlist"),
                                        );
                                    }
                                }
                            }
                            pa
                        };
                        if !AsRef::<AccountInfo>::as_ref(&hashlist).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("hashlist"),
                            );
                        }
                        if !__anchor_rent
                            .is_exempt(
                                hashlist.to_account_info().lamports(),
                                hashlist.to_account_info().try_data_len()?,
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                    )
                                    .with_account_name("hashlist"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_bytes(), deployment.ticker.as_bytes()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment_config".as_bytes(), deployment.key().as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment_config = __bump;
                        if deployment_config.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment_config")
                                    .with_pubkeys((deployment_config.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("payer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&creator).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("creator"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_escrow_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_escrow_token_account"),
                            );
                        }
                        if !(token_program_2022.key() == spl_token_2022::ID) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("token_program_2022"),
                            );
                        }
                        if !(sysvar_instructions.key()
                            == sysvar_instructions_program::ID)
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("sysvar_instructions"),
                            );
                        }
                        Ok(DeployToken2022Ctx {
                            deployment,
                            deployment_config,
                            hashlist,
                            payer,
                            creator,
                            fungible_mint,
                            fungible_escrow_token_account,
                            token_program_2022,
                            associated_token_program,
                            system_program,
                            rent,
                            sysvar_instructions,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for DeployToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.deployment_config.to_account_infos());
                        account_infos.extend(self.hashlist.to_account_infos());
                        account_infos.extend(self.payer.to_account_infos());
                        account_infos.extend(self.creator.to_account_infos());
                        account_infos.extend(self.fungible_mint.to_account_infos());
                        account_infos
                            .extend(
                                self.fungible_escrow_token_account.to_account_infos(),
                            );
                        account_infos.extend(self.token_program_2022.to_account_infos());
                        account_infos
                            .extend(self.associated_token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos.extend(self.rent.to_account_infos());
                        account_infos
                            .extend(self.sysvar_instructions.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for DeployToken2022Ctx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas
                            .extend(self.deployment_config.to_account_metas(None));
                        account_metas.extend(self.hashlist.to_account_metas(None));
                        account_metas.extend(self.payer.to_account_metas(None));
                        account_metas.extend(self.creator.to_account_metas(None));
                        account_metas.extend(self.fungible_mint.to_account_metas(None));
                        account_metas
                            .extend(
                                self.fungible_escrow_token_account.to_account_metas(None),
                            );
                        account_metas
                            .extend(self.token_program_2022.to_account_metas(None));
                        account_metas
                            .extend(
                                self.associated_token_program.to_account_metas(None),
                            );
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas.extend(self.rent.to_account_metas(None));
                        account_metas
                            .extend(self.sysvar_instructions.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info>
                for DeployToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(&self.hashlist, program_id)
                            .map_err(|e| e.with_account_name("hashlist"))?;
                        anchor_lang::AccountsExit::exit(&self.payer, program_id)
                            .map_err(|e| e.with_account_name("payer"))?;
                        anchor_lang::AccountsExit::exit(&self.creator, program_id)
                            .map_err(|e| e.with_account_name("creator"))?;
                        anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_escrow_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_escrow_token_account")
                            })?;
                        Ok(())
                    }
                }
                pub struct DeployToken2022CtxBumps {
                    pub deployment: u8,
                    pub deployment_config: u8,
                    pub hashlist: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for DeployToken2022CtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "DeployToken2022CtxBumps",
                            "deployment",
                            &self.deployment,
                            "deployment_config",
                            &self.deployment_config,
                            "hashlist",
                            &&self.hashlist,
                        )
                    }
                }
                impl Default for DeployToken2022CtxBumps {
                    fn default() -> Self {
                        DeployToken2022CtxBumps {
                            deployment: u8::MAX,
                            deployment_config: u8::MAX,
                            hashlist: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for DeployToken2022Ctx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = DeployToken2022CtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_deploy_token2022_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`DeployToken2022Ctx`].
                    pub struct DeployToken2022Ctx {
                        pub deployment: Pubkey,
                        pub deployment_config: Pubkey,
                        pub hashlist: Pubkey,
                        pub payer: Pubkey,
                        pub creator: Pubkey,
                        pub fungible_mint: Pubkey,
                        pub fungible_escrow_token_account: Pubkey,
                        pub token_program_2022: Pubkey,
                        pub associated_token_program: Pubkey,
                        pub system_program: Pubkey,
                        pub rent: Pubkey,
                        pub sysvar_instructions: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for DeployToken2022Ctx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.deployment_config,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.hashlist, writer)?;
                            borsh::BorshSerialize::serialize(&self.payer, writer)?;
                            borsh::BorshSerialize::serialize(&self.creator, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_escrow_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program_2022,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.associated_token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.rent, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.sysvar_instructions,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for DeployToken2022Ctx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.deployment_config,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.hashlist,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.payer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.creator,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_mint,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_escrow_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program_2022,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.associated_token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.rent,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.sysvar_instructions,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_deploy_token2022_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`DeployToken2022Ctx`].
                    pub struct DeployToken2022Ctx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub deployment_config: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub creator: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_escrow_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program_2022: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub rent: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas
                    for DeployToken2022Ctx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.deployment_config),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.hashlist),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.payer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.creator),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_mint),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_escrow_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program_2022),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.associated_token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.rent),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.sysvar_instructions),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info>
                    for DeployToken2022Ctx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment_config,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.creator),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_escrow_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program_2022,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.associated_token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.rent),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.sysvar_instructions,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub fn deploy_token_2022(
                    ctx: Context<DeployToken2022Ctx>,
                ) -> Result<()> {
                    let hashlist = &mut ctx.accounts.hashlist;
                    let deployment = &mut ctx.accounts.deployment;
                    let payer = &ctx.accounts.payer;
                    let fungible_mint = &ctx.accounts.fungible_mint;
                    let fungible_escrow_token_account = &ctx
                        .accounts
                        .fungible_escrow_token_account;
                    let token_program = &ctx.accounts.token_program_2022;
                    let associated_token_program = &ctx
                        .accounts
                        .associated_token_program;
                    let system_program = &ctx.accounts.system_program;
                    let deployment_config = &ctx.accounts.deployment_config;
                    check_deploy_allowed(deployment);
                    if deployment.deployment_type != TOKEN2022_DEPLOYMENT_TYPE {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("Wrong deployment type"),
                            );
                        }
                    }
                    deploy_token_2022_logic(
                        hashlist,
                        deployment,
                        deployment_config,
                        fungible_mint,
                        payer,
                        fungible_escrow_token_account,
                        token_program,
                        associated_token_program,
                        system_program,
                        ctx.bumps.deployment,
                    )?;
                    Ok(())
                }
            }
            pub use deploy_token_2022::*;
            pub mod deploy_hybrid {
                use anchor_lang::prelude::*;
                use anchor_spl::{
                    associated_token::AssociatedToken,
                    token::{spl_token, Mint, TokenAccount},
                };
                use solana_program::system_program;
                use crate::{
                    Deployment, Hashlist, deploy_hybrid_logic, HYBRID_DEPLOYMENT_TYPE,
                };
                pub mod sysvar_instructions_program {
                    use anchor_lang::declare_id;
                    /// The static program ID
                    pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                        6u8,
                        167u8,
                        213u8,
                        23u8,
                        24u8,
                        123u8,
                        209u8,
                        102u8,
                        53u8,
                        218u8,
                        212u8,
                        4u8,
                        85u8,
                        253u8,
                        194u8,
                        192u8,
                        193u8,
                        36u8,
                        198u8,
                        143u8,
                        33u8,
                        86u8,
                        117u8,
                        165u8,
                        219u8,
                        186u8,
                        203u8,
                        95u8,
                        8u8,
                        0u8,
                        0u8,
                        0u8,
                    ]);
                    /// Confirms that a given pubkey is equivalent to the program ID
                    pub fn check_id(
                        id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> bool {
                        id == &ID
                    }
                    /// Returns the program ID
                    pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                        ID
                    }
                }
                pub struct DeployV2Input {
                    pub require_creator_cosign: bool,
                    pub use_inscriptions: bool,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for DeployV2Input {
                    #[inline]
                    fn clone(&self) -> DeployV2Input {
                        DeployV2Input {
                            require_creator_cosign: ::core::clone::Clone::clone(
                                &self.require_creator_cosign,
                            ),
                            use_inscriptions: ::core::clone::Clone::clone(
                                &self.use_inscriptions,
                            ),
                        }
                    }
                }
                impl borsh::de::BorshDeserialize for DeployV2Input
                where
                    bool: borsh::BorshDeserialize,
                    bool: borsh::BorshDeserialize,
                {
                    fn deserialize_reader<R: borsh::maybestd::io::Read>(
                        reader: &mut R,
                    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                        Ok(Self {
                            require_creator_cosign: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                            use_inscriptions: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                        })
                    }
                }
                impl borsh::ser::BorshSerialize for DeployV2Input
                where
                    bool: borsh::ser::BorshSerialize,
                    bool: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(
                            &self.require_creator_cosign,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.use_inscriptions,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                pub struct DeployHybridCtx<'info> {
                    #[account(
                        mut,
                        seeds = ["deployment".as_bytes(),
                        deployment.ticker.as_bytes()],
                        bump
                    )]
                    pub deployment: Account<'info, Deployment>,
                    #[account(
                        init_if_needed,
                        seeds = ["hashlist".as_bytes(),
                        deployment.key().as_ref()],
                        bump,
                        payer = payer,
                        space = 8+32+4
                    )]
                    pub hashlist: Account<'info, Hashlist>,
                    #[account(mut)]
                    pub payer: Signer<'info>,
                    #[account(mut)]
                    pub creator: Signer<'info>,
                    #[account(
                        init,
                        payer = payer,
                        mint::freeze_authority = deployment,
                        mint::authority = deployment,
                        mint::decimals = deployment.decimals
                    )]
                    pub fungible_mint: Account<'info, Mint>,
                    /// CHECK: Passed via CPI
                    #[account(mut)]
                    pub fungible_master_edition: UncheckedAccount<'info>,
                    /// CHECK: Passed via CPI
                    #[account(mut)]
                    pub fungible_metadata: UncheckedAccount<'info>,
                    /// CHECK: checked in code
                    #[account(
                        init,
                        associated_token::mint = fungible_mint,
                        payer = payer,
                        associated_token::authority = deployment
                    )]
                    pub fungible_escrow_token_account: Account<'info, TokenAccount>,
                    /// CHECK: passed in via CPI to libreplex_inscriptions program
                    #[account(constraint = token_program.key()= = spl_token::ID)]
                    pub token_program: UncheckedAccount<'info>,
                    #[account()]
                    pub associated_token_program: Program<'info, AssociatedToken>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                    #[account()]
                    pub rent: Sysvar<'info, Rent>,
                    /// CHECK: Id checked in constraint
                    #[account(
                        constraint = sysvar_instructions.key(

                        )= = sysvar_instructions_program::ID
                    )]
                    #[account()]
                    pub sysvar_instructions: UncheckedAccount<'info>,
                    /// CHECK: address checked
                    #[account(address = mpl_token_metadata::ID)]
                    pub metadata_program: UncheckedAccount<'info>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, DeployHybridCtxBumps>
                for DeployHybridCtx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut DeployHybridCtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: anchor_lang::accounts::account::Account<
                            Deployment,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let hashlist = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        let payer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("payer"))?;
                        let creator: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("creator"))?;
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let fungible_mint = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        let fungible_master_edition: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_master_edition")
                            })?;
                        let fungible_metadata: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("fungible_metadata"))?;
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let fungible_escrow_token_account = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        let token_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program"))?;
                        let associated_token_program: anchor_lang::accounts::program::Program<
                            AssociatedToken,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("associated_token_program")
                            })?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let rent: Sysvar<Rent> = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("rent"))?;
                        let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                        let metadata_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("metadata_program"))?;
                        let __anchor_rent = Rent::get()?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["hashlist".as_bytes(), deployment.key().as_ref()],
                            __program_id,
                        );
                        __bumps.hashlist = __bump;
                        if hashlist.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist")
                                    .with_pubkeys((hashlist.key(), __pda_address)),
                            );
                        }
                        let hashlist = {
                            let actual_field = AsRef::<AccountInfo>::as_ref(&hashlist);
                            let actual_owner = actual_field.owner;
                            let space = 8 + 32 + 4;
                            let pa: anchor_lang::accounts::account::Account<Hashlist> = if !true
                                || actual_owner
                                    == &anchor_lang::solana_program::system_program::ID
                            {
                                let __current_lamports = hashlist.lamports();
                                if __current_lamports == 0 {
                                    let space = space;
                                    let lamports = __anchor_rent.minimum_balance(space);
                                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                        from: payer.to_account_info(),
                                        to: hashlist.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::create_account(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        lamports,
                                        space as u64,
                                        __program_id,
                                    )?;
                                } else {
                                    if payer.key() == hashlist.key() {
                                        return Err(
                                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                    error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .name(),
                                                    error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .into(),
                                                    error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .to_string(),
                                                    error_origin: Some(
                                                        anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                            filename: "programs/libreplex_fair_launch/src/instructions/v2/token_2022/deploy_hybrid.rs",
                                                            line: 32u32,
                                                        }),
                                                    ),
                                                    compared_values: None,
                                                })
                                                .with_pubkeys((payer.key(), hashlist.key())),
                                        );
                                    }
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space)
                                        .max(1)
                                        .saturating_sub(__current_lamports);
                                    if required_lamports > 0 {
                                        let cpi_accounts = anchor_lang::system_program::Transfer {
                                            from: payer.to_account_info(),
                                            to: hashlist.to_account_info(),
                                        };
                                        let cpi_context = anchor_lang::context::CpiContext::new(
                                            system_program.to_account_info(),
                                            cpi_accounts,
                                        );
                                        anchor_lang::system_program::transfer(
                                            cpi_context,
                                            required_lamports,
                                        )?;
                                    }
                                    let cpi_accounts = anchor_lang::system_program::Allocate {
                                        account_to_allocate: hashlist.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::allocate(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        space as u64,
                                    )?;
                                    let cpi_accounts = anchor_lang::system_program::Assign {
                                        account_to_assign: hashlist.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::assign(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        __program_id,
                                    )?;
                                }
                                match anchor_lang::accounts::account::Account::try_from_unchecked(
                                    &hashlist,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist")),
                                }
                            } else {
                                match anchor_lang::accounts::account::Account::try_from(
                                    &hashlist,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist")),
                                }
                            };
                            if true {
                                if space != actual_field.data_len() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintSpace,
                                            )
                                            .with_account_name("hashlist")
                                            .with_values((space, actual_field.data_len())),
                                    );
                                }
                                if actual_owner != __program_id {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintOwner,
                                            )
                                            .with_account_name("hashlist")
                                            .with_pubkeys((*actual_owner, *__program_id)),
                                    );
                                }
                                {
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space);
                                    if pa.to_account_info().lamports() < required_lamports {
                                        return Err(
                                            anchor_lang::error::Error::from(
                                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                                )
                                                .with_account_name("hashlist"),
                                        );
                                    }
                                }
                            }
                            pa
                        };
                        if !AsRef::<AccountInfo>::as_ref(&hashlist).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("hashlist"),
                            );
                        }
                        if !__anchor_rent
                            .is_exempt(
                                hashlist.to_account_info().lamports(),
                                hashlist.to_account_info().try_data_len()?,
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                    )
                                    .with_account_name("hashlist"),
                            );
                        }
                        let __anchor_rent = Rent::get()?;
                        let fungible_mint: anchor_lang::accounts::account::Account<
                            Mint,
                        > = {
                            let owner_program = AsRef::<
                                AccountInfo,
                            >::as_ref(&fungible_mint)
                                .owner;
                            if !false
                                || owner_program
                                    == &anchor_lang::solana_program::system_program::ID
                            {
                                let __current_lamports = fungible_mint.lamports();
                                if __current_lamports == 0 {
                                    let space = ::anchor_spl::token::Mint::LEN;
                                    let lamports = __anchor_rent.minimum_balance(space);
                                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                        from: payer.to_account_info(),
                                        to: fungible_mint.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::create_account(
                                        cpi_context.with_signer(&[]),
                                        lamports,
                                        space as u64,
                                        &token_program.key(),
                                    )?;
                                } else {
                                    if payer.key() == fungible_mint.key() {
                                        return Err(
                                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                    error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .name(),
                                                    error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .into(),
                                                    error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .to_string(),
                                                    error_origin: Some(
                                                        anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                            filename: "programs/libreplex_fair_launch/src/instructions/v2/token_2022/deploy_hybrid.rs",
                                                            line: 32u32,
                                                        }),
                                                    ),
                                                    compared_values: None,
                                                })
                                                .with_pubkeys((payer.key(), fungible_mint.key())),
                                        );
                                    }
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(::anchor_spl::token::Mint::LEN)
                                        .max(1)
                                        .saturating_sub(__current_lamports);
                                    if required_lamports > 0 {
                                        let cpi_accounts = anchor_lang::system_program::Transfer {
                                            from: payer.to_account_info(),
                                            to: fungible_mint.to_account_info(),
                                        };
                                        let cpi_context = anchor_lang::context::CpiContext::new(
                                            system_program.to_account_info(),
                                            cpi_accounts,
                                        );
                                        anchor_lang::system_program::transfer(
                                            cpi_context,
                                            required_lamports,
                                        )?;
                                    }
                                    let cpi_accounts = anchor_lang::system_program::Allocate {
                                        account_to_allocate: fungible_mint.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::allocate(
                                        cpi_context.with_signer(&[]),
                                        ::anchor_spl::token::Mint::LEN as u64,
                                    )?;
                                    let cpi_accounts = anchor_lang::system_program::Assign {
                                        account_to_assign: fungible_mint.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::assign(
                                        cpi_context.with_signer(&[]),
                                        &token_program.key(),
                                    )?;
                                }
                                let cpi_program = token_program.to_account_info();
                                let accounts = ::anchor_spl::token_interface::InitializeMint2 {
                                    mint: fungible_mint.to_account_info(),
                                };
                                let cpi_ctx = anchor_lang::context::CpiContext::new(
                                    cpi_program,
                                    accounts,
                                );
                                ::anchor_spl::token_interface::initialize_mint2(
                                    cpi_ctx,
                                    deployment.decimals,
                                    &deployment.key(),
                                    Option::<
                                        &anchor_lang::prelude::Pubkey,
                                    >::Some(&deployment.key()),
                                )?;
                            }
                            let pa: anchor_lang::accounts::account::Account<Mint> = match anchor_lang::accounts::account::Account::try_from_unchecked(
                                &fungible_mint,
                            ) {
                                Ok(val) => val,
                                Err(e) => return Err(e.with_account_name("fungible_mint")),
                            };
                            if false {
                                if pa.mint_authority
                                    != anchor_lang::solana_program::program_option::COption::Some(
                                        deployment.key(),
                                    )
                                {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintMintMintAuthority,
                                            )
                                            .with_account_name("fungible_mint"),
                                    );
                                }
                                if pa
                                    .freeze_authority
                                    .as_ref()
                                    .map(|fa| {
                                        Option::<
                                            &anchor_lang::prelude::Pubkey,
                                        >::Some(&deployment.key())
                                            .as_ref()
                                            .map(|expected_fa| fa != *expected_fa)
                                            .unwrap_or(true)
                                    })
                                    .unwrap_or(
                                        Option::<
                                            &anchor_lang::prelude::Pubkey,
                                        >::Some(&deployment.key())
                                            .is_some(),
                                    )
                                {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintMintFreezeAuthority,
                                            )
                                            .with_account_name("fungible_mint"),
                                    );
                                }
                                if pa.decimals != deployment.decimals {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintMintDecimals,
                                            )
                                            .with_account_name("fungible_mint")
                                            .with_values((pa.decimals, deployment.decimals)),
                                    );
                                }
                                if owner_program != &token_program.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram,
                                            )
                                            .with_account_name("fungible_mint")
                                            .with_pubkeys((*owner_program, token_program.key())),
                                    );
                                }
                            }
                            pa
                        };
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_signer {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSigner,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !__anchor_rent
                            .is_exempt(
                                fungible_mint.to_account_info().lamports(),
                                fungible_mint.to_account_info().try_data_len()?,
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        let __anchor_rent = Rent::get()?;
                        let fungible_escrow_token_account: anchor_lang::accounts::account::Account<
                            TokenAccount,
                        > = {
                            let owner_program = AsRef::<
                                AccountInfo,
                            >::as_ref(&fungible_escrow_token_account)
                                .owner;
                            if !false
                                || owner_program
                                    == &anchor_lang::solana_program::system_program::ID
                            {
                                let cpi_program = associated_token_program
                                    .to_account_info();
                                let cpi_accounts = ::anchor_spl::associated_token::Create {
                                    payer: payer.to_account_info(),
                                    associated_token: fungible_escrow_token_account
                                        .to_account_info(),
                                    authority: deployment.to_account_info(),
                                    mint: fungible_mint.to_account_info(),
                                    system_program: system_program.to_account_info(),
                                    token_program: token_program.to_account_info(),
                                };
                                let cpi_ctx = anchor_lang::context::CpiContext::new(
                                    cpi_program,
                                    cpi_accounts,
                                );
                                ::anchor_spl::associated_token::create(cpi_ctx)?;
                            }
                            let pa: anchor_lang::accounts::account::Account<
                                TokenAccount,
                            > = match anchor_lang::accounts::account::Account::try_from_unchecked(
                                &fungible_escrow_token_account,
                            ) {
                                Ok(val) => val,
                                Err(e) => {
                                    return Err(
                                        e.with_account_name("fungible_escrow_token_account"),
                                    );
                                }
                            };
                            if false {
                                if pa.mint != fungible_mint.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintTokenMint,
                                            )
                                            .with_account_name("fungible_escrow_token_account")
                                            .with_pubkeys((pa.mint, fungible_mint.key())),
                                    );
                                }
                                if pa.owner != deployment.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintTokenOwner,
                                            )
                                            .with_account_name("fungible_escrow_token_account")
                                            .with_pubkeys((pa.owner, deployment.key())),
                                    );
                                }
                                if owner_program != &token_program.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintAssociatedTokenTokenProgram,
                                            )
                                            .with_account_name("fungible_escrow_token_account")
                                            .with_pubkeys((*owner_program, token_program.key())),
                                    );
                                }
                                if pa.key()
                                    != ::anchor_spl::associated_token::get_associated_token_address_with_program_id(
                                        &deployment.key(),
                                        &fungible_mint.key(),
                                        &token_program.key(),
                                    )
                                {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::AccountNotAssociatedTokenAccount,
                                            )
                                            .with_account_name("fungible_escrow_token_account"),
                                    );
                                }
                            }
                            pa
                        };
                        if !AsRef::<AccountInfo>::as_ref(&fungible_escrow_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_escrow_token_account"),
                            );
                        }
                        if !__anchor_rent
                            .is_exempt(
                                fungible_escrow_token_account.to_account_info().lamports(),
                                fungible_escrow_token_account
                                    .to_account_info()
                                    .try_data_len()?,
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                    )
                                    .with_account_name("fungible_escrow_token_account"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_bytes(), deployment.ticker.as_bytes()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("payer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&creator).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("creator"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_master_edition)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_master_edition"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_metadata).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_metadata"),
                            );
                        }
                        if !(token_program.key() == spl_token::ID) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("token_program"),
                            );
                        }
                        if !(sysvar_instructions.key()
                            == sysvar_instructions_program::ID)
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("sysvar_instructions"),
                            );
                        }
                        {
                            let actual = metadata_program.key();
                            let expected = mpl_token_metadata::ID;
                            if actual != expected {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintAddress,
                                        )
                                        .with_account_name("metadata_program")
                                        .with_pubkeys((actual, expected)),
                                );
                            }
                        }
                        Ok(DeployHybridCtx {
                            deployment,
                            hashlist,
                            payer,
                            creator,
                            fungible_mint,
                            fungible_master_edition,
                            fungible_metadata,
                            fungible_escrow_token_account,
                            token_program,
                            associated_token_program,
                            system_program,
                            rent,
                            sysvar_instructions,
                            metadata_program,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info> for DeployHybridCtx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.hashlist.to_account_infos());
                        account_infos.extend(self.payer.to_account_infos());
                        account_infos.extend(self.creator.to_account_infos());
                        account_infos.extend(self.fungible_mint.to_account_infos());
                        account_infos
                            .extend(self.fungible_master_edition.to_account_infos());
                        account_infos.extend(self.fungible_metadata.to_account_infos());
                        account_infos
                            .extend(
                                self.fungible_escrow_token_account.to_account_infos(),
                            );
                        account_infos.extend(self.token_program.to_account_infos());
                        account_infos
                            .extend(self.associated_token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos.extend(self.rent.to_account_infos());
                        account_infos
                            .extend(self.sysvar_instructions.to_account_infos());
                        account_infos.extend(self.metadata_program.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for DeployHybridCtx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas.extend(self.hashlist.to_account_metas(None));
                        account_metas.extend(self.payer.to_account_metas(None));
                        account_metas.extend(self.creator.to_account_metas(None));
                        account_metas
                            .extend(self.fungible_mint.to_account_metas(Some(true)));
                        account_metas
                            .extend(self.fungible_master_edition.to_account_metas(None));
                        account_metas
                            .extend(self.fungible_metadata.to_account_metas(None));
                        account_metas
                            .extend(
                                self.fungible_escrow_token_account.to_account_metas(None),
                            );
                        account_metas.extend(self.token_program.to_account_metas(None));
                        account_metas
                            .extend(
                                self.associated_token_program.to_account_metas(None),
                            );
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas.extend(self.rent.to_account_metas(None));
                        account_metas
                            .extend(self.sysvar_instructions.to_account_metas(None));
                        account_metas
                            .extend(self.metadata_program.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info> for DeployHybridCtx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(&self.hashlist, program_id)
                            .map_err(|e| e.with_account_name("hashlist"))?;
                        anchor_lang::AccountsExit::exit(&self.payer, program_id)
                            .map_err(|e| e.with_account_name("payer"))?;
                        anchor_lang::AccountsExit::exit(&self.creator, program_id)
                            .map_err(|e| e.with_account_name("creator"))?;
                        anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_master_edition,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_master_edition")
                            })?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_metadata,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("fungible_metadata"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_escrow_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_escrow_token_account")
                            })?;
                        Ok(())
                    }
                }
                pub struct DeployHybridCtxBumps {
                    pub deployment: u8,
                    pub hashlist: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for DeployHybridCtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "DeployHybridCtxBumps",
                            "deployment",
                            &self.deployment,
                            "hashlist",
                            &&self.hashlist,
                        )
                    }
                }
                impl Default for DeployHybridCtxBumps {
                    fn default() -> Self {
                        DeployHybridCtxBumps {
                            deployment: u8::MAX,
                            hashlist: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for DeployHybridCtx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = DeployHybridCtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_deploy_hybrid_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`DeployHybridCtx`].
                    pub struct DeployHybridCtx {
                        pub deployment: Pubkey,
                        pub hashlist: Pubkey,
                        pub payer: Pubkey,
                        pub creator: Pubkey,
                        pub fungible_mint: Pubkey,
                        pub fungible_master_edition: Pubkey,
                        pub fungible_metadata: Pubkey,
                        pub fungible_escrow_token_account: Pubkey,
                        pub token_program: Pubkey,
                        pub associated_token_program: Pubkey,
                        pub system_program: Pubkey,
                        pub rent: Pubkey,
                        pub sysvar_instructions: Pubkey,
                        pub metadata_program: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for DeployHybridCtx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(&self.hashlist, writer)?;
                            borsh::BorshSerialize::serialize(&self.payer, writer)?;
                            borsh::BorshSerialize::serialize(&self.creator, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_master_edition,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_metadata,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_escrow_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.associated_token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.rent, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.sysvar_instructions,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.metadata_program,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for DeployHybridCtx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.hashlist,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.payer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.creator,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_mint,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_master_edition,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_metadata,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_escrow_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.associated_token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.rent,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.sysvar_instructions,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.metadata_program,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_deploy_hybrid_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`DeployHybridCtx`].
                    pub struct DeployHybridCtx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub creator: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_master_edition: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_metadata: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_escrow_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub rent: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub metadata_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas for DeployHybridCtx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.hashlist),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.payer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.creator),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_mint),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_master_edition),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_metadata),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_escrow_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.associated_token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.rent),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.sysvar_instructions),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.metadata_program),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info>
                    for DeployHybridCtx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.creator),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_master_edition,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_metadata,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_escrow_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.associated_token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.rent),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.sysvar_instructions,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.metadata_program,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub fn deploy_hybrid(ctx: Context<DeployHybridCtx>) -> Result<()> {
                    let hashlist = &mut ctx.accounts.hashlist;
                    let deployment = &mut ctx.accounts.deployment;
                    let payer = &ctx.accounts.payer;
                    let fungible_mint = &ctx.accounts.fungible_mint;
                    let fungible_metadata = &ctx.accounts.fungible_metadata;
                    let fungible_master_edition = &ctx.accounts.fungible_master_edition;
                    let fungible_escrow_token_account = &ctx
                        .accounts
                        .fungible_escrow_token_account;
                    let token_program = &ctx.accounts.token_program;
                    let associated_token_program = &ctx
                        .accounts
                        .associated_token_program;
                    let system_program = &ctx.accounts.system_program;
                    let rent = &ctx.accounts.rent;
                    let metadata_program = &ctx.accounts.metadata_program;
                    check_deploy_allowed(deployment);
                    let sysvar_instructions = &ctx.accounts.sysvar_instructions;
                    if deployment.deployment_type != HYBRID_DEPLOYMENT_TYPE {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("Wrong deployment type"),
                            );
                        }
                    }
                    deploy_hybrid_logic(
                        hashlist,
                        deployment,
                        fungible_mint.as_ref(),
                        fungible_metadata,
                        fungible_master_edition,
                        payer,
                        fungible_escrow_token_account.as_ref(),
                        token_program,
                        associated_token_program,
                        system_program,
                        rent,
                        sysvar_instructions,
                        metadata_program,
                        ctx.bumps.deployment,
                    )?;
                    Ok(())
                }
                pub fn check_deploy_allowed(deployment: &Account<Deployment>) {
                    if deployment.fungible_mint != system_program::ID {
                        if deployment.require_creator_cosign {
                            if deployment.number_of_tokens_issued > 0 {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Cannot force redeploy after tokens have been issued",
                                        ),
                                    );
                                }
                            }
                        } else {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("Cannot redeploy without creator cosign"),
                                );
                            }
                        }
                    }
                }
            }
            pub use deploy_hybrid::*;
            pub mod swap_to_fungible_2022 {
                use anchor_lang::prelude::*;
                use anchor_spl::{
                    token_2022, associated_token::AssociatedToken,
                    token_interface::{Token2022, TokenAccount},
                    token::{spl_token, Token},
                };
                use libreplex_shared::operations::transfer_generic_spl;
                use crate::{Deployment, HashlistMarker};
                pub mod sysvar_instructions_program {
                    use anchor_lang::declare_id;
                    /// The static program ID
                    pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                        6u8,
                        167u8,
                        213u8,
                        23u8,
                        24u8,
                        123u8,
                        209u8,
                        102u8,
                        53u8,
                        218u8,
                        212u8,
                        4u8,
                        85u8,
                        253u8,
                        194u8,
                        192u8,
                        193u8,
                        36u8,
                        198u8,
                        143u8,
                        33u8,
                        86u8,
                        117u8,
                        165u8,
                        219u8,
                        186u8,
                        203u8,
                        95u8,
                        8u8,
                        0u8,
                        0u8,
                        0u8,
                    ]);
                    /// Confirms that a given pubkey is equivalent to the program ID
                    pub fn check_id(
                        id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> bool {
                        id == &ID
                    }
                    /// Returns the program ID
                    pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                        ID
                    }
                }
                pub struct SwapToFungible2022Ctx<'info> {
                    #[account(
                        mut,
                        constraint = deployment.fungible_mint = = fungible_mint.key(),
                        seeds = ["deployment".as_ref(),
                        deployment.ticker.as_ref()],
                        bump
                    )]
                    pub deployment: Box<Account<'info, Deployment>>,
                    #[account(mut)]
                    pub payer: Signer<'info>,
                    #[account(
                        constraint = !deployment.require_creator_cosign||deployment.creator = = signer.key(

                        )
                    )]
                    pub signer: Signer<'info>,
                    /// CHECK: Owner must be spl token or token 2022
                    #[account(
                        mut,
                        constraint = fungible_mint.owner.eq(
                            &token_2022::ID
                        )||fungible_mint.owner.eq(&spl_token::ID)
                    )]
                    pub fungible_mint: UncheckedAccount<'info>,
                    #[account(
                        seeds = ["hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref()],
                        bump,
                    )]
                    pub hashlist_marker: Account<'info, HashlistMarker>,
                    /// this always exists so we can specify the account type explicitly
                    #[account(
                        mut,
                        token::mint = fungible_mint,
                        token::authority = deployment,
                    )]
                    pub fungible_source_token_account: InterfaceAccount<
                        'info,
                        TokenAccount,
                    >,
                    /// CHECK: derivation checked in Logic. May not exist so created as required.
                    #[account(mut)]
                    pub fungible_target_token_account: UncheckedAccount<'info>,
                    /// CHECK: Can be anyone they do not need to consent to receiving a token.
                    pub fungible_target_token_account_owner: UncheckedAccount<'info>,
                    /// CHECK: checked in constraint
                    #[account(mut)]
                    pub non_fungible_mint: UncheckedAccount<'info>,
                    pub non_fungible_source_account_owner: Signer<'info>,
                    /// this always exists (otherwise we couldn't swap), so we can specify the account
                    /// type explicitly
                    #[account(
                        mut,
                        token::mint = non_fungible_mint,
                        token::authority = non_fungible_source_account_owner,
                    )]
                    pub non_fungible_source_token_account: InterfaceAccount<
                        'info,
                        TokenAccount,
                    >,
                    /// CHECK: derivation checked in Logic. Will be created as needed
                    #[account(mut)]
                    pub non_fungible_target_token_account: UncheckedAccount<'info>,
                    pub token_program_22: Program<'info, Token2022>,
                    pub token_program: Program<'info, Token>,
                    #[account()]
                    pub associated_token_program: Program<'info, AssociatedToken>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                    /// CHECK: Checked in constraint
                    #[account(
                        constraint = sysvar_instructions.key(

                        )= = sysvar_instructions_program::ID
                    )]
                    sysvar_instructions: UncheckedAccount<'info>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, SwapToFungible2022CtxBumps>
                for SwapToFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut SwapToFungible2022CtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: Box<
                            anchor_lang::accounts::account::Account<Deployment>,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        let payer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("payer"))?;
                        let signer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("signer"))?;
                        let fungible_mint: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        let hashlist_marker: anchor_lang::accounts::account::Account<
                            HashlistMarker,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("hashlist_marker"))?;
                        let fungible_source_token_account: anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_source_token_account")
                            })?;
                        let fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_target_token_account")
                            })?;
                        let fungible_target_token_account_owner: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_target_token_account_owner")
                            })?;
                        let non_fungible_mint: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        let non_fungible_source_account_owner: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_source_account_owner")
                            })?;
                        let non_fungible_source_token_account: anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_source_token_account")
                            })?;
                        let non_fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_target_token_account")
                            })?;
                        let token_program_22: anchor_lang::accounts::program::Program<
                            Token2022,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program_22"))?;
                        let token_program: anchor_lang::accounts::program::Program<
                            Token,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program"))?;
                        let associated_token_program: anchor_lang::accounts::program::Program<
                            AssociatedToken,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("associated_token_program")
                            })?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_ref(), deployment.ticker.as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(deployment.as_ref()).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        if !(deployment.fungible_mint == fungible_mint.key()) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("payer"),
                            );
                        }
                        if !(!deployment.require_creator_cosign
                            || deployment.creator == signer.key())
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("signer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !(fungible_mint.owner.eq(&token_2022::ID)
                            || fungible_mint.owner.eq(&spl_token::ID))
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &[
                                "hashlist_marker".as_bytes(),
                                deployment.key().as_ref(),
                                non_fungible_mint.key().as_ref(),
                            ],
                            &__program_id,
                        );
                        __bumps.hashlist_marker = __bump;
                        if hashlist_marker.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_pubkeys((hashlist_marker.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_source_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_source_token_account"),
                            );
                        }
                        {
                            if fungible_source_token_account.owner != deployment.key() {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                                );
                            }
                            if fungible_source_token_account.mint != fungible_mint.key()
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                                );
                            }
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_target_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_target_token_account"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        if !AsRef::<
                            AccountInfo,
                        >::as_ref(&non_fungible_source_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_source_token_account"),
                            );
                        }
                        {
                            if non_fungible_source_token_account.owner
                                != non_fungible_source_account_owner.key()
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                                );
                            }
                            if non_fungible_source_token_account.mint
                                != non_fungible_mint.key()
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                                );
                            }
                        }
                        if !AsRef::<
                            AccountInfo,
                        >::as_ref(&non_fungible_target_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_target_token_account"),
                            );
                        }
                        if !(sysvar_instructions.key()
                            == sysvar_instructions_program::ID)
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("sysvar_instructions"),
                            );
                        }
                        Ok(SwapToFungible2022Ctx {
                            deployment,
                            payer,
                            signer,
                            fungible_mint,
                            hashlist_marker,
                            fungible_source_token_account,
                            fungible_target_token_account,
                            fungible_target_token_account_owner,
                            non_fungible_mint,
                            non_fungible_source_account_owner,
                            non_fungible_source_token_account,
                            non_fungible_target_token_account,
                            token_program_22,
                            token_program,
                            associated_token_program,
                            system_program,
                            sysvar_instructions,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for SwapToFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.payer.to_account_infos());
                        account_infos.extend(self.signer.to_account_infos());
                        account_infos.extend(self.fungible_mint.to_account_infos());
                        account_infos.extend(self.hashlist_marker.to_account_infos());
                        account_infos
                            .extend(
                                self.fungible_source_token_account.to_account_infos(),
                            );
                        account_infos
                            .extend(
                                self.fungible_target_token_account.to_account_infos(),
                            );
                        account_infos
                            .extend(
                                self.fungible_target_token_account_owner.to_account_infos(),
                            );
                        account_infos.extend(self.non_fungible_mint.to_account_infos());
                        account_infos
                            .extend(
                                self.non_fungible_source_account_owner.to_account_infos(),
                            );
                        account_infos
                            .extend(
                                self.non_fungible_source_token_account.to_account_infos(),
                            );
                        account_infos
                            .extend(
                                self.non_fungible_target_token_account.to_account_infos(),
                            );
                        account_infos.extend(self.token_program_22.to_account_infos());
                        account_infos.extend(self.token_program.to_account_infos());
                        account_infos
                            .extend(self.associated_token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos
                            .extend(self.sysvar_instructions.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas
                for SwapToFungible2022Ctx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas.extend(self.payer.to_account_metas(None));
                        account_metas.extend(self.signer.to_account_metas(None));
                        account_metas.extend(self.fungible_mint.to_account_metas(None));
                        account_metas
                            .extend(self.hashlist_marker.to_account_metas(None));
                        account_metas
                            .extend(
                                self.fungible_source_token_account.to_account_metas(None),
                            );
                        account_metas
                            .extend(
                                self.fungible_target_token_account.to_account_metas(None),
                            );
                        account_metas
                            .extend(
                                self
                                    .fungible_target_token_account_owner
                                    .to_account_metas(None),
                            );
                        account_metas
                            .extend(self.non_fungible_mint.to_account_metas(None));
                        account_metas
                            .extend(
                                self
                                    .non_fungible_source_account_owner
                                    .to_account_metas(None),
                            );
                        account_metas
                            .extend(
                                self
                                    .non_fungible_source_token_account
                                    .to_account_metas(None),
                            );
                        account_metas
                            .extend(
                                self
                                    .non_fungible_target_token_account
                                    .to_account_metas(None),
                            );
                        account_metas
                            .extend(self.token_program_22.to_account_metas(None));
                        account_metas.extend(self.token_program.to_account_metas(None));
                        account_metas
                            .extend(
                                self.associated_token_program.to_account_metas(None),
                            );
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas
                            .extend(self.sysvar_instructions.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info>
                for SwapToFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(&self.payer, program_id)
                            .map_err(|e| e.with_account_name("payer"))?;
                        anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_source_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_source_token_account")
                            })?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_target_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_target_token_account")
                            })?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_mint,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_source_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_source_token_account")
                            })?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_target_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_target_token_account")
                            })?;
                        Ok(())
                    }
                }
                pub struct SwapToFungible2022CtxBumps {
                    pub deployment: u8,
                    pub hashlist_marker: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for SwapToFungible2022CtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "SwapToFungible2022CtxBumps",
                            "deployment",
                            &self.deployment,
                            "hashlist_marker",
                            &&self.hashlist_marker,
                        )
                    }
                }
                impl Default for SwapToFungible2022CtxBumps {
                    fn default() -> Self {
                        SwapToFungible2022CtxBumps {
                            deployment: u8::MAX,
                            hashlist_marker: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for SwapToFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = SwapToFungible2022CtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_swap_to_fungible2022_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`SwapToFungible2022Ctx`].
                    pub struct SwapToFungible2022Ctx {
                        pub deployment: Pubkey,
                        pub payer: Pubkey,
                        pub signer: Pubkey,
                        pub fungible_mint: Pubkey,
                        pub hashlist_marker: Pubkey,
                        ///this always exists so we can specify the account type explicitly
                        pub fungible_source_token_account: Pubkey,
                        pub fungible_target_token_account: Pubkey,
                        pub fungible_target_token_account_owner: Pubkey,
                        pub non_fungible_mint: Pubkey,
                        pub non_fungible_source_account_owner: Pubkey,
                        ///this always exists (otherwise we couldn't swap), so we can specify the account
                        ///type explicitly
                        pub non_fungible_source_token_account: Pubkey,
                        pub non_fungible_target_token_account: Pubkey,
                        pub token_program_22: Pubkey,
                        pub token_program: Pubkey,
                        pub associated_token_program: Pubkey,
                        pub system_program: Pubkey,
                        pub sysvar_instructions: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for SwapToFungible2022Ctx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(&self.payer, writer)?;
                            borsh::BorshSerialize::serialize(&self.signer, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.hashlist_marker,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_source_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_target_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_target_token_account_owner,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_source_account_owner,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_source_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_target_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program_22,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.associated_token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.sysvar_instructions,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for SwapToFungible2022Ctx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.payer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.signer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.hashlist_marker,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_source_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_target_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.fungible_target_token_account_owner,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.non_fungible_source_account_owner,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_source_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_target_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program_22,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.associated_token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.sysvar_instructions,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_swap_to_fungible2022_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`SwapToFungible2022Ctx`].
                    pub struct SwapToFungible2022Ctx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub signer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        ///this always exists so we can specify the account type explicitly
                        pub fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_target_token_account_owner: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_source_account_owner: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        ///this always exists (otherwise we couldn't swap), so we can specify the account
                        ///type explicitly
                        pub non_fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program_22: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas
                    for SwapToFungible2022Ctx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.payer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.signer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.hashlist_marker),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_source_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_target_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(
                                            &self.fungible_target_token_account_owner,
                                        ),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.non_fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(
                                            &self.non_fungible_source_account_owner,
                                        ),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(
                                            &self.non_fungible_source_token_account,
                                        ),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(
                                            &self.non_fungible_target_token_account,
                                        ),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program_22),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.associated_token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.sysvar_instructions),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info>
                    for SwapToFungible2022Ctx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.signer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist_marker,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_source_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_target_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_target_token_account_owner,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_source_account_owner,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_source_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_target_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program_22,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.associated_token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.sysvar_instructions,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub fn swap_to_fungible_2022(
                    ctx: Context<SwapToFungible2022Ctx>,
                ) -> Result<()> {
                    let token_program = &ctx.accounts.token_program;
                    let token_program_22 = &ctx.accounts.token_program_22;
                    let payer = &ctx.accounts.payer;
                    let non_fungible_source_account_owner = &ctx
                        .accounts
                        .non_fungible_source_account_owner;
                    let non_fungible_source_token_account = &ctx
                        .accounts
                        .non_fungible_source_token_account;
                    let non_fungible_target_token_account = &ctx
                        .accounts
                        .non_fungible_target_token_account;
                    let non_fungible_mint = &ctx.accounts.non_fungible_mint;
                    let fungible_target_token_account_owner = &ctx
                        .accounts
                        .fungible_target_token_account_owner;
                    let fungible_source_token_account = &ctx
                        .accounts
                        .fungible_source_token_account;
                    let fungible_target_token_account = &ctx
                        .accounts
                        .fungible_target_token_account;
                    let fungible_mint = &ctx.accounts.fungible_mint;
                    let deployment = &mut ctx.accounts.deployment;
                    let associated_token_program = &ctx
                        .accounts
                        .associated_token_program;
                    let system_program = &ctx.accounts.system_program;
                    let source_token_program = match *non_fungible_mint.owner {
                        spl_token::ID => token_program.to_account_info(),
                        spl_token_2022::ID => token_program_22.to_account_info(),
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("How could you do this to me"),
                            );
                        }
                    };
                    ::solana_program::log::sol_log(
                        "Transferring non fungible into escrow",
                    );
                    transfer_generic_spl(
                        source_token_program.as_ref(),
                        non_fungible_source_token_account.as_ref(),
                        non_fungible_target_token_account,
                        non_fungible_source_account_owner,
                        non_fungible_mint,
                        deployment.as_ref().as_ref(),
                        associated_token_program,
                        system_program,
                        None,
                        payer,
                        0,
                        1,
                    )?;
                    let ticker = deployment.ticker.clone();
                    let authority_seeds = &[
                        "deployment".as_bytes(),
                        ticker.as_ref(),
                        &[ctx.bumps.deployment],
                    ];
                    ::solana_program::log::sol_log("Transferring fungible from escrow");
                    let target_token_program = match *fungible_mint.owner {
                        spl_token::ID => token_program.to_account_info(),
                        spl_token_2022::ID => token_program_22.to_account_info(),
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("How could you do this to me"),
                            );
                        }
                    };
                    transfer_generic_spl(
                        &target_token_program,
                        &fungible_source_token_account.to_account_info(),
                        &fungible_target_token_account.to_account_info(),
                        &deployment.to_account_info(),
                        &fungible_mint.clone(),
                        &fungible_target_token_account_owner.to_account_info(),
                        &associated_token_program.to_account_info(),
                        &system_program.to_account_info(),
                        Some(&[authority_seeds]),
                        &payer.to_account_info(),
                        deployment.decimals,
                        deployment.get_fungible_mint_amount(),
                    )?;
                    deployment.escrow_non_fungible_count += 1;
                    Ok(())
                }
            }
            pub use swap_to_fungible_2022::*;
            pub mod swap_to_non_fungible_2022 {
                use crate::{DeploymentConfig, HashlistMarker};
                use anchor_lang::prelude::*;
                use anchor_spl::{
                    associated_token::AssociatedToken, token::{spl_token, Token},
                    token_2022, token_interface::{Token2022, TokenAccount},
                };
                use libreplex_shared::operations::transfer_generic_spl;
                use crate::Deployment;
                pub mod sysvar_instructions_program {
                    use anchor_lang::declare_id;
                    /// The static program ID
                    pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                        6u8,
                        167u8,
                        213u8,
                        23u8,
                        24u8,
                        123u8,
                        209u8,
                        102u8,
                        53u8,
                        218u8,
                        212u8,
                        4u8,
                        85u8,
                        253u8,
                        194u8,
                        192u8,
                        193u8,
                        36u8,
                        198u8,
                        143u8,
                        33u8,
                        86u8,
                        117u8,
                        165u8,
                        219u8,
                        186u8,
                        203u8,
                        95u8,
                        8u8,
                        0u8,
                        0u8,
                        0u8,
                    ]);
                    /// Confirms that a given pubkey is equivalent to the program ID
                    pub fn check_id(
                        id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> bool {
                        id == &ID
                    }
                    /// Returns the program ID
                    pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                        ID
                    }
                }
                pub struct SwapToNonFungible2022Ctx<'info> {
                    #[account(
                        mut,
                        constraint = deployment.fungible_mint = = fungible_mint.key(),
                        seeds = ["deployment".as_ref(),
                        deployment.ticker.as_ref()],
                        bump
                    )]
                    pub deployment: Account<'info, Deployment>,
                    /// CHECK: Checked by deserialize in transfer logic
                    #[account(
                        seeds = ["deployment_config".as_bytes(),
                        deployment.key().as_ref()],
                        bump
                    )]
                    pub deployment_config: UncheckedAccount<'info>,
                    #[account(mut)]
                    pub payer: Signer<'info>,
                    /// CHECK: Checked in constraint
                    #[account(
                        mut,
                        constraint = fungible_mint.owner.eq(
                            &token_2022::ID
                        )||fungible_mint.owner.eq(&spl_token::ID)
                    )]
                    pub fungible_mint: UncheckedAccount<'info>,
                    #[account(
                        mut,
                        token::mint = fungible_mint,
                        token::authority = payer,
                    )]
                    pub fungible_source_token_account: InterfaceAccount<
                        'info,
                        TokenAccount,
                    >,
                    /// CHECK: Checked in transfer logic
                    #[account(mut)]
                    pub fungible_target_token_account: UncheckedAccount<'info>,
                    /// CHECK: Checked in constraint
                    #[account(
                        mut,
                        constraint = non_fungible_mint.owner.eq(
                            &token_2022::ID
                        )||non_fungible_mint.owner.eq(&spl_token::ID)
                    )]
                    pub non_fungible_mint: UncheckedAccount<'info>,
                    #[account(
                        mut,
                        token::mint = non_fungible_mint,
                        token::authority = deployment,
                    )]
                    pub non_fungible_source_token_account: InterfaceAccount<
                        'info,
                        TokenAccount,
                    >,
                    #[account(
                        seeds = ["hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref()],
                        bump,
                    )]
                    pub hashlist_marker: Account<'info, HashlistMarker>,
                    /// CHECK: Checked in transfer logic
                    #[account(mut)]
                    pub non_fungible_target_token_account: UncheckedAccount<'info>,
                    pub token_program_22: Program<'info, Token2022>,
                    pub token_program: Program<'info, Token>,
                    #[account()]
                    pub associated_token_program: Program<'info, AssociatedToken>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                    /// CHECK: Checked in constraint
                    #[account(
                        constraint = sysvar_instructions.key(

                        )= = sysvar_instructions_program::ID
                    )]
                    sysvar_instructions: UncheckedAccount<'info>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, SwapToNonFungible2022CtxBumps>
                for SwapToNonFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut SwapToNonFungible2022CtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: anchor_lang::accounts::account::Account<
                            Deployment,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        let deployment_config: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment_config"))?;
                        let payer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("payer"))?;
                        let fungible_mint: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        let fungible_source_token_account: anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_source_token_account")
                            })?;
                        let fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_target_token_account")
                            })?;
                        let non_fungible_mint: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        let non_fungible_source_token_account: anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_source_token_account")
                            })?;
                        let hashlist_marker: anchor_lang::accounts::account::Account<
                            HashlistMarker,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("hashlist_marker"))?;
                        let non_fungible_target_token_account: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_target_token_account")
                            })?;
                        let token_program_22: anchor_lang::accounts::program::Program<
                            Token2022,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program_22"))?;
                        let token_program: anchor_lang::accounts::program::Program<
                            Token,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program"))?;
                        let associated_token_program: anchor_lang::accounts::program::Program<
                            AssociatedToken,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("associated_token_program")
                            })?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let sysvar_instructions: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("sysvar_instructions"))?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_ref(), deployment.ticker.as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        if !(deployment.fungible_mint == fungible_mint.key()) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment_config".as_bytes(), deployment.key().as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment_config = __bump;
                        if deployment_config.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment_config")
                                    .with_pubkeys((deployment_config.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("payer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !(fungible_mint.owner.eq(&token_2022::ID)
                            || fungible_mint.owner.eq(&spl_token::ID))
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_source_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_source_token_account"),
                            );
                        }
                        {
                            if fungible_source_token_account.owner != payer.key() {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                                );
                            }
                            if fungible_source_token_account.mint != fungible_mint.key()
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                                );
                            }
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_target_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_target_token_account"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        if !(non_fungible_mint.owner.eq(&token_2022::ID)
                            || non_fungible_mint.owner.eq(&spl_token::ID))
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        if !AsRef::<
                            AccountInfo,
                        >::as_ref(&non_fungible_source_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_source_token_account"),
                            );
                        }
                        {
                            if non_fungible_source_token_account.owner
                                != deployment.key()
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                                );
                            }
                            if non_fungible_source_token_account.mint
                                != non_fungible_mint.key()
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                                );
                            }
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &[
                                "hashlist_marker".as_bytes(),
                                deployment.key().as_ref(),
                                non_fungible_mint.key().as_ref(),
                            ],
                            &__program_id,
                        );
                        __bumps.hashlist_marker = __bump;
                        if hashlist_marker.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_pubkeys((hashlist_marker.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<
                            AccountInfo,
                        >::as_ref(&non_fungible_target_token_account)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_target_token_account"),
                            );
                        }
                        if !(sysvar_instructions.key()
                            == sysvar_instructions_program::ID)
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("sysvar_instructions"),
                            );
                        }
                        Ok(SwapToNonFungible2022Ctx {
                            deployment,
                            deployment_config,
                            payer,
                            fungible_mint,
                            fungible_source_token_account,
                            fungible_target_token_account,
                            non_fungible_mint,
                            non_fungible_source_token_account,
                            hashlist_marker,
                            non_fungible_target_token_account,
                            token_program_22,
                            token_program,
                            associated_token_program,
                            system_program,
                            sysvar_instructions,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for SwapToNonFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.deployment_config.to_account_infos());
                        account_infos.extend(self.payer.to_account_infos());
                        account_infos.extend(self.fungible_mint.to_account_infos());
                        account_infos
                            .extend(
                                self.fungible_source_token_account.to_account_infos(),
                            );
                        account_infos
                            .extend(
                                self.fungible_target_token_account.to_account_infos(),
                            );
                        account_infos.extend(self.non_fungible_mint.to_account_infos());
                        account_infos
                            .extend(
                                self.non_fungible_source_token_account.to_account_infos(),
                            );
                        account_infos.extend(self.hashlist_marker.to_account_infos());
                        account_infos
                            .extend(
                                self.non_fungible_target_token_account.to_account_infos(),
                            );
                        account_infos.extend(self.token_program_22.to_account_infos());
                        account_infos.extend(self.token_program.to_account_infos());
                        account_infos
                            .extend(self.associated_token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos
                            .extend(self.sysvar_instructions.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas
                for SwapToNonFungible2022Ctx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas
                            .extend(self.deployment_config.to_account_metas(None));
                        account_metas.extend(self.payer.to_account_metas(None));
                        account_metas.extend(self.fungible_mint.to_account_metas(None));
                        account_metas
                            .extend(
                                self.fungible_source_token_account.to_account_metas(None),
                            );
                        account_metas
                            .extend(
                                self.fungible_target_token_account.to_account_metas(None),
                            );
                        account_metas
                            .extend(self.non_fungible_mint.to_account_metas(None));
                        account_metas
                            .extend(
                                self
                                    .non_fungible_source_token_account
                                    .to_account_metas(None),
                            );
                        account_metas
                            .extend(self.hashlist_marker.to_account_metas(None));
                        account_metas
                            .extend(
                                self
                                    .non_fungible_target_token_account
                                    .to_account_metas(None),
                            );
                        account_metas
                            .extend(self.token_program_22.to_account_metas(None));
                        account_metas.extend(self.token_program.to_account_metas(None));
                        account_metas
                            .extend(
                                self.associated_token_program.to_account_metas(None),
                            );
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas
                            .extend(self.sysvar_instructions.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info>
                for SwapToNonFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(&self.payer, program_id)
                            .map_err(|e| e.with_account_name("payer"))?;
                        anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_source_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_source_token_account")
                            })?;
                        anchor_lang::AccountsExit::exit(
                                &self.fungible_target_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("fungible_target_token_account")
                            })?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_mint,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_source_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_source_token_account")
                            })?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_target_token_account,
                                program_id,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_target_token_account")
                            })?;
                        Ok(())
                    }
                }
                pub struct SwapToNonFungible2022CtxBumps {
                    pub deployment: u8,
                    pub deployment_config: u8,
                    pub hashlist_marker: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for SwapToNonFungible2022CtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "SwapToNonFungible2022CtxBumps",
                            "deployment",
                            &self.deployment,
                            "deployment_config",
                            &self.deployment_config,
                            "hashlist_marker",
                            &&self.hashlist_marker,
                        )
                    }
                }
                impl Default for SwapToNonFungible2022CtxBumps {
                    fn default() -> Self {
                        SwapToNonFungible2022CtxBumps {
                            deployment: u8::MAX,
                            deployment_config: u8::MAX,
                            hashlist_marker: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for SwapToNonFungible2022Ctx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = SwapToNonFungible2022CtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_swap_to_non_fungible2022_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`SwapToNonFungible2022Ctx`].
                    pub struct SwapToNonFungible2022Ctx {
                        pub deployment: Pubkey,
                        pub deployment_config: Pubkey,
                        pub payer: Pubkey,
                        pub fungible_mint: Pubkey,
                        pub fungible_source_token_account: Pubkey,
                        pub fungible_target_token_account: Pubkey,
                        pub non_fungible_mint: Pubkey,
                        pub non_fungible_source_token_account: Pubkey,
                        pub hashlist_marker: Pubkey,
                        pub non_fungible_target_token_account: Pubkey,
                        pub token_program_22: Pubkey,
                        pub token_program: Pubkey,
                        pub associated_token_program: Pubkey,
                        pub system_program: Pubkey,
                        pub sysvar_instructions: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for SwapToNonFungible2022Ctx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.deployment_config,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.payer, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_source_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_target_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_source_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.hashlist_marker,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_target_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program_22,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.associated_token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.sysvar_instructions,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for SwapToNonFungible2022Ctx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.deployment_config,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.payer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_source_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_target_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_source_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.hashlist_marker,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_target_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program_22,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.associated_token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.sysvar_instructions,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_swap_to_non_fungible2022_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`SwapToNonFungible2022Ctx`].
                    pub struct SwapToNonFungible2022Ctx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub deployment_config: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_source_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_target_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program_22: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub sysvar_instructions: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas
                    for SwapToNonFungible2022Ctx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.deployment_config),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.payer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_source_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_target_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.non_fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(
                                            &self.non_fungible_source_token_account,
                                        ),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.hashlist_marker),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(
                                            &self.non_fungible_target_token_account,
                                        ),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program_22),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.associated_token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.sysvar_instructions),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info>
                    for SwapToNonFungible2022Ctx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment_config,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_source_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_target_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_source_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist_marker,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_target_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program_22,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.associated_token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.sysvar_instructions,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub fn swap_to_nonfungible_2022<'a>(
                    ctx: Context<'_, '_, '_, 'a, SwapToNonFungible2022Ctx<'a>>,
                ) -> Result<()> {
                    let token_program = &ctx.accounts.token_program;
                    let payer = &ctx.accounts.payer;
                    let non_fungible_source_token_account = &ctx
                        .accounts
                        .non_fungible_source_token_account;
                    let non_fungible_target_token_account = &ctx
                        .accounts
                        .non_fungible_target_token_account;
                    let non_fungible_mint = &ctx.accounts.non_fungible_mint;
                    let source_wallet = &ctx.accounts.payer;
                    let fungible_source_token_account = &ctx
                        .accounts
                        .fungible_source_token_account;
                    let fungible_target_token_account = &ctx
                        .accounts
                        .fungible_target_token_account;
                    let fungible_mint = &ctx.accounts.fungible_mint;
                    let deployment = &mut ctx.accounts.deployment;
                    let deployment_config = &ctx.accounts.deployment_config;
                    let associated_token_program = &ctx
                        .accounts
                        .associated_token_program;
                    let system_program = &ctx.accounts.system_program;
                    let token_program_22 = &ctx.accounts.token_program_22;
                    let source_token_program = match *non_fungible_mint.owner {
                        spl_token::ID => token_program.to_account_info(),
                        spl_token_2022::ID => token_program_22.to_account_info(),
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("How could you do this to me"),
                            );
                        }
                    };
                    let target_token_program = match *fungible_mint.owner {
                        spl_token::ID => token_program.to_account_info(),
                        spl_token_2022::ID => token_program_22.to_account_info(),
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("How could you do this to me"),
                            );
                        }
                    };
                    let mut fungible_amount_to_transfer = deployment
                        .get_fungible_mint_amount();
                    if !deployment_config.data_is_empty() {
                        let tai = deployment_config.to_account_info();
                        let mut data: &[u8] = &tai.try_borrow_data()?;
                        let deployment_config_object = DeploymentConfig::try_deserialize(
                            &mut data,
                        )?;
                        if deployment_config_object.deflation_rate_per_swap > 0 {
                            let mut numerator = (deployment.get_fungible_mint_amount()
                                as u128)
                                .checked_mul(10_000_u128)
                                .unwrap();
                            let denominator = 10_000_u128
                                .checked_sub(
                                    deployment_config_object.deflation_rate_per_swap as u128,
                                )
                                .unwrap();
                            let remainder = numerator.checked_rem(denominator);
                            if let Some(x) = remainder {
                                if x > 0 {
                                    numerator = numerator
                                        .checked_add(denominator)
                                        .unwrap()
                                        .checked_sub(x)
                                        .unwrap();
                                }
                            }
                            fungible_amount_to_transfer = numerator
                                .checked_div(denominator)
                                .unwrap() as u64;
                        }
                    }
                    transfer_generic_spl(
                        &target_token_program.to_account_info(),
                        &fungible_source_token_account.to_account_info(),
                        &fungible_target_token_account.to_account_info(),
                        &source_wallet.to_account_info(),
                        &fungible_mint.to_account_info(),
                        &deployment.to_account_info(),
                        &associated_token_program.to_account_info(),
                        &system_program.to_account_info(),
                        None,
                        &payer.to_account_info(),
                        deployment.decimals,
                        fungible_amount_to_transfer,
                    )?;
                    deployment.escrow_non_fungible_count -= 1;
                    let authority_seeds = &[
                        "deployment".as_bytes(),
                        deployment.ticker.as_ref(),
                        &[ctx.bumps.deployment],
                    ];
                    transfer_generic_spl(
                        &source_token_program.to_account_info(),
                        &non_fungible_source_token_account.to_account_info(),
                        &non_fungible_target_token_account.to_account_info(),
                        &deployment.to_account_info(),
                        &non_fungible_mint.to_account_info(),
                        &source_wallet.to_account_info(),
                        &associated_token_program.to_account_info(),
                        &system_program.to_account_info(),
                        Some(&[authority_seeds]),
                        &payer.to_account_info(),
                        0,
                        1,
                    )?;
                    Ok(())
                }
            }
            pub use swap_to_non_fungible_2022::*;
            pub mod update_symbol_2022 {
                use anchor_lang::prelude::*;
                use anchor_spl::{token_2022, token_interface::Mint};
                use solana_program::program::invoke_signed;
                use spl_token_metadata_interface::{
                    instruction::update_field, state::Field,
                };
                use crate::{Deployment, HashlistMarker};
                pub struct UpdateSymbol2022Ctx<'info> {
                    #[account(
                        mut,
                        seeds = ["deployment".as_ref(),
                        deployment.ticker.as_ref()],
                        bump
                    )]
                    pub deployment: Account<'info, Deployment>,
                    #[account(
                        seeds = ["hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref()],
                        bump,
                    )]
                    pub hashlist_marker: Account<'info, HashlistMarker>,
                    #[account(mut)]
                    pub signer: Signer<'info>,
                    /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
                    #[account(mut)]
                    pub non_fungible_mint: InterfaceAccount<'info, Mint>,
                    /// CHECK: Checked in constraint
                    #[account(constraint = token_program.key()= = token_2022::ID)]
                    pub token_program: UncheckedAccount<'info>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, UpdateSymbol2022CtxBumps>
                for UpdateSymbol2022Ctx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut UpdateSymbol2022CtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: anchor_lang::accounts::account::Account<
                            Deployment,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        let hashlist_marker: anchor_lang::accounts::account::Account<
                            HashlistMarker,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("hashlist_marker"))?;
                        let signer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("signer"))?;
                        let non_fungible_mint: anchor_lang::accounts::interface_account::InterfaceAccount<
                            Mint,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        let token_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program"))?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_ref(), deployment.ticker.as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &[
                                "hashlist_marker".as_bytes(),
                                deployment.key().as_ref(),
                                non_fungible_mint.key().as_ref(),
                            ],
                            &__program_id,
                        );
                        __bumps.hashlist_marker = __bump;
                        if hashlist_marker.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_pubkeys((hashlist_marker.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&signer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("signer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        if !(token_program.key() == token_2022::ID) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("token_program"),
                            );
                        }
                        Ok(UpdateSymbol2022Ctx {
                            deployment,
                            hashlist_marker,
                            signer,
                            non_fungible_mint,
                            token_program,
                            system_program,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for UpdateSymbol2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.hashlist_marker.to_account_infos());
                        account_infos.extend(self.signer.to_account_infos());
                        account_infos.extend(self.non_fungible_mint.to_account_infos());
                        account_infos.extend(self.token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for UpdateSymbol2022Ctx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas
                            .extend(self.hashlist_marker.to_account_metas(None));
                        account_metas.extend(self.signer.to_account_metas(None));
                        account_metas
                            .extend(self.non_fungible_mint.to_account_metas(None));
                        account_metas.extend(self.token_program.to_account_metas(None));
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info>
                for UpdateSymbol2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(&self.signer, program_id)
                            .map_err(|e| e.with_account_name("signer"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_mint,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        Ok(())
                    }
                }
                pub struct UpdateSymbol2022CtxBumps {
                    pub deployment: u8,
                    pub hashlist_marker: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for UpdateSymbol2022CtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "UpdateSymbol2022CtxBumps",
                            "deployment",
                            &self.deployment,
                            "hashlist_marker",
                            &&self.hashlist_marker,
                        )
                    }
                }
                impl Default for UpdateSymbol2022CtxBumps {
                    fn default() -> Self {
                        UpdateSymbol2022CtxBumps {
                            deployment: u8::MAX,
                            hashlist_marker: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for UpdateSymbol2022Ctx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = UpdateSymbol2022CtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_update_symbol2022_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`UpdateSymbol2022Ctx`].
                    pub struct UpdateSymbol2022Ctx {
                        pub deployment: Pubkey,
                        pub hashlist_marker: Pubkey,
                        pub signer: Pubkey,
                        pub non_fungible_mint: Pubkey,
                        pub token_program: Pubkey,
                        pub system_program: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for UpdateSymbol2022Ctx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.hashlist_marker,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.signer, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for UpdateSymbol2022Ctx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.hashlist_marker,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.signer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_update_symbol2022_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`UpdateSymbol2022Ctx`].
                    pub struct UpdateSymbol2022Ctx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub signer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas
                    for UpdateSymbol2022Ctx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.hashlist_marker),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.signer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.non_fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info>
                    for UpdateSymbol2022Ctx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist_marker,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.signer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub fn update_symbol2022(
                    ctx: Context<UpdateSymbol2022Ctx>,
                ) -> Result<()> {
                    let non_fungible_mint = &ctx.accounts.non_fungible_mint;
                    let deployment = &mut ctx.accounts.deployment;
                    let deployment_seeds: &[&[u8]] = &[
                        "deployment".as_bytes(),
                        deployment.ticker.as_ref(),
                        &[ctx.bumps.deployment],
                    ];
                    let initialise_metadata_ix = update_field(
                        &spl_token_2022::ID,
                        &non_fungible_mint.key(),
                        &deployment.key(),
                        Field::Symbol,
                        deployment.ticker.clone(),
                    );
                    let account_infos = &[
                        non_fungible_mint.to_account_info(),
                        deployment.to_account_info(),
                    ];
                    invoke_signed(
                        &initialise_metadata_ix,
                        account_infos,
                        &[deployment_seeds],
                    )?;
                    Ok(())
                }
            }
            pub use update_symbol_2022::*;
            pub mod update_spl_metadata_2022 {
                use anchor_lang::prelude::*;
                use anchor_spl::{token_2022, token_interface::Mint};
                use solana_program::program::invoke_signed;
                use spl_token_metadata_interface::{
                    instruction::update_field, state::Field,
                };
                use crate::Deployment;
                pub struct UpdateSplMetadata2022Ctx<'info> {
                    #[account(
                        mut,
                        seeds = ["deployment".as_ref(),
                        deployment.ticker.as_ref()],
                        bump
                    )]
                    pub deployment: Account<'info, Deployment>,
                    #[account(mut, constraint = deployment.creator = = signer.key())]
                    pub signer: Signer<'info>,
                    /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
                    #[account(
                        mut,
                        constraint = deployment.fungible_mint = = fungible_mint.key()
                    )]
                    pub fungible_mint: InterfaceAccount<'info, Mint>,
                    /// CHECK: Checked in constraint
                    #[account(constraint = token_program.key()= = token_2022::ID)]
                    pub token_program: UncheckedAccount<'info>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, UpdateSplMetadata2022CtxBumps>
                for UpdateSplMetadata2022Ctx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut UpdateSplMetadata2022CtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: anchor_lang::accounts::account::Account<
                            Deployment,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        let signer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("signer"))?;
                        let fungible_mint: anchor_lang::accounts::interface_account::InterfaceAccount<
                            Mint,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        let token_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program"))?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_ref(), deployment.ticker.as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&signer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("signer"),
                            );
                        }
                        if !(deployment.creator == signer.key()) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("signer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !(deployment.fungible_mint == fungible_mint.key()) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !(token_program.key() == token_2022::ID) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("token_program"),
                            );
                        }
                        Ok(UpdateSplMetadata2022Ctx {
                            deployment,
                            signer,
                            fungible_mint,
                            token_program,
                            system_program,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for UpdateSplMetadata2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.signer.to_account_infos());
                        account_infos.extend(self.fungible_mint.to_account_infos());
                        account_infos.extend(self.token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas
                for UpdateSplMetadata2022Ctx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas.extend(self.signer.to_account_metas(None));
                        account_metas.extend(self.fungible_mint.to_account_metas(None));
                        account_metas.extend(self.token_program.to_account_metas(None));
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info>
                for UpdateSplMetadata2022Ctx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(&self.signer, program_id)
                            .map_err(|e| e.with_account_name("signer"))?;
                        anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        Ok(())
                    }
                }
                pub struct UpdateSplMetadata2022CtxBumps {
                    pub deployment: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for UpdateSplMetadata2022CtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "UpdateSplMetadata2022CtxBumps",
                            "deployment",
                            &&self.deployment,
                        )
                    }
                }
                impl Default for UpdateSplMetadata2022CtxBumps {
                    fn default() -> Self {
                        UpdateSplMetadata2022CtxBumps {
                            deployment: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for UpdateSplMetadata2022Ctx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = UpdateSplMetadata2022CtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_update_spl_metadata2022_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`UpdateSplMetadata2022Ctx`].
                    pub struct UpdateSplMetadata2022Ctx {
                        pub deployment: Pubkey,
                        pub signer: Pubkey,
                        pub fungible_mint: Pubkey,
                        pub token_program: Pubkey,
                        pub system_program: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for UpdateSplMetadata2022Ctx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(&self.signer, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for UpdateSplMetadata2022Ctx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.signer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_update_spl_metadata2022_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`UpdateSplMetadata2022Ctx`].
                    pub struct UpdateSplMetadata2022Ctx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub signer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas
                    for UpdateSplMetadata2022Ctx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.signer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info>
                    for UpdateSplMetadata2022Ctx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.signer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub fn update_spl_metadata2022(
                    ctx: Context<UpdateSplMetadata2022Ctx>,
                    new_uri: String,
                ) -> Result<()> {
                    let fungible_mint = &ctx.accounts.fungible_mint;
                    let deployment = &mut ctx.accounts.deployment;
                    let deployment_seeds: &[&[u8]] = &[
                        "deployment".as_bytes(),
                        deployment.ticker.as_ref(),
                        &[ctx.bumps.deployment],
                    ];
                    let update_metadata_ix = update_field(
                        &spl_token_2022::ID,
                        &fungible_mint.key(),
                        &deployment.key(),
                        Field::Symbol,
                        deployment.ticker.clone(),
                    );
                    let account_infos = &[
                        fungible_mint.to_account_info(),
                        deployment.to_account_info(),
                    ];
                    invoke_signed(
                        &update_metadata_ix,
                        account_infos,
                        &[deployment_seeds],
                    )?;
                    let update_metadata_ix: solana_program::instruction::Instruction = update_field(
                        &spl_token_2022::ID,
                        &fungible_mint.key(),
                        &deployment.key(),
                        Field::Uri,
                        new_uri,
                    );
                    let account_infos = &[
                        fungible_mint.to_account_info(),
                        deployment.to_account_info(),
                    ];
                    invoke_signed(
                        &update_metadata_ix,
                        account_infos,
                        &[deployment_seeds],
                    )?;
                    Ok(())
                }
            }
            pub use update_spl_metadata_2022::*;
            pub mod join {
                use anchor_lang::prelude::*;
                use anchor_spl::token_interface::TokenAccount;
                use anchor_spl::{
                    associated_token::AssociatedToken, token_2022, token_interface::Mint,
                };
                use spl_pod::optional_keys::OptionalNonZeroPubkey;
                use spl_token_2022::extension::group_member_pointer::GroupMemberPointer;
                use spl_token_2022::extension::{
                    group_pointer::GroupPointer, BaseStateWithExtensions,
                };
                use spl_token_2022::extension::metadata_pointer::MetadataPointer;
                use crate::{
                    errors::FairLaunchError, Deployment, HashlistMarker,
                    TOKEN2022_DEPLOYMENT_TYPE, HYBRID_DEPLOYMENT_TYPE,
                    mint_token2022_logic, DeploymentConfig,
                };
                pub struct JoinCtx<'info> {
                    #[account(
                        mut,
                        has_one = fungible_mint,
                        seeds = ["deployment".as_ref(),
                        deployment.ticker.as_ref()],
                        bump
                    )]
                    pub deployment: Account<'info, Deployment>,
                    #[account(
                        mut,
                        seeds = ["deployment_config".as_ref(),
                        deployment.key().as_ref()],
                        bump
                    )]
                    pub deployment_config: Account<'info, DeploymentConfig>,
                    /// CHECK: checked in constraint
                    #[account(
                        mut,
                        constraint = deployment_config.creator_fee_treasury = = creator_fee_treasury.key(

                        )
                    )]
                    pub creator_fee_treasury: UncheckedAccount<'info>,
                    /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
                    #[account(
                        mut,
                        seeds = ["hashlist".as_bytes(),
                        deployment.key().as_ref()],
                        bump,
                    )]
                    pub hashlist: UncheckedAccount<'info>,
                    #[account(
                        init,
                        space = 8,
                        payer = payer,
                        seeds = ["hashlist_marker".as_bytes(),
                        deployment.key().as_ref(),
                        non_fungible_mint.key().as_ref()],
                        bump,
                    )]
                    pub hashlist_marker: Account<'info, HashlistMarker>,
                    #[account(mut)]
                    pub payer: Signer<'info>,
                    #[account(mut)]
                    pub signer: Signer<'info>,
                    #[account(mut)]
                    pub fungible_mint: InterfaceAccount<'info, Mint>,
                    /// CHECK: It's a fair launch. Anybody can sign, anybody can receive the inscription
                    #[account(mut)]
                    pub minter: UncheckedAccount<'info>,
                    #[account(mut, owner = spl_token_2022::ID)]
                    pub non_fungible_mint: Signer<'info>,
                    /// CHECK: Will check in instruction
                    #[account(
                        associated_token::mint = non_fungible_mint,
                        associated_token::authority = non_fungible_token_account_owner
                    )]
                    pub non_fungible_token_account: InterfaceAccount<
                        'info,
                        TokenAccount,
                    >,
                    pub non_fungible_token_account_owner: Signer<'info>,
                    /// CHECK: Checked in constraint
                    #[account(constraint = token_program.key()= = token_2022::ID)]
                    pub token_program: UncheckedAccount<'info>,
                    #[account()]
                    pub associated_token_program: Program<'info, AssociatedToken>,
                    #[account()]
                    pub system_program: Program<'info, System>,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::Accounts<'info, JoinCtxBumps> for JoinCtx<'info>
                where
                    'info: 'info,
                {
                    #[inline(never)]
                    fn try_accounts(
                        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >],
                        __ix_data: &[u8],
                        __bumps: &mut JoinCtxBumps,
                        __reallocs: &mut std::collections::BTreeSet<
                            anchor_lang::solana_program::pubkey::Pubkey,
                        >,
                    ) -> anchor_lang::Result<Self> {
                        let deployment: anchor_lang::accounts::account::Account<
                            Deployment,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment"))?;
                        let deployment_config: anchor_lang::accounts::account::Account<
                            DeploymentConfig,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("deployment_config"))?;
                        let creator_fee_treasury: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("creator_fee_treasury"))?;
                        let hashlist: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("hashlist"))?;
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let hashlist_marker = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        let payer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("payer"))?;
                        let signer: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("signer"))?;
                        let fungible_mint: anchor_lang::accounts::interface_account::InterfaceAccount<
                            Mint,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        let minter: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("minter"))?;
                        let non_fungible_mint: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        let non_fungible_token_account: anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_token_account")
                            })?;
                        let non_fungible_token_account_owner: Signer = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("non_fungible_token_account_owner")
                            })?;
                        let token_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("token_program"))?;
                        let associated_token_program: anchor_lang::accounts::program::Program<
                            AssociatedToken,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| {
                                e.with_account_name("associated_token_program")
                            })?;
                        let system_program: anchor_lang::accounts::program::Program<
                            System,
                        > = anchor_lang::Accounts::try_accounts(
                                __program_id,
                                __accounts,
                                __ix_data,
                                __bumps,
                                __reallocs,
                            )
                            .map_err(|e| e.with_account_name("system_program"))?;
                        let __anchor_rent = Rent::get()?;
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &[
                                "hashlist_marker".as_bytes(),
                                deployment.key().as_ref(),
                                non_fungible_mint.key().as_ref(),
                            ],
                            __program_id,
                        );
                        __bumps.hashlist_marker = __bump;
                        if hashlist_marker.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist_marker")
                                    .with_pubkeys((hashlist_marker.key(), __pda_address)),
                            );
                        }
                        let hashlist_marker = {
                            let actual_field = AsRef::<
                                AccountInfo,
                            >::as_ref(&hashlist_marker);
                            let actual_owner = actual_field.owner;
                            let space = 8;
                            let pa: anchor_lang::accounts::account::Account<
                                HashlistMarker,
                            > = if !false
                                || actual_owner
                                    == &anchor_lang::solana_program::system_program::ID
                            {
                                let __current_lamports = hashlist_marker.lamports();
                                if __current_lamports == 0 {
                                    let space = space;
                                    let lamports = __anchor_rent.minimum_balance(space);
                                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                        from: payer.to_account_info(),
                                        to: hashlist_marker.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::create_account(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist_marker".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        non_fungible_mint.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        lamports,
                                        space as u64,
                                        __program_id,
                                    )?;
                                } else {
                                    if payer.key() == hashlist_marker.key() {
                                        return Err(
                                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                    error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .name(),
                                                    error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .into(),
                                                    error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .to_string(),
                                                    error_origin: Some(
                                                        anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                            filename: "programs/libreplex_fair_launch/src/instructions/v2/token_2022/join.rs",
                                                            line: 17u32,
                                                        }),
                                                    ),
                                                    compared_values: None,
                                                })
                                                .with_pubkeys((payer.key(), hashlist_marker.key())),
                                        );
                                    }
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space)
                                        .max(1)
                                        .saturating_sub(__current_lamports);
                                    if required_lamports > 0 {
                                        let cpi_accounts = anchor_lang::system_program::Transfer {
                                            from: payer.to_account_info(),
                                            to: hashlist_marker.to_account_info(),
                                        };
                                        let cpi_context = anchor_lang::context::CpiContext::new(
                                            system_program.to_account_info(),
                                            cpi_accounts,
                                        );
                                        anchor_lang::system_program::transfer(
                                            cpi_context,
                                            required_lamports,
                                        )?;
                                    }
                                    let cpi_accounts = anchor_lang::system_program::Allocate {
                                        account_to_allocate: hashlist_marker.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::allocate(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist_marker".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        non_fungible_mint.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        space as u64,
                                    )?;
                                    let cpi_accounts = anchor_lang::system_program::Assign {
                                        account_to_assign: hashlist_marker.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::assign(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        "hashlist_marker".as_bytes(),
                                                        deployment.key().as_ref(),
                                                        non_fungible_mint.key().as_ref(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        __program_id,
                                    )?;
                                }
                                match anchor_lang::accounts::account::Account::try_from_unchecked(
                                    &hashlist_marker,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist_marker")),
                                }
                            } else {
                                match anchor_lang::accounts::account::Account::try_from(
                                    &hashlist_marker,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("hashlist_marker")),
                                }
                            };
                            if false {
                                if space != actual_field.data_len() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintSpace,
                                            )
                                            .with_account_name("hashlist_marker")
                                            .with_values((space, actual_field.data_len())),
                                    );
                                }
                                if actual_owner != __program_id {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintOwner,
                                            )
                                            .with_account_name("hashlist_marker")
                                            .with_pubkeys((*actual_owner, *__program_id)),
                                    );
                                }
                                {
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space);
                                    if pa.to_account_info().lamports() < required_lamports {
                                        return Err(
                                            anchor_lang::error::Error::from(
                                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                                )
                                                .with_account_name("hashlist_marker"),
                                        );
                                    }
                                }
                            }
                            pa
                        };
                        if !AsRef::<AccountInfo>::as_ref(&hashlist_marker).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("hashlist_marker"),
                            );
                        }
                        if !__anchor_rent
                            .is_exempt(
                                hashlist_marker.to_account_info().lamports(),
                                hashlist_marker.to_account_info().try_data_len()?,
                            )
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                    )
                                    .with_account_name("hashlist_marker"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment".as_ref(), deployment.ticker.as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment = __bump;
                        if deployment.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment")
                                    .with_pubkeys((deployment.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment"),
                            );
                        }
                        {
                            let my_key = deployment.fungible_mint;
                            let target_key = fungible_mint.key();
                            if my_key != target_key {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintHasOne,
                                        )
                                        .with_account_name("deployment")
                                        .with_pubkeys((my_key, target_key)),
                                );
                            }
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["deployment_config".as_ref(), deployment.key().as_ref()],
                            &__program_id,
                        );
                        __bumps.deployment_config = __bump;
                        if deployment_config.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("deployment_config")
                                    .with_pubkeys((deployment_config.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&deployment_config).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("deployment_config"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&creator_fee_treasury)
                            .is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("creator_fee_treasury"),
                            );
                        }
                        if !(deployment_config.creator_fee_treasury
                            == creator_fee_treasury.key())
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("creator_fee_treasury"),
                            );
                        }
                        let (__pda_address, __bump) = Pubkey::find_program_address(
                            &["hashlist".as_bytes(), deployment.key().as_ref()],
                            &__program_id,
                        );
                        __bumps.hashlist = __bump;
                        if hashlist.key() != __pda_address {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                                    )
                                    .with_account_name("hashlist")
                                    .with_pubkeys((hashlist.key(), __pda_address)),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&hashlist).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("hashlist"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("payer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&signer).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("signer"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&fungible_mint).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("fungible_mint"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&minter).is_writable {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("minter"),
                            );
                        }
                        if !AsRef::<AccountInfo>::as_ref(&non_fungible_mint).is_writable
                        {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintMut,
                                    )
                                    .with_account_name("non_fungible_mint"),
                            );
                        }
                        {
                            let my_owner = AsRef::<
                                AccountInfo,
                            >::as_ref(&non_fungible_mint)
                                .owner;
                            let owner_address = spl_token_2022::ID;
                            if my_owner != &owner_address {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintOwner,
                                        )
                                        .with_account_name("non_fungible_mint")
                                        .with_pubkeys((*my_owner, owner_address)),
                                );
                            }
                        }
                        {
                            let my_owner = non_fungible_token_account.owner;
                            let wallet_address = non_fungible_token_account_owner.key();
                            if my_owner != wallet_address {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintTokenOwner,
                                        )
                                        .with_account_name("non_fungible_token_account")
                                        .with_pubkeys((my_owner, wallet_address)),
                                );
                            }
                            let __associated_token_address = ::anchor_spl::associated_token::get_associated_token_address(
                                &wallet_address,
                                &non_fungible_mint.key(),
                            );
                            let my_key = non_fungible_token_account.key();
                            if my_key != __associated_token_address {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintAssociated,
                                        )
                                        .with_account_name("non_fungible_token_account")
                                        .with_pubkeys((my_key, __associated_token_address)),
                                );
                            }
                        }
                        if !(token_program.key() == token_2022::ID) {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintRaw,
                                    )
                                    .with_account_name("token_program"),
                            );
                        }
                        Ok(JoinCtx {
                            deployment,
                            deployment_config,
                            creator_fee_treasury,
                            hashlist,
                            hashlist_marker,
                            payer,
                            signer,
                            fungible_mint,
                            minter,
                            non_fungible_mint,
                            non_fungible_token_account,
                            non_fungible_token_account_owner,
                            token_program,
                            associated_token_program,
                            system_program,
                        })
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info> for JoinCtx<'info>
                where
                    'info: 'info,
                {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos.extend(self.deployment.to_account_infos());
                        account_infos.extend(self.deployment_config.to_account_infos());
                        account_infos
                            .extend(self.creator_fee_treasury.to_account_infos());
                        account_infos.extend(self.hashlist.to_account_infos());
                        account_infos.extend(self.hashlist_marker.to_account_infos());
                        account_infos.extend(self.payer.to_account_infos());
                        account_infos.extend(self.signer.to_account_infos());
                        account_infos.extend(self.fungible_mint.to_account_infos());
                        account_infos.extend(self.minter.to_account_infos());
                        account_infos.extend(self.non_fungible_mint.to_account_infos());
                        account_infos
                            .extend(self.non_fungible_token_account.to_account_infos());
                        account_infos
                            .extend(
                                self.non_fungible_token_account_owner.to_account_infos(),
                            );
                        account_infos.extend(self.token_program.to_account_infos());
                        account_infos
                            .extend(self.associated_token_program.to_account_infos());
                        account_infos.extend(self.system_program.to_account_infos());
                        account_infos
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for JoinCtx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas.extend(self.deployment.to_account_metas(None));
                        account_metas
                            .extend(self.deployment_config.to_account_metas(None));
                        account_metas
                            .extend(self.creator_fee_treasury.to_account_metas(None));
                        account_metas.extend(self.hashlist.to_account_metas(None));
                        account_metas
                            .extend(self.hashlist_marker.to_account_metas(None));
                        account_metas.extend(self.payer.to_account_metas(None));
                        account_metas.extend(self.signer.to_account_metas(None));
                        account_metas.extend(self.fungible_mint.to_account_metas(None));
                        account_metas.extend(self.minter.to_account_metas(None));
                        account_metas
                            .extend(self.non_fungible_mint.to_account_metas(None));
                        account_metas
                            .extend(
                                self.non_fungible_token_account.to_account_metas(None),
                            );
                        account_metas
                            .extend(
                                self.non_fungible_token_account_owner.to_account_metas(None),
                            );
                        account_metas.extend(self.token_program.to_account_metas(None));
                        account_metas
                            .extend(
                                self.associated_token_program.to_account_metas(None),
                            );
                        account_metas.extend(self.system_program.to_account_metas(None));
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::AccountsExit<'info> for JoinCtx<'info>
                where
                    'info: 'info,
                {
                    fn exit(
                        &self,
                        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    ) -> anchor_lang::Result<()> {
                        anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                            .map_err(|e| e.with_account_name("deployment"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.deployment_config,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("deployment_config"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.creator_fee_treasury,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("creator_fee_treasury"))?;
                        anchor_lang::AccountsExit::exit(&self.hashlist, program_id)
                            .map_err(|e| e.with_account_name("hashlist"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.hashlist_marker,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("hashlist_marker"))?;
                        anchor_lang::AccountsExit::exit(&self.payer, program_id)
                            .map_err(|e| e.with_account_name("payer"))?;
                        anchor_lang::AccountsExit::exit(&self.signer, program_id)
                            .map_err(|e| e.with_account_name("signer"))?;
                        anchor_lang::AccountsExit::exit(&self.fungible_mint, program_id)
                            .map_err(|e| e.with_account_name("fungible_mint"))?;
                        anchor_lang::AccountsExit::exit(&self.minter, program_id)
                            .map_err(|e| e.with_account_name("minter"))?;
                        anchor_lang::AccountsExit::exit(
                                &self.non_fungible_mint,
                                program_id,
                            )
                            .map_err(|e| e.with_account_name("non_fungible_mint"))?;
                        Ok(())
                    }
                }
                pub struct JoinCtxBumps {
                    pub deployment: u8,
                    pub deployment_config: u8,
                    pub hashlist: u8,
                    pub hashlist_marker: u8,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for JoinCtxBumps {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "JoinCtxBumps",
                            "deployment",
                            &self.deployment,
                            "deployment_config",
                            &self.deployment_config,
                            "hashlist",
                            &self.hashlist,
                            "hashlist_marker",
                            &&self.hashlist_marker,
                        )
                    }
                }
                impl Default for JoinCtxBumps {
                    fn default() -> Self {
                        JoinCtxBumps {
                            deployment: u8::MAX,
                            deployment_config: u8::MAX,
                            hashlist: u8::MAX,
                            hashlist_marker: u8::MAX,
                        }
                    }
                }
                impl<'info> anchor_lang::Bumps for JoinCtx<'info>
                where
                    'info: 'info,
                {
                    type Bumps = JoinCtxBumps;
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
                /// instead of an `AccountInfo`. This is useful for clients that want
                /// to generate a list of accounts, without explicitly knowing the
                /// order all the fields should be in.
                ///
                /// To access the struct in this module, one should use the sibling
                /// `accounts` module (also generated), which re-exports this.
                pub(crate) mod __client_accounts_join_ctx {
                    use super::*;
                    use anchor_lang::prelude::borsh;
                    /// Generated client accounts for [`JoinCtx`].
                    pub struct JoinCtx {
                        pub deployment: Pubkey,
                        pub deployment_config: Pubkey,
                        pub creator_fee_treasury: Pubkey,
                        pub hashlist: Pubkey,
                        pub hashlist_marker: Pubkey,
                        pub payer: Pubkey,
                        pub signer: Pubkey,
                        pub fungible_mint: Pubkey,
                        pub minter: Pubkey,
                        pub non_fungible_mint: Pubkey,
                        pub non_fungible_token_account: Pubkey,
                        pub non_fungible_token_account_owner: Pubkey,
                        pub token_program: Pubkey,
                        pub associated_token_program: Pubkey,
                        pub system_program: Pubkey,
                    }
                    impl borsh::ser::BorshSerialize for JoinCtx
                    where
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                        Pubkey: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.deployment_config,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.creator_fee_treasury,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.hashlist, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.hashlist_marker,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.payer, writer)?;
                            borsh::BorshSerialize::serialize(&self.signer, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.minter, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_mint,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_token_account,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.non_fungible_token_account_owner,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.associated_token_program,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.system_program,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    #[automatically_derived]
                    impl anchor_lang::ToAccountMetas for JoinCtx {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.deployment_config,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.creator_fee_treasury,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.hashlist,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.hashlist_marker,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.payer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.signer,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.fungible_mint,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.minter,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        self.non_fungible_mint,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.non_fungible_token_account,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.non_fungible_token_account_owner,
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.associated_token_program,
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        self.system_program,
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                }
                /// An internal, Anchor generated module. This is used (as an
                /// implementation detail), to generate a CPI struct for a given
                /// `#[derive(Accounts)]` implementation, where each field is an
                /// AccountInfo.
                ///
                /// To access the struct in this module, one should use the sibling
                /// [`cpi::accounts`] module (also generated), which re-exports this.
                pub(crate) mod __cpi_client_accounts_join_ctx {
                    use super::*;
                    /// Generated CPI struct of the accounts for [`JoinCtx`].
                    pub struct JoinCtx<'info> {
                        pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub deployment_config: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub creator_fee_treasury: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub hashlist_marker: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub signer: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub minter: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_mint: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub non_fungible_token_account_owner: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                        pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                            'info,
                        >,
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountMetas for JoinCtx<'info> {
                        fn to_account_metas(
                            &self,
                            is_signer: Option<bool>,
                        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                            let mut account_metas = ::alloc::vec::Vec::new();
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.deployment_config),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.creator_fee_treasury),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.hashlist),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.hashlist_marker),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.payer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.signer),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.fungible_mint),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.minter),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new(
                                        anchor_lang::Key::key(&self.non_fungible_mint),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.non_fungible_token_account),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(
                                            &self.non_fungible_token_account_owner,
                                        ),
                                        true,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.associated_token_program),
                                        false,
                                    ),
                                );
                            account_metas
                                .push(
                                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                        anchor_lang::Key::key(&self.system_program),
                                        false,
                                    ),
                                );
                            account_metas
                        }
                    }
                    #[automatically_derived]
                    impl<'info> anchor_lang::ToAccountInfos<'info> for JoinCtx<'info> {
                        fn to_account_infos(
                            &self,
                        ) -> Vec<
                            anchor_lang::solana_program::account_info::AccountInfo<'info>,
                        > {
                            let mut account_infos = ::alloc::vec::Vec::new();
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.deployment_config,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.creator_fee_treasury,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.hashlist_marker,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.signer),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(&self.minter),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_mint,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_token_account,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.non_fungible_token_account_owner,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.associated_token_program,
                                    ),
                                );
                            account_infos
                                .extend(
                                    anchor_lang::ToAccountInfos::to_account_infos(
                                        &self.system_program,
                                    ),
                                );
                            account_infos
                        }
                    }
                }
                pub fn join_handler<'info>(
                    ctx: Context<'_, '_, '_, 'info, JoinCtx<'info>>,
                ) -> Result<()> {
                    let deployment = &mut ctx.accounts.deployment;
                    let deployment_config = &mut ctx.accounts.deployment_config;
                    let payer = &ctx.accounts.payer;
                    let signer = &ctx.accounts.signer;
                    let minter = &ctx.accounts.minter;
                    let non_fungible_mint = &ctx.accounts.non_fungible_mint;
                    let non_fungible_token_account = &ctx
                        .accounts
                        .non_fungible_token_account;
                    let token_program = &ctx.accounts.token_program;
                    let associated_token_program = &ctx
                        .accounts
                        .associated_token_program;
                    let system_program = &ctx.accounts.system_program;
                    let fungible_mint = &ctx.accounts.fungible_mint;
                    let creator_fee_treasury = &mut ctx.accounts.creator_fee_treasury;
                    let hashlist = &mut ctx.accounts.hashlist;
                    if !deployment.require_creator_cosign {
                        ::core::panicking::panic("explicit panic")
                    }
                    if non_fungible_token_account.amount != 1 {
                        ::core::panicking::panic("explicit panic")
                    }
                    let non_fungible_mint_data = non_fungible_mint.try_borrow_data()?;
                    let mint_with_extensions = spl_token_2022::extension::StateWithExtensions::<
                        spl_token_2022::state::Mint,
                    >::unpack(&non_fungible_mint_data)?;
                    let mint_base = &mint_with_extensions.base;
                    if mint_base.supply != 1 || mint_base.mint_authority.is_some()
                        || mint_base
                            .freeze_authority
                            .expect("Freeze authority not provided") != deployment.key()
                    {
                        ::core::panicking::panic("explicit panic")
                    }
                    mint_with_extensions.get_extension::<MetadataPointer>()?;
                    let group_member_ptr = mint_with_extensions
                        .get_extension::<GroupMemberPointer>()?;
                    if group_member_ptr.authority
                        != OptionalNonZeroPubkey::try_from(Some(deployment.key()))?
                    {
                        ::core::panicking::panic("explicit panic")
                    }
                    mint_token2022_logic(
                        deployment,
                        deployment_config,
                        creator_fee_treasury,
                        &fungible_mint.to_account_info(),
                        non_fungible_mint,
                        system_program,
                        payer,
                        associated_token_program,
                        token_program,
                        minter,
                        non_fungible_token_account.as_ref(),
                        hashlist,
                        ctx.bumps.deployment,
                        ctx.remaining_accounts,
                        &signer,
                        false,
                    )?;
                    Ok(())
                }
            }
            pub use join::*;
        }
        pub use token_2022::*;
        pub mod relinquish_cosigner {
            use anchor_lang::prelude::*;
            use crate::Deployment;
            pub struct RelinquishCosignersCtx<'info> {
                #[account(mut)]
                pub deployment: Account<'info, Deployment>,
                #[account(mut)]
                pub payer: Signer<'info>,
                #[account(
                    mut,
                    constraint = cosigner.key()= = deployment.creator,
                    constraint = deployment.require_creator_cosign
                )]
                pub cosigner: Signer<'info>,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::Accounts<'info, RelinquishCosignersCtxBumps>
            for RelinquishCosignersCtx<'info>
            where
                'info: 'info,
            {
                #[inline(never)]
                fn try_accounts(
                    __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    __ix_data: &[u8],
                    __bumps: &mut RelinquishCosignersCtxBumps,
                    __reallocs: &mut std::collections::BTreeSet<
                        anchor_lang::solana_program::pubkey::Pubkey,
                    >,
                ) -> anchor_lang::Result<Self> {
                    let deployment: anchor_lang::accounts::account::Account<
                        Deployment,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("deployment"))?;
                    let payer: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("payer"))?;
                    let cosigner: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("cosigner"))?;
                    if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("deployment"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("payer"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(&cosigner).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("cosigner"),
                        );
                    }
                    if !(cosigner.key() == deployment.creator) {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRaw,
                                )
                                .with_account_name("cosigner"),
                        );
                    }
                    if !(deployment.require_creator_cosign) {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRaw,
                                )
                                .with_account_name("cosigner"),
                        );
                    }
                    Ok(RelinquishCosignersCtx {
                        deployment,
                        payer,
                        cosigner,
                    })
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info>
            for RelinquishCosignersCtx<'info>
            where
                'info: 'info,
            {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos.extend(self.deployment.to_account_infos());
                    account_infos.extend(self.payer.to_account_infos());
                    account_infos.extend(self.cosigner.to_account_infos());
                    account_infos
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for RelinquishCosignersCtx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas.extend(self.deployment.to_account_metas(None));
                    account_metas.extend(self.payer.to_account_metas(None));
                    account_metas.extend(self.cosigner.to_account_metas(None));
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsExit<'info>
            for RelinquishCosignersCtx<'info>
            where
                'info: 'info,
            {
                fn exit(
                    &self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                        .map_err(|e| e.with_account_name("deployment"))?;
                    anchor_lang::AccountsExit::exit(&self.payer, program_id)
                        .map_err(|e| e.with_account_name("payer"))?;
                    anchor_lang::AccountsExit::exit(&self.cosigner, program_id)
                        .map_err(|e| e.with_account_name("cosigner"))?;
                    Ok(())
                }
            }
            pub struct RelinquishCosignersCtxBumps {}
            #[automatically_derived]
            impl ::core::fmt::Debug for RelinquishCosignersCtxBumps {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "RelinquishCosignersCtxBumps")
                }
            }
            impl Default for RelinquishCosignersCtxBumps {
                fn default() -> Self {
                    RelinquishCosignersCtxBumps {}
                }
            }
            impl<'info> anchor_lang::Bumps for RelinquishCosignersCtx<'info>
            where
                'info: 'info,
            {
                type Bumps = RelinquishCosignersCtxBumps;
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
            /// instead of an `AccountInfo`. This is useful for clients that want
            /// to generate a list of accounts, without explicitly knowing the
            /// order all the fields should be in.
            ///
            /// To access the struct in this module, one should use the sibling
            /// `accounts` module (also generated), which re-exports this.
            pub(crate) mod __client_accounts_relinquish_cosigners_ctx {
                use super::*;
                use anchor_lang::prelude::borsh;
                /// Generated client accounts for [`RelinquishCosignersCtx`].
                pub struct RelinquishCosignersCtx {
                    pub deployment: Pubkey,
                    pub payer: Pubkey,
                    pub cosigner: Pubkey,
                }
                impl borsh::ser::BorshSerialize for RelinquishCosignersCtx
                where
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                        borsh::BorshSerialize::serialize(&self.payer, writer)?;
                        borsh::BorshSerialize::serialize(&self.cosigner, writer)?;
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl anchor_lang::ToAccountMetas for RelinquishCosignersCtx {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.deployment,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.payer,
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.cosigner,
                                    true,
                                ),
                            );
                        account_metas
                    }
                }
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a CPI struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is an
            /// AccountInfo.
            ///
            /// To access the struct in this module, one should use the sibling
            /// [`cpi::accounts`] module (also generated), which re-exports this.
            pub(crate) mod __cpi_client_accounts_relinquish_cosigners_ctx {
                use super::*;
                /// Generated CPI struct of the accounts for [`RelinquishCosignersCtx`].
                pub struct RelinquishCosignersCtx<'info> {
                    pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub cosigner: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas
                for RelinquishCosignersCtx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.deployment),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.payer),
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.cosigner),
                                    true,
                                ),
                            );
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for RelinquishCosignersCtx<'info> {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.deployment,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.cosigner,
                                ),
                            );
                        account_infos
                    }
                }
            }
            pub fn relinquish_cosigner(
                ctx: Context<RelinquishCosignersCtx>,
            ) -> Result<()> {
                let deployment: &mut Account<'_, Deployment> = &mut ctx
                    .accounts
                    .deployment;
                deployment.require_creator_cosign = false;
                Ok(())
            }
        }
        pub use relinquish_cosigner::*;
        pub use initialise::*;
        pub mod initialise {
            use anchor_lang::{prelude::*, system_program};
            use crate::{
                Deployment, initialise_logic, InitialiseInput, TOKEN2022_DEPLOYMENT_TYPE,
                DeploymentConfig, HYBRID_DEPLOYMENT_TYPE,
            };
            pub struct InitialiseInputV2 {
                pub limit_per_mint: u64,
                pub max_number_of_tokens: u64,
                pub decimals: u8,
                pub ticker: String,
                pub deployment_template: String,
                pub mint_template: String,
                pub offchain_url: String,
                pub creator_cosign_program_id: Option<Pubkey>,
                pub use_inscriptions: bool,
                pub deployment_type: u8,
                pub creator_fee_treasury: Pubkey,
                pub creator_fee_per_mint_in_lamports: u64,
                pub deflation_rate_per_swap: u16,
            }
            impl borsh::de::BorshDeserialize for InitialiseInputV2
            where
                u64: borsh::BorshDeserialize,
                u64: borsh::BorshDeserialize,
                u8: borsh::BorshDeserialize,
                String: borsh::BorshDeserialize,
                String: borsh::BorshDeserialize,
                String: borsh::BorshDeserialize,
                String: borsh::BorshDeserialize,
                Option<Pubkey>: borsh::BorshDeserialize,
                bool: borsh::BorshDeserialize,
                u8: borsh::BorshDeserialize,
                Pubkey: borsh::BorshDeserialize,
                u64: borsh::BorshDeserialize,
                u16: borsh::BorshDeserialize,
            {
                fn deserialize_reader<R: borsh::maybestd::io::Read>(
                    reader: &mut R,
                ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                    Ok(Self {
                        limit_per_mint: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        max_number_of_tokens: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        decimals: borsh::BorshDeserialize::deserialize_reader(reader)?,
                        ticker: borsh::BorshDeserialize::deserialize_reader(reader)?,
                        deployment_template: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        mint_template: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        offchain_url: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        creator_cosign_program_id: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        use_inscriptions: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        deployment_type: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        creator_fee_treasury: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        creator_fee_per_mint_in_lamports: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                        deflation_rate_per_swap: borsh::BorshDeserialize::deserialize_reader(
                            reader,
                        )?,
                    })
                }
            }
            impl borsh::ser::BorshSerialize for InitialiseInputV2
            where
                u64: borsh::ser::BorshSerialize,
                u64: borsh::ser::BorshSerialize,
                u8: borsh::ser::BorshSerialize,
                String: borsh::ser::BorshSerialize,
                String: borsh::ser::BorshSerialize,
                String: borsh::ser::BorshSerialize,
                String: borsh::ser::BorshSerialize,
                Option<Pubkey>: borsh::ser::BorshSerialize,
                bool: borsh::ser::BorshSerialize,
                u8: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                u64: borsh::ser::BorshSerialize,
                u16: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.limit_per_mint, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.max_number_of_tokens,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.decimals, writer)?;
                    borsh::BorshSerialize::serialize(&self.ticker, writer)?;
                    borsh::BorshSerialize::serialize(&self.deployment_template, writer)?;
                    borsh::BorshSerialize::serialize(&self.mint_template, writer)?;
                    borsh::BorshSerialize::serialize(&self.offchain_url, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.creator_cosign_program_id,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.use_inscriptions, writer)?;
                    borsh::BorshSerialize::serialize(&self.deployment_type, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.creator_fee_treasury,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.creator_fee_per_mint_in_lamports,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.deflation_rate_per_swap,
                        writer,
                    )?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for InitialiseInputV2 {
                #[inline]
                fn clone(&self) -> InitialiseInputV2 {
                    InitialiseInputV2 {
                        limit_per_mint: ::core::clone::Clone::clone(
                            &self.limit_per_mint,
                        ),
                        max_number_of_tokens: ::core::clone::Clone::clone(
                            &self.max_number_of_tokens,
                        ),
                        decimals: ::core::clone::Clone::clone(&self.decimals),
                        ticker: ::core::clone::Clone::clone(&self.ticker),
                        deployment_template: ::core::clone::Clone::clone(
                            &self.deployment_template,
                        ),
                        mint_template: ::core::clone::Clone::clone(&self.mint_template),
                        offchain_url: ::core::clone::Clone::clone(&self.offchain_url),
                        creator_cosign_program_id: ::core::clone::Clone::clone(
                            &self.creator_cosign_program_id,
                        ),
                        use_inscriptions: ::core::clone::Clone::clone(
                            &self.use_inscriptions,
                        ),
                        deployment_type: ::core::clone::Clone::clone(
                            &self.deployment_type,
                        ),
                        creator_fee_treasury: ::core::clone::Clone::clone(
                            &self.creator_fee_treasury,
                        ),
                        creator_fee_per_mint_in_lamports: ::core::clone::Clone::clone(
                            &self.creator_fee_per_mint_in_lamports,
                        ),
                        deflation_rate_per_swap: ::core::clone::Clone::clone(
                            &self.deflation_rate_per_swap,
                        ),
                    }
                }
            }
            #[instruction(input:InitialiseInputV2)]
            pub struct InitialiseV2Ctx<'info> {
                #[account(
                    init,
                    payer = payer,
                    space = 8+Deployment::INIT_SPACE,
                    seeds = ["deployment".as_ref(),
                    input.ticker.as_ref()],
                    bump
                )]
                pub deployment: Account<'info, Deployment>,
                #[account(
                    init,
                    payer = payer,
                    space = DeploymentConfig::SIZE,
                    seeds = ["deployment_config".as_bytes(),
                    deployment.key().as_ref()],
                    bump
                )]
                pub deployment_config: Account<'info, DeploymentConfig>,
                #[account(mut)]
                pub payer: Signer<'info>,
                /// CHECK: Can be anyone.
                pub creator: UncheckedAccount<'info>,
                #[account()]
                pub system_program: Program<'info, System>,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::Accounts<'info, InitialiseV2CtxBumps>
            for InitialiseV2Ctx<'info>
            where
                'info: 'info,
            {
                #[inline(never)]
                fn try_accounts(
                    __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    __ix_data: &[u8],
                    __bumps: &mut InitialiseV2CtxBumps,
                    __reallocs: &mut std::collections::BTreeSet<
                        anchor_lang::solana_program::pubkey::Pubkey,
                    >,
                ) -> anchor_lang::Result<Self> {
                    let mut __ix_data = __ix_data;
                    struct __Args {
                        input: InitialiseInputV2,
                    }
                    impl borsh::ser::BorshSerialize for __Args
                    where
                        InitialiseInputV2: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.input, writer)?;
                            Ok(())
                        }
                    }
                    impl borsh::de::BorshDeserialize for __Args
                    where
                        InitialiseInputV2: borsh::BorshDeserialize,
                    {
                        fn deserialize_reader<R: borsh::maybestd::io::Read>(
                            reader: &mut R,
                        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                            Ok(Self {
                                input: borsh::BorshDeserialize::deserialize_reader(reader)?,
                            })
                        }
                    }
                    let __Args { input } = __Args::deserialize(&mut __ix_data)
                        .map_err(|_| {
                            anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                        })?;
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let deployment = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let deployment_config = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    let payer: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("payer"))?;
                    let creator: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("creator"))?;
                    let system_program: anchor_lang::accounts::program::Program<
                        System,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("system_program"))?;
                    let __anchor_rent = Rent::get()?;
                    let (__pda_address, __bump) = Pubkey::find_program_address(
                        &["deployment".as_ref(), input.ticker.as_ref()],
                        __program_id,
                    );
                    __bumps.deployment = __bump;
                    if deployment.key() != __pda_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintSeeds,
                                )
                                .with_account_name("deployment")
                                .with_pubkeys((deployment.key(), __pda_address)),
                        );
                    }
                    let deployment = {
                        let actual_field = AsRef::<AccountInfo>::as_ref(&deployment);
                        let actual_owner = actual_field.owner;
                        let space = 8 + Deployment::INIT_SPACE;
                        let pa: anchor_lang::accounts::account::Account<Deployment> = if !false
                            || actual_owner
                                == &anchor_lang::solana_program::system_program::ID
                        {
                            let __current_lamports = deployment.lamports();
                            if __current_lamports == 0 {
                                let space = space;
                                let lamports = __anchor_rent.minimum_balance(space);
                                let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                    from: payer.to_account_info(),
                                    to: deployment.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::create_account(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    "deployment".as_ref(),
                                                    input.ticker.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    lamports,
                                    space as u64,
                                    __program_id,
                                )?;
                            } else {
                                if payer.key() == deployment.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .name(),
                                                error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .into(),
                                                error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .to_string(),
                                                error_origin: Some(
                                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                        filename: "programs/libreplex_fair_launch/src/instructions/v2/initialise.rs",
                                                        line: 42u32,
                                                    }),
                                                ),
                                                compared_values: None,
                                            })
                                            .with_pubkeys((payer.key(), deployment.key())),
                                    );
                                }
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space)
                                    .max(1)
                                    .saturating_sub(__current_lamports);
                                if required_lamports > 0 {
                                    let cpi_accounts = anchor_lang::system_program::Transfer {
                                        from: payer.to_account_info(),
                                        to: deployment.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::transfer(
                                        cpi_context,
                                        required_lamports,
                                    )?;
                                }
                                let cpi_accounts = anchor_lang::system_program::Allocate {
                                    account_to_allocate: deployment.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::allocate(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    "deployment".as_ref(),
                                                    input.ticker.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    space as u64,
                                )?;
                                let cpi_accounts = anchor_lang::system_program::Assign {
                                    account_to_assign: deployment.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::assign(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    "deployment".as_ref(),
                                                    input.ticker.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    __program_id,
                                )?;
                            }
                            match anchor_lang::accounts::account::Account::try_from_unchecked(
                                &deployment,
                            ) {
                                Ok(val) => val,
                                Err(e) => return Err(e.with_account_name("deployment")),
                            }
                        } else {
                            match anchor_lang::accounts::account::Account::try_from(
                                &deployment,
                            ) {
                                Ok(val) => val,
                                Err(e) => return Err(e.with_account_name("deployment")),
                            }
                        };
                        if false {
                            if space != actual_field.data_len() {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintSpace,
                                        )
                                        .with_account_name("deployment")
                                        .with_values((space, actual_field.data_len())),
                                );
                            }
                            if actual_owner != __program_id {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintOwner,
                                        )
                                        .with_account_name("deployment")
                                        .with_pubkeys((*actual_owner, *__program_id)),
                                );
                            }
                            {
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space);
                                if pa.to_account_info().lamports() < required_lamports {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                            )
                                            .with_account_name("deployment"),
                                    );
                                }
                            }
                        }
                        pa
                    };
                    if !AsRef::<AccountInfo>::as_ref(&deployment).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("deployment"),
                        );
                    }
                    if !__anchor_rent
                        .is_exempt(
                            deployment.to_account_info().lamports(),
                            deployment.to_account_info().try_data_len()?,
                        )
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                )
                                .with_account_name("deployment"),
                        );
                    }
                    let __anchor_rent = Rent::get()?;
                    let (__pda_address, __bump) = Pubkey::find_program_address(
                        &["deployment_config".as_bytes(), deployment.key().as_ref()],
                        __program_id,
                    );
                    __bumps.deployment_config = __bump;
                    if deployment_config.key() != __pda_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintSeeds,
                                )
                                .with_account_name("deployment_config")
                                .with_pubkeys((deployment_config.key(), __pda_address)),
                        );
                    }
                    let deployment_config = {
                        let actual_field = AsRef::<
                            AccountInfo,
                        >::as_ref(&deployment_config);
                        let actual_owner = actual_field.owner;
                        let space = DeploymentConfig::SIZE;
                        let pa: anchor_lang::accounts::account::Account<
                            DeploymentConfig,
                        > = if !false
                            || actual_owner
                                == &anchor_lang::solana_program::system_program::ID
                        {
                            let __current_lamports = deployment_config.lamports();
                            if __current_lamports == 0 {
                                let space = space;
                                let lamports = __anchor_rent.minimum_balance(space);
                                let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                    from: payer.to_account_info(),
                                    to: deployment_config.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::create_account(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    "deployment_config".as_bytes(),
                                                    deployment.key().as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    lamports,
                                    space as u64,
                                    __program_id,
                                )?;
                            } else {
                                if payer.key() == deployment_config.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .name(),
                                                error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .into(),
                                                error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .to_string(),
                                                error_origin: Some(
                                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                        filename: "programs/libreplex_fair_launch/src/instructions/v2/initialise.rs",
                                                        line: 42u32,
                                                    }),
                                                ),
                                                compared_values: None,
                                            })
                                            .with_pubkeys((payer.key(), deployment_config.key())),
                                    );
                                }
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space)
                                    .max(1)
                                    .saturating_sub(__current_lamports);
                                if required_lamports > 0 {
                                    let cpi_accounts = anchor_lang::system_program::Transfer {
                                        from: payer.to_account_info(),
                                        to: deployment_config.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::transfer(
                                        cpi_context,
                                        required_lamports,
                                    )?;
                                }
                                let cpi_accounts = anchor_lang::system_program::Allocate {
                                    account_to_allocate: deployment_config.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::allocate(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    "deployment_config".as_bytes(),
                                                    deployment.key().as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    space as u64,
                                )?;
                                let cpi_accounts = anchor_lang::system_program::Assign {
                                    account_to_assign: deployment_config.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::assign(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    "deployment_config".as_bytes(),
                                                    deployment.key().as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    __program_id,
                                )?;
                            }
                            match anchor_lang::accounts::account::Account::try_from_unchecked(
                                &deployment_config,
                            ) {
                                Ok(val) => val,
                                Err(e) => {
                                    return Err(e.with_account_name("deployment_config"));
                                }
                            }
                        } else {
                            match anchor_lang::accounts::account::Account::try_from(
                                &deployment_config,
                            ) {
                                Ok(val) => val,
                                Err(e) => {
                                    return Err(e.with_account_name("deployment_config"));
                                }
                            }
                        };
                        if false {
                            if space != actual_field.data_len() {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintSpace,
                                        )
                                        .with_account_name("deployment_config")
                                        .with_values((space, actual_field.data_len())),
                                );
                            }
                            if actual_owner != __program_id {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintOwner,
                                        )
                                        .with_account_name("deployment_config")
                                        .with_pubkeys((*actual_owner, *__program_id)),
                                );
                            }
                            {
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space);
                                if pa.to_account_info().lamports() < required_lamports {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                            )
                                            .with_account_name("deployment_config"),
                                    );
                                }
                            }
                        }
                        pa
                    };
                    if !AsRef::<AccountInfo>::as_ref(&deployment_config).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("deployment_config"),
                        );
                    }
                    if !__anchor_rent
                        .is_exempt(
                            deployment_config.to_account_info().lamports(),
                            deployment_config.to_account_info().try_data_len()?,
                        )
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                )
                                .with_account_name("deployment_config"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("payer"),
                        );
                    }
                    Ok(InitialiseV2Ctx {
                        deployment,
                        deployment_config,
                        payer,
                        creator,
                        system_program,
                    })
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for InitialiseV2Ctx<'info>
            where
                'info: 'info,
            {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos.extend(self.deployment.to_account_infos());
                    account_infos.extend(self.deployment_config.to_account_infos());
                    account_infos.extend(self.payer.to_account_infos());
                    account_infos.extend(self.creator.to_account_infos());
                    account_infos.extend(self.system_program.to_account_infos());
                    account_infos
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for InitialiseV2Ctx<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas.extend(self.deployment.to_account_metas(None));
                    account_metas.extend(self.deployment_config.to_account_metas(None));
                    account_metas.extend(self.payer.to_account_metas(None));
                    account_metas.extend(self.creator.to_account_metas(None));
                    account_metas.extend(self.system_program.to_account_metas(None));
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsExit<'info> for InitialiseV2Ctx<'info>
            where
                'info: 'info,
            {
                fn exit(
                    &self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsExit::exit(&self.deployment, program_id)
                        .map_err(|e| e.with_account_name("deployment"))?;
                    anchor_lang::AccountsExit::exit(&self.deployment_config, program_id)
                        .map_err(|e| e.with_account_name("deployment_config"))?;
                    anchor_lang::AccountsExit::exit(&self.payer, program_id)
                        .map_err(|e| e.with_account_name("payer"))?;
                    Ok(())
                }
            }
            pub struct InitialiseV2CtxBumps {
                pub deployment: u8,
                pub deployment_config: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for InitialiseV2CtxBumps {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "InitialiseV2CtxBumps",
                        "deployment",
                        &self.deployment,
                        "deployment_config",
                        &&self.deployment_config,
                    )
                }
            }
            impl Default for InitialiseV2CtxBumps {
                fn default() -> Self {
                    InitialiseV2CtxBumps {
                        deployment: u8::MAX,
                        deployment_config: u8::MAX,
                    }
                }
            }
            impl<'info> anchor_lang::Bumps for InitialiseV2Ctx<'info>
            where
                'info: 'info,
            {
                type Bumps = InitialiseV2CtxBumps;
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
            /// instead of an `AccountInfo`. This is useful for clients that want
            /// to generate a list of accounts, without explicitly knowing the
            /// order all the fields should be in.
            ///
            /// To access the struct in this module, one should use the sibling
            /// `accounts` module (also generated), which re-exports this.
            pub(crate) mod __client_accounts_initialise_v2_ctx {
                use super::*;
                use anchor_lang::prelude::borsh;
                /// Generated client accounts for [`InitialiseV2Ctx`].
                pub struct InitialiseV2Ctx {
                    pub deployment: Pubkey,
                    pub deployment_config: Pubkey,
                    pub payer: Pubkey,
                    pub creator: Pubkey,
                    pub system_program: Pubkey,
                }
                impl borsh::ser::BorshSerialize for InitialiseV2Ctx
                where
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.deployment, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.deployment_config,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(&self.payer, writer)?;
                        borsh::BorshSerialize::serialize(&self.creator, writer)?;
                        borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl anchor_lang::ToAccountMetas for InitialiseV2Ctx {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.deployment,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.deployment_config,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.payer,
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.creator,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.system_program,
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a CPI struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is an
            /// AccountInfo.
            ///
            /// To access the struct in this module, one should use the sibling
            /// [`cpi::accounts`] module (also generated), which re-exports this.
            pub(crate) mod __cpi_client_accounts_initialise_v2_ctx {
                use super::*;
                /// Generated CPI struct of the accounts for [`InitialiseV2Ctx`].
                pub struct InitialiseV2Ctx<'info> {
                    pub deployment: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub deployment_config: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub payer: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub creator: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for InitialiseV2Ctx<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.deployment),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.deployment_config),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.payer),
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.creator),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.system_program),
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for InitialiseV2Ctx<'info> {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.deployment,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.deployment_config,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(&self.creator),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.system_program,
                                ),
                            );
                        account_infos
                    }
                }
            }
            pub fn initialise_v2(
                ctx: Context<InitialiseV2Ctx>,
                input: InitialiseInputV2,
            ) -> Result<()> {
                let deployment: &mut Account<'_, Deployment> = &mut ctx
                    .accounts
                    .deployment;
                let deployment_config = &mut ctx.accounts.deployment_config;
                let creator = &ctx.accounts.creator;
                let InitialiseInputV2 {
                    limit_per_mint,
                    max_number_of_tokens,
                    decimals,
                    ticker,
                    deployment_template,
                    mint_template,
                    offchain_url,
                    use_inscriptions,
                    deployment_type,
                    creator_cosign_program_id,
                    creator_fee_per_mint_in_lamports: creator_fee_in_lamports,
                    creator_fee_treasury,
                    deflation_rate_per_swap,
                } = input;
                if deployment_type != TOKEN2022_DEPLOYMENT_TYPE
                    && deployment_type != HYBRID_DEPLOYMENT_TYPE
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Bad deployment type"),
                        );
                    }
                }
                if deployment_type == HYBRID_DEPLOYMENT_TYPE
                    && deflation_rate_per_swap > 0
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Non-zero deflation rate requires a token-2022 deployment",
                            ),
                        );
                    }
                }
                deployment_config.creator_fee_treasury = creator_fee_treasury;
                deployment_config
                    .creator_fee_per_mint_lamports = creator_fee_in_lamports;
                deployment_config.deflation_rate_per_swap = deflation_rate_per_swap;
                initialise_logic(
                    InitialiseInput {
                        limit_per_mint,
                        max_number_of_tokens,
                        decimals,
                        ticker,
                        deployment_template,
                        mint_template,
                        offchain_url,
                        deployment_type,
                    },
                    deployment,
                    creator.key(),
                    Some(&deployment_config),
                )?;
                deployment.require_creator_cosign = creator_cosign_program_id.is_some();
                deployment_config
                    .cosigner_program_id = match creator_cosign_program_id {
                    Some(x) => x,
                    _ => system_program::ID,
                };
                deployment.use_inscriptions = use_inscriptions;
                Ok(())
            }
        }
        pub use shared_logic::*;
        pub mod shared_logic {
            pub mod inscriptions {
                pub mod create_fair_launch_inscriptions {
                    use anchor_lang::prelude::*;
                    use libreplex_inscriptions::{
                        cpi::accounts::CreateInscriptionV3, instructions::SignerType,
                    };
                    use crate::{Deployment, create_immutable_inscription};
                    pub fn create_fair_launch_inscriptions<'a>(
                        inscriptions_program: &AccountInfo<'a>,
                        inscription_summary: &AccountInfo<'a>,
                        non_fungible_mint: &Signer<'a>,
                        inscription_v3: &AccountInfo<'a>,
                        system_program: &Program<'a, System>,
                        payer: &Signer<'a>,
                        inscription_data: &AccountInfo<'a>,
                        deployment: &mut Account<'a, Deployment>,
                    ) -> Result<()> {
                        libreplex_inscriptions::cpi::create_inscription_v3(
                            CpiContext::new(
                                inscriptions_program.to_account_info(),
                                CreateInscriptionV3 {
                                    inscription_summary: inscription_summary.to_account_info(),
                                    root: non_fungible_mint.to_account_info(),
                                    signer: non_fungible_mint.to_account_info(),
                                    inscription_v3: inscription_v3.to_account_info(),
                                    system_program: system_program.to_account_info(),
                                    payer: payer.to_account_info(),
                                    inscription_data: inscription_data.to_account_info(),
                                },
                            ),
                            libreplex_inscriptions::instructions::CreateInscriptionInputV3 {
                                authority: Some(payer.key()),
                                signer_type: SignerType::Root,
                                validation_hash: None,
                            },
                        )?;
                        create_immutable_inscription(
                            deployment,
                            inscriptions_program,
                            payer,
                            system_program,
                            inscription_data,
                            inscription_v3,
                            inscription_summary,
                        )?;
                        Ok(())
                    }
                }
                pub use create_fair_launch_inscriptions::*;
                pub mod create_immutable_inscription {
                    use anchor_lang::prelude::*;
                    use libreplex_inscriptions::{
                        cpi::accounts::MakeInscriptionImmutableV3,
                        cpi::accounts::ResizeInscriptionV3,
                        cpi::accounts::WriteToInscriptionV3,
                        instructions::WriteToInscriptionInput,
                    };
                    use crate::Deployment;
                    pub fn create_immutable_inscription<'a>(
                        deployment: &mut Account<'a, Deployment>,
                        inscriptions_program: &AccountInfo<'a>,
                        payer: &Signer<'a>,
                        system_program: &Program<'a, System>,
                        inscription_data: &AccountInfo<'a>,
                        inscription_v3: &AccountInfo<'a>,
                        inscription_summary: &AccountInfo<'a>,
                    ) -> Result<()> {
                        let data_bytes = deployment.mint_template.clone().into_bytes();
                        libreplex_inscriptions::cpi::resize_inscription_v3(
                            CpiContext::new(
                                inscriptions_program.to_account_info(),
                                ResizeInscriptionV3 {
                                    authority: payer.to_account_info(),
                                    system_program: system_program.to_account_info(),
                                    payer: payer.to_account_info(),
                                    inscription_data: inscription_data.to_account_info(),
                                    inscription_v3: inscription_v3.to_account_info(),
                                },
                            ),
                            libreplex_inscriptions::instructions::ResizeInscriptionInput {
                                change: data_bytes.len() as i32 - 8,
                                expected_start_size: 8,
                                target_size: data_bytes.len() as u32,
                            },
                        )?;
                        libreplex_inscriptions::cpi::write_to_inscription_v3(
                            CpiContext::new(
                                inscriptions_program.to_account_info(),
                                WriteToInscriptionV3 {
                                    authority: payer.to_account_info(),
                                    payer: payer.to_account_info(),
                                    inscription_v3: inscription_v3.to_account_info(),
                                    system_program: system_program.to_account_info(),
                                    inscription_data: inscription_data.to_account_info(),
                                },
                            ),
                            WriteToInscriptionInput {
                                data: data_bytes,
                                start_pos: 0,
                                media_type: Some("text/plain".to_owned()),
                                encoding_type: Some("ascii".to_owned()),
                            },
                        )?;
                        libreplex_inscriptions::cpi::make_inscription_immutable_v3(
                            CpiContext::new(
                                inscriptions_program.to_account_info(),
                                MakeInscriptionImmutableV3 {
                                    payer: payer.to_account_info(),
                                    authority: payer.to_account_info(),
                                    inscription_summary: inscription_summary.to_account_info(),
                                    inscription_v3: inscription_v3.to_account_info(),
                                    system_program: system_program.to_account_info(),
                                },
                            ),
                        )?;
                        Ok(())
                    }
                }
                pub use create_immutable_inscription::*;
            }
            pub use inscriptions::*;
            pub mod deploy {
                pub mod deploy_hybrid_logic {
                    use anchor_lang::prelude::*;
                    use anchor_spl::associated_token::AssociatedToken;
                    use libreplex_shared::CreateMetadataAccounts;
                    use libreplex_shared::create_legacy_metadata;
                    use mpl_token_metadata::types::Creator;
                    use crate::DeploymentActive;
                    use crate::{
                        mint_all_fungibles, revoke_mint_auths, Deployment, Hashlist,
                        HYBRID_DEPLOYMENT_TYPE,
                    };
                    pub mod sysvar_instructions_program {
                        use anchor_lang::declare_id;
                        /// The static program ID
                        pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                            6u8,
                            167u8,
                            213u8,
                            23u8,
                            24u8,
                            123u8,
                            209u8,
                            102u8,
                            53u8,
                            218u8,
                            212u8,
                            4u8,
                            85u8,
                            253u8,
                            194u8,
                            192u8,
                            193u8,
                            36u8,
                            198u8,
                            143u8,
                            33u8,
                            86u8,
                            117u8,
                            165u8,
                            219u8,
                            186u8,
                            203u8,
                            95u8,
                            8u8,
                            0u8,
                            0u8,
                            0u8,
                        ]);
                        /// Confirms that a given pubkey is equivalent to the program ID
                        pub fn check_id(
                            id: &anchor_lang::solana_program::pubkey::Pubkey,
                        ) -> bool {
                            id == &ID
                        }
                        /// Returns the program ID
                        pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                            ID
                        }
                    }
                    pub fn deploy_hybrid_logic<'f>(
                        hashlist: &mut Account<'f, Hashlist>,
                        deployment: &mut Account<'f, Deployment>,
                        fungible_mint: &AccountInfo<'f>,
                        fungible_metadata: &UncheckedAccount<'f>,
                        fungible_master_edition: &UncheckedAccount<'f>,
                        payer: &Signer<'f>,
                        fungible_escrow_token_account: &AccountInfo<'f>,
                        token_program: &UncheckedAccount<'f>,
                        associated_token_program: &Program<'f, AssociatedToken>,
                        system_program: &Program<'f, System>,
                        rent: &Sysvar<'f, Rent>,
                        sysvar_instructions_info: &UncheckedAccount<'f>,
                        metadata_program: &UncheckedAccount<'f>,
                        deployment_bump: u8,
                    ) -> Result<()> {
                        hashlist.deployment = deployment.key();
                        ::solana_program::log::sol_log(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Set fungible mint to {0}",
                                        fungible_mint.key(),
                                    ),
                                );
                                res
                            },
                        );
                        deployment.fungible_mint = fungible_mint.key();
                        let deployment_seeds: &[&[u8]] = &[
                            "deployment".as_bytes(),
                            deployment.ticker.as_ref(),
                            &[deployment_bump],
                        ];
                        mint_all_fungibles(
                            deployment,
                            &fungible_mint.to_account_info(),
                            fungible_escrow_token_account,
                            associated_token_program,
                            payer,
                            system_program,
                            token_program,
                            deployment_seeds,
                            false,
                        )?;
                        if deployment.deployment_type == HYBRID_DEPLOYMENT_TYPE {
                            create_legacy_metadata(
                                CreateMetadataAccounts {
                                    authority_pda: deployment.to_account_info(),
                                    payer: payer.to_account_info(),
                                    nft_mint: fungible_mint.to_account_info(),
                                    nft_mint_authority: deployment.to_account_info(),
                                    nft_metadata: fungible_metadata.to_account_info(),
                                    nft_master_edition: fungible_master_edition
                                        .to_account_info(),
                                    system_program: system_program.to_account_info(),
                                    rent: rent.to_account_info(),
                                    sysvar_instructions_info: sysvar_instructions_info
                                        .to_account_info(),
                                    metadata_program: metadata_program.to_account_info(),
                                    token_program: token_program.to_account_info(),
                                },
                                deployment_seeds,
                                deployment.ticker.clone(),
                                deployment
                                    .ticker[..std::cmp::min(10, deployment.ticker.len())]
                                    .to_string(),
                                0,
                                deployment.offchain_url.clone(),
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        Creator {
                                            address: payer.key(),
                                            verified: false,
                                            share: 100,
                                        },
                                    ]),
                                ),
                                false,
                            )?
                        }
                        revoke_mint_auths(
                            deployment,
                            token_program,
                            fungible_mint,
                            deployment_seeds,
                        )?;
                        {
                            anchor_lang::solana_program::log::sol_log_data(
                                &[
                                    &anchor_lang::Event::data(
                                        &DeploymentActive {
                                            ticker: deployment.ticker.clone(),
                                            fungible_mint: fungible_mint.key(),
                                        },
                                    ),
                                ],
                            );
                        };
                        Ok(())
                    }
                }
                pub use deploy_hybrid_logic::*;
                pub mod deploy_token_2022_logic {
                    use anchor_lang::prelude::*;
                    use anchor_spl::associated_token::AssociatedToken;
                    use libreplex_shared::{
                        create_token_2022_and_metadata, MintAccounts2022, TokenGroupInput,
                    };
                    use spl_token_metadata_interface::state::TokenMetadata;
                    use crate::{
                        mint_all_fungibles, Deployment, DeploymentActive,
                        DeploymentConfig, Hashlist,
                    };
                    use spl_pod::optional_keys::OptionalNonZeroPubkey;
                    pub mod sysvar_instructions_program {
                        use anchor_lang::declare_id;
                        /// The static program ID
                        pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                            6u8,
                            167u8,
                            213u8,
                            23u8,
                            24u8,
                            123u8,
                            209u8,
                            102u8,
                            53u8,
                            218u8,
                            212u8,
                            4u8,
                            85u8,
                            253u8,
                            194u8,
                            192u8,
                            193u8,
                            36u8,
                            198u8,
                            143u8,
                            33u8,
                            86u8,
                            117u8,
                            165u8,
                            219u8,
                            186u8,
                            203u8,
                            95u8,
                            8u8,
                            0u8,
                            0u8,
                            0u8,
                        ]);
                        /// Confirms that a given pubkey is equivalent to the program ID
                        pub fn check_id(
                            id: &anchor_lang::solana_program::pubkey::Pubkey,
                        ) -> bool {
                            id == &ID
                        }
                        /// Returns the program ID
                        pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                            ID
                        }
                    }
                    pub fn deploy_token_2022_logic<'f>(
                        hashlist: &mut Account<'f, Hashlist>,
                        deployment: &mut Account<'f, Deployment>,
                        deployment_config: &Account<'f, DeploymentConfig>,
                        fungible_mint: &Signer<'f>,
                        payer: &Signer<'f>,
                        fungible_escrow_token_account: &UncheckedAccount<'f>,
                        token_program: &UncheckedAccount<'f>,
                        associated_token_program: &Program<'f, AssociatedToken>,
                        system_program: &Program<'f, System>,
                        deployment_bump: u8,
                    ) -> Result<()> {
                        hashlist.deployment = deployment.key();
                        ::solana_program::log::sol_log(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Set fungible mint to {0}",
                                        fungible_mint.key(),
                                    ),
                                );
                                res
                            },
                        );
                        deployment.fungible_mint = fungible_mint.key();
                        let deployment_seeds: &[&[u8]] = &[
                            "deployment".as_bytes(),
                            deployment.ticker.as_ref(),
                            &[deployment_bump],
                        ];
                        let update_authority = OptionalNonZeroPubkey::try_from(
                                Some(deployment.key()),
                            )
                            .expect("Bad update auth");
                        ::solana_program::log::sol_log(
                            "Create token 2022 w/ metadata and group",
                        );
                        create_token_2022_and_metadata(
                            MintAccounts2022 {
                                authority: deployment.to_account_info(),
                                payer: payer.to_account_info(),
                                nft_owner: deployment.to_account_info(),
                                nft_mint: fungible_mint.to_account_info(),
                                spl_token_program: token_program.to_account_info(),
                            },
                            deployment.decimals,
                            Some(TokenMetadata {
                                update_authority,
                                mint: fungible_mint.key(),
                                name: deployment.ticker.clone(),
                                symbol: deployment.ticker.clone(),
                                uri: deployment.offchain_url.clone(),
                                additional_metadata: ::alloc::vec::Vec::new(),
                            }),
                            Some(TokenGroupInput {
                                max_size: deployment.max_number_of_tokens as u32,
                            }),
                            None,
                            Some(deployment_seeds),
                            deployment_config.deflation_rate_per_swap,
                        )?;
                        let deployment_seeds: &[&[u8]] = &[
                            "deployment".as_bytes(),
                            deployment.ticker.as_ref(),
                            &[deployment_bump],
                        ];
                        mint_all_fungibles(
                            deployment,
                            &fungible_mint.to_account_info(),
                            fungible_escrow_token_account,
                            associated_token_program,
                            payer,
                            system_program,
                            token_program,
                            deployment_seeds,
                            true,
                        )?;
                        ::solana_program::log::sol_log("Created non fungible");
                        {
                            anchor_lang::solana_program::log::sol_log_data(
                                &[
                                    &anchor_lang::Event::data(
                                        &DeploymentActive {
                                            ticker: deployment.ticker.clone(),
                                            fungible_mint: fungible_mint.key(),
                                        },
                                    ),
                                ],
                            );
                        };
                        Ok(())
                    }
                }
                pub use deploy_token_2022_logic::*;
            }
            pub use deploy::*;
            pub mod swaps {
                pub mod move_fungible_out_of_escrow {
                    use anchor_lang::prelude::*;
                    use anchor_spl::{
                        associated_token::AssociatedToken, token::{Mint, TokenAccount},
                    };
                    use libreplex_shared::operations::transfer_non_pnft;
                    use crate::Deployment;
                    pub mod sysvar_instructions_program {
                        use anchor_lang::declare_id;
                        /// The static program ID
                        pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                            6u8,
                            167u8,
                            213u8,
                            23u8,
                            24u8,
                            123u8,
                            209u8,
                            102u8,
                            53u8,
                            218u8,
                            212u8,
                            4u8,
                            85u8,
                            253u8,
                            194u8,
                            192u8,
                            193u8,
                            36u8,
                            198u8,
                            143u8,
                            33u8,
                            86u8,
                            117u8,
                            165u8,
                            219u8,
                            186u8,
                            203u8,
                            95u8,
                            8u8,
                            0u8,
                            0u8,
                            0u8,
                        ]);
                        /// Confirms that a given pubkey is equivalent to the program ID
                        pub fn check_id(
                            id: &anchor_lang::solana_program::pubkey::Pubkey,
                        ) -> bool {
                            id == &ID
                        }
                        /// Returns the program ID
                        pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                            ID
                        }
                    }
                    pub fn move_fungible_out_of_escrow<'a>(
                        token_program: &AccountInfo<'a>,
                        fungible_source_token_account: &Account<'a, TokenAccount>,
                        fungible_target_token_account: &UncheckedAccount<'a>,
                        deployment: &mut Account<'a, Deployment>,
                        fungible_mint: &Account<'a, Mint>,
                        payer: &Signer<'a>,
                        associated_token_program: &Program<'a, AssociatedToken>,
                        system_program: &Program<'a, System>,
                        authority_seeds: &[&[u8]; 3],
                    ) -> Result<()> {
                        transfer_non_pnft(
                            &token_program.to_account_info(),
                            &fungible_source_token_account.to_account_info(),
                            &fungible_target_token_account.to_account_info(),
                            &deployment.to_account_info(),
                            &fungible_mint.to_account_info(),
                            &payer.to_account_info(),
                            &associated_token_program.to_account_info(),
                            &system_program.to_account_info(),
                            Some(&[authority_seeds]),
                            &payer.to_account_info(),
                            deployment.get_fungible_mint_amount(),
                        )?;
                        deployment.escrow_non_fungible_count += 1;
                        Ok(())
                    }
                }
                pub use move_fungible_out_of_escrow::*;
                pub mod move_fungible_into_escrow {
                    use anchor_lang::prelude::*;
                    use anchor_spl::{
                        associated_token::AssociatedToken, token::{Mint, TokenAccount},
                    };
                    use libreplex_shared::operations::transfer_non_pnft;
                    use crate::Deployment;
                    pub mod sysvar_instructions_program {
                        use anchor_lang::declare_id;
                        /// The static program ID
                        pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
                            6u8,
                            167u8,
                            213u8,
                            23u8,
                            24u8,
                            123u8,
                            209u8,
                            102u8,
                            53u8,
                            218u8,
                            212u8,
                            4u8,
                            85u8,
                            253u8,
                            194u8,
                            192u8,
                            193u8,
                            36u8,
                            198u8,
                            143u8,
                            33u8,
                            86u8,
                            117u8,
                            165u8,
                            219u8,
                            186u8,
                            203u8,
                            95u8,
                            8u8,
                            0u8,
                            0u8,
                            0u8,
                        ]);
                        /// Confirms that a given pubkey is equivalent to the program ID
                        pub fn check_id(
                            id: &anchor_lang::solana_program::pubkey::Pubkey,
                        ) -> bool {
                            id == &ID
                        }
                        /// Returns the program ID
                        pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
                            ID
                        }
                    }
                    pub fn move_fungible_into_escrow<'a>(
                        token_program: &AccountInfo<'a>,
                        fungible_source_token_account: &Account<'a, TokenAccount>,
                        fungible_target_token_account: &UncheckedAccount<'a>,
                        source_wallet: &Signer<'a>,
                        fungible_mint: &Account<'a, Mint>,
                        deployment: &mut Account<'a, Deployment>,
                        associated_token_program: &Program<'a, AssociatedToken>,
                        system_program: &Program<'a, System>,
                        payer: &Signer<'a>,
                    ) -> Result<()> {
                        transfer_non_pnft(
                            &token_program.to_account_info(),
                            &fungible_source_token_account.to_account_info(),
                            &fungible_target_token_account.to_account_info(),
                            &source_wallet.to_account_info(),
                            &fungible_mint.to_account_info(),
                            &deployment.to_account_info(),
                            &associated_token_program.to_account_info(),
                            &system_program.to_account_info(),
                            None,
                            &payer.to_account_info(),
                            deployment.get_fungible_mint_amount(),
                        )?;
                        deployment.escrow_non_fungible_count -= 1;
                        Ok(())
                    }
                }
                pub use move_fungible_into_escrow::*;
            }
            pub use swaps::*;
            pub mod mint {
                pub mod mint_token_2022_logic {
                    use anchor_lang::prelude::*;
                    use anchor_spl::associated_token::AssociatedToken;
                    use solana_program::{program::invoke, system_instruction};
                    use spl_pod::optional_keys::OptionalNonZeroPubkey;
                    use spl_token_metadata_interface::state::TokenMetadata;
                    use libreplex_shared::{
                        create_token_2022_and_metadata, MintAccounts2022, SharedError,
                        TokenMemberInput,
                    };
                    use crate::{
                        create_fair_launch_inscriptions, errors::FairLaunchError,
                        mint_non_fungible_2022_logic, update_deployment_and_hashlist,
                        Deployment, DeploymentConfig, HYBRID_DEPLOYMENT_TYPE,
                        TOKEN2022_DEPLOYMENT_TYPE,
                    };
                    pub fn mint_token2022_logic<'info>(
                        deployment: &mut Account<'info, Deployment>,
                        deployment_config: &mut Account<'info, DeploymentConfig>,
                        fee_treasury: &UncheckedAccount<'info>,
                        fungible_mint: &AccountInfo<'info>,
                        non_fungible_mint: &Signer<'info>,
                        system_program: &Program<'info, System>,
                        payer: &Signer<'info>,
                        associated_token_program: &Program<'info, AssociatedToken>,
                        token_program: &UncheckedAccount<'info>,
                        minter: &UncheckedAccount<'info>,
                        non_fungible_token_account: &AccountInfo<'info>,
                        hashlist: &mut UncheckedAccount<'info>,
                        bump_deployment: u8,
                        remaining_accounts: &[AccountInfo<'info>],
                        co_signer: &Signer<'info>,
                        create_the_nft: bool,
                    ) -> Result<()> {
                        if !deployment.deployment_type.eq(&TOKEN2022_DEPLOYMENT_TYPE)
                            && !deployment.deployment_type.eq(&HYBRID_DEPLOYMENT_TYPE)
                        {
                            return Err(FairLaunchError::IncorrectMintType.into());
                        }
                        if deployment.number_of_tokens_issued
                            >= deployment.max_number_of_tokens
                        {
                            return Err(FairLaunchError::MintedOut.into());
                        }
                        if deployment.migrated_from_legacy {
                            return Err(
                                FairLaunchError::LegacyMigrationsAreMintedOut.into(),
                            );
                        }
                        if deployment.require_creator_cosign
                            && !co_signer.key().eq(&deployment.creator.key())
                        {
                            return Err(SharedError::InvalidCreatorCosigner.into());
                        }
                        let update_authority = OptionalNonZeroPubkey::try_from(
                                Some(deployment.key()),
                            )
                            .expect("Bad update auth");
                        deployment.number_of_tokens_issued += 1;
                        let ticker = deployment.ticker.clone();
                        let deployment_seeds: &[&[u8]] = &[
                            "deployment".as_bytes(),
                            ticker.as_ref(),
                            &[bump_deployment],
                        ];
                        if create_the_nft {
                            create_token_2022_and_metadata(
                                MintAccounts2022 {
                                    authority: deployment.to_account_info(),
                                    payer: payer.to_account_info(),
                                    nft_owner: minter.to_account_info(),
                                    nft_mint: non_fungible_mint.to_account_info(),
                                    spl_token_program: token_program.to_account_info(),
                                },
                                0,
                                Some(TokenMetadata {
                                    name: deployment.ticker.clone(),
                                    symbol: deployment.ticker.clone(),
                                    uri: deployment.offchain_url.clone(),
                                    update_authority,
                                    mint: non_fungible_mint.key(),
                                    additional_metadata: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ("fld".to_string(), deployment.key().to_string()),
                                            (
                                                "pos".to_string(),
                                                deployment.number_of_tokens_issued.to_string(),
                                            ),
                                        ]),
                                    ),
                                }),
                                None,
                                Some(TokenMemberInput {
                                    group_mint: fungible_mint.to_account_info(),
                                }),
                                Some(deployment_seeds),
                                0,
                            )?;
                            mint_non_fungible_2022_logic(
                                &non_fungible_mint.to_account_info(),
                                non_fungible_token_account,
                                associated_token_program,
                                payer,
                                &minter.to_account_info(),
                                system_program,
                                token_program,
                                &deployment.to_account_info(),
                                deployment_seeds,
                            )?;
                        } else {}
                        if deployment.use_inscriptions {
                            if remaining_accounts.len() != 4 {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Incorrect number of remaining accounts. with use_inscriptions, you must provide 4",
                                        ),
                                    );
                                };
                            }
                            let inscriptions_program = &remaining_accounts[0];
                            let inscription_summary = &remaining_accounts[1];
                            let inscription_v3 = &remaining_accounts[2];
                            let inscription_data = &remaining_accounts[3];
                            create_fair_launch_inscriptions(
                                inscriptions_program,
                                inscription_summary,
                                non_fungible_mint,
                                inscription_v3,
                                system_program,
                                payer,
                                inscription_data,
                                deployment,
                            )?;
                            update_deployment_and_hashlist(
                                deployment,
                                hashlist,
                                payer,
                                system_program,
                                non_fungible_mint.key(),
                                Some(inscription_summary),
                            )?;
                        } else {
                            update_deployment_and_hashlist(
                                deployment,
                                hashlist,
                                payer,
                                system_program,
                                non_fungible_mint.key(),
                                None,
                            )?;
                        }
                        ::solana_program::log::sol_log(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Creator fee: {0}",
                                        deployment_config.creator_fee_per_mint_lamports,
                                    ),
                                );
                                res
                            },
                        );
                        if deployment_config.creator_fee_per_mint_lamports > 0 {
                            ::solana_program::log::sol_log(
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "{0} {1}",
                                            payer.key(),
                                            deployment_config.creator_fee_treasury.key(),
                                        ),
                                    );
                                    res
                                },
                            );
                            invoke(
                                &system_instruction::transfer(
                                    &payer.key(),
                                    &deployment_config.creator_fee_treasury,
                                    deployment_config.creator_fee_per_mint_lamports,
                                ),
                                &[
                                    payer.to_account_info(),
                                    fee_treasury.to_account_info(),
                                    system_program.to_account_info(),
                                ],
                            )?;
                        }
                        Ok(())
                    }
                }
                pub use mint_token_2022_logic::*;
                pub mod mint_all_fungibles_2022_logic {
                    use anchor_lang::prelude::*;
                    use anchor_spl::{
                        associated_token::AssociatedToken,
                        token_interface::{mint_to, set_authority, MintTo, SetAuthority},
                    };
                    use libreplex_shared::SharedError;
                    use crate::Deployment;
                    pub fn revoke_mint_auths<'a>(
                        deployment: &Account<'a, Deployment>,
                        token_program: &UncheckedAccount<'a>,
                        fungible_mint: &AccountInfo<'a>,
                        deployment_seeds: &[&[u8]],
                    ) -> Result<()> {
                        ::solana_program::log::sol_log("Removing freeze auth");
                        set_authority(
                            CpiContext::new_with_signer(
                                token_program.to_account_info(),
                                SetAuthority {
                                    current_authority: deployment.to_account_info(),
                                    account_or_mint: fungible_mint.clone(),
                                },
                                &[deployment_seeds],
                            ),
                            anchor_spl::token_2022::spl_token_2022::instruction::AuthorityType::FreezeAccount,
                            None,
                        )?;
                        ::solana_program::log::sol_log("Removing mint authority");
                        set_authority(
                            CpiContext::new_with_signer(
                                token_program.to_account_info(),
                                SetAuthority {
                                    current_authority: deployment.to_account_info(),
                                    account_or_mint: fungible_mint.clone(),
                                },
                                &[deployment_seeds],
                            ),
                            anchor_spl::token_2022::spl_token_2022::instruction::AuthorityType::MintTokens,
                            None,
                        )?;
                        Ok(())
                    }
                    pub fn mint_all_fungibles<'a>(
                        deployment: &Account<'a, Deployment>,
                        fungible_mint: &AccountInfo<'a>,
                        fungible_token_account_escrow: &AccountInfo<'a>,
                        associated_token_program: &Program<'a, AssociatedToken>,
                        payer: &Signer<'a>,
                        system_program: &Program<'a, System>,
                        token_program: &UncheckedAccount<'a>,
                        deployment_seeds: &[&[u8]],
                        revoke_auths: bool,
                    ) -> Result<()> {
                        ::solana_program::log::sol_log(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!("Mint all fungibles {0}", token_program.key()),
                                );
                                res
                            },
                        );
                        let expected_token_account = anchor_spl::associated_token::get_associated_token_address_with_program_id(
                            &deployment.key(),
                            &fungible_mint.key(),
                            &token_program.key(),
                        );
                        if expected_token_account != fungible_token_account_escrow.key()
                        {
                            return Err(SharedError::InvalidTokenAccount.into());
                        }
                        if fungible_token_account_escrow
                            .to_account_info()
                            .data_is_empty()
                        {
                            ::solana_program::log::sol_log(
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}", payer.key()),
                                    );
                                    res
                                },
                            );
                            anchor_spl::associated_token::create(
                                CpiContext::new(
                                    associated_token_program.to_account_info(),
                                    anchor_spl::associated_token::Create {
                                        payer: payer.to_account_info(),
                                        associated_token: fungible_token_account_escrow
                                            .to_account_info(),
                                        authority: deployment.to_account_info(),
                                        mint: fungible_mint.clone(),
                                        system_program: system_program.to_account_info(),
                                        token_program: token_program.to_account_info(),
                                    },
                                ),
                            )?;
                        }
                        ::solana_program::log::sol_log(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!("Minting {0}", token_program.key()),
                                );
                                res
                            },
                        );
                        mint_to(
                            CpiContext::new_with_signer(
                                token_program.to_account_info(),
                                MintTo {
                                    mint: fungible_mint.clone(),
                                    to: fungible_token_account_escrow.to_account_info(),
                                    authority: deployment.to_account_info(),
                                },
                                &[deployment_seeds],
                            ),
                            deployment.get_max_fungible_mint_amount(),
                        )?;
                        if revoke_auths {
                            revoke_mint_auths(
                                deployment,
                                token_program,
                                fungible_mint,
                                deployment_seeds,
                            )?;
                        }
                        Ok(())
                    }
                }
                pub use mint_all_fungibles_2022_logic::*;
                pub mod mint_non_fungible_2022_logic {
                    use anchor_lang::prelude::*;
                    use anchor_spl::{
                        associated_token::AssociatedToken,
                        token_interface::{mint_to, set_authority, MintTo, SetAuthority},
                    };
                    use libreplex_shared::SharedError;
                    pub fn mint_non_fungible_2022_logic<'a>(
                        non_fungible_mint: &AccountInfo<'a>,
                        non_fungible_token_account: &AccountInfo<'a>,
                        associated_token_program: &Program<'a, AssociatedToken>,
                        payer: &Signer<'a>,
                        minter: &AccountInfo<'a>,
                        system_program: &Program<'a, System>,
                        token_program: &UncheckedAccount<'a>,
                        authority: &AccountInfo<'a>,
                        deployment_seeds: &[&[u8]],
                    ) -> Result<()> {
                        ::solana_program::log::sol_log(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!("MINT NON-FUNGIBLE {0}", token_program.key()),
                                );
                                res
                            },
                        );
                        let expected_token_account = anchor_spl::associated_token::get_associated_token_address_with_program_id(
                            &minter.key(),
                            &non_fungible_mint.key(),
                            &token_program.key(),
                        );
                        if expected_token_account != non_fungible_token_account.key() {
                            return Err(SharedError::InvalidTokenAccount.into());
                        }
                        if non_fungible_token_account.to_account_info().data_is_empty() {
                            ::solana_program::log::sol_log(
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}", payer.key()),
                                    );
                                    res
                                },
                            );
                            anchor_spl::associated_token::create(
                                CpiContext::new_with_signer(
                                    associated_token_program.to_account_info(),
                                    anchor_spl::associated_token::Create {
                                        payer: payer.to_account_info(),
                                        associated_token: non_fungible_token_account
                                            .to_account_info(),
                                        authority: minter.clone(),
                                        mint: non_fungible_mint.clone(),
                                        system_program: system_program.to_account_info(),
                                        token_program: token_program.to_account_info(),
                                    },
                                    &[deployment_seeds],
                                ),
                            )?;
                        }
                        if token_program.key().eq(&spl_token_2022::ID) {
                            ::solana_program::log::sol_log(
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("Minting {0}", token_program.key()),
                                    );
                                    res
                                },
                            );
                            mint_to(
                                CpiContext::new_with_signer(
                                    token_program.to_account_info(),
                                    MintTo {
                                        mint: non_fungible_mint.clone(),
                                        to: non_fungible_token_account.to_account_info(),
                                        authority: authority.clone(),
                                    },
                                    &[deployment_seeds],
                                ),
                                1,
                            )?;
                            ::solana_program::log::sol_log("Removing mint authority");
                            set_authority(
                                CpiContext::new_with_signer(
                                    token_program.to_account_info(),
                                    SetAuthority {
                                        current_authority: authority.clone(),
                                        account_or_mint: non_fungible_mint.clone(),
                                    },
                                    &[deployment_seeds],
                                ),
                                anchor_spl::token_2022::spl_token_2022::instruction::AuthorityType::MintTokens,
                                None,
                            )?;
                            ::solana_program::log::sol_log("done");
                        } else {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "This method is only compatible with token-2022",
                                    ),
                                );
                            }
                        }
                        Ok(())
                    }
                }
                pub use mint_non_fungible_2022_logic::*;
                pub mod update_deployment_and_hashlist {
                    use anchor_lang::prelude::*;
                    use libreplex_inscriptions::InscriptionSummary;
                    use crate::{add_to_hashlist, Deployment, MintEvent};
                    pub fn update_deployment_and_hashlist<'a>(
                        deployment: &mut Account<'a, Deployment>,
                        hashlist: &mut UncheckedAccount<'a>,
                        payer: &Signer<'a>,
                        system_program: &Program<'a, System>,
                        root_key: Pubkey,
                        inscription_summary: Option<&AccountInfo<'a>>,
                    ) -> Result<()> {
                        if deployment.number_of_tokens_issued <= 262144 {
                            ::solana_program::log::sol_log("updating hashlist");
                            let mut order_number = 0;
                            if deployment.use_inscriptions {
                                match inscription_summary {
                                    Some(x) => {
                                        ::solana_program::log::sol_log("using inscriptions");
                                        if x.data_is_empty() {
                                            let mut data: &[u8] = &x.try_borrow_data()?[..];
                                            let inscription_summary_obj = InscriptionSummary::deserialize(
                                                &mut data,
                                            )?;
                                            order_number = inscription_summary_obj
                                                .inscription_count_total;
                                        }
                                    }
                                    None => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "inscription_summary must be provided when using inscriptions",
                                            ),
                                        );
                                    }
                                }
                            }
                            add_to_hashlist(
                                deployment.number_of_tokens_issued as u32,
                                hashlist,
                                payer,
                                system_program,
                                &root_key,
                                &deployment.key(),
                                order_number,
                            )?;
                        }
                        {
                            anchor_lang::solana_program::log::sol_log_data(
                                &[
                                    &anchor_lang::Event::data(
                                        &MintEvent {
                                            mint: root_key,
                                            ticker: deployment.ticker.clone(),
                                            tokens_minted: deployment.number_of_tokens_issued,
                                            max_number_of_tokens: deployment.max_number_of_tokens,
                                        },
                                    ),
                                ],
                            );
                        };
                        Ok(())
                    }
                }
                pub use update_deployment_and_hashlist::*;
            }
            pub use mint::*;
        }
    }
    pub use v2::*;
    pub const COMPRESSED_DEPLOYMENT_TYPE: u8 = 2;
    pub const STANDARD_DEPLOYMENT_TYPE: u8 = 0;
    pub const TOKEN2022_DEPLOYMENT_TYPE: u8 = 3;
    pub const HYBRID_DEPLOYMENT_TYPE: u8 = 4;
}
pub use instructions::*;
/// The static program ID
pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
    112u8,
    243u8,
    237u8,
    111u8,
    49u8,
    210u8,
    140u8,
    36u8,
    186u8,
    180u8,
    134u8,
    167u8,
    252u8,
    133u8,
    18u8,
    158u8,
    172u8,
    39u8,
    76u8,
    141u8,
    75u8,
    152u8,
    3u8,
    163u8,
    110u8,
    123u8,
    220u8,
    94u8,
    36u8,
    84u8,
    224u8,
    18u8,
]);
/// Confirms that a given pubkey is equivalent to the program ID
pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
    id == &ID
}
/// Returns the program ID
pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
    ID
}
pub mod errors {
    use anchor_lang::prelude::*;
    #[repr(u32)]
    pub enum FairLaunchError {
        TickerTooLong,
        MintTemplateTooLong,
        OffchainUrlTooLong,
        DeploymentTemplateTooLong,
        RootTypeTooLong,
        MintedOut,
        LegacyMigrationsAreMintedOut,
        MissingGlobalTreeDelegate,
        IncorrectMintType,
        InvalidMetadata,
        CreatorFeeTooHigh,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FairLaunchError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FairLaunchError::TickerTooLong => "TickerTooLong",
                    FairLaunchError::MintTemplateTooLong => "MintTemplateTooLong",
                    FairLaunchError::OffchainUrlTooLong => "OffchainUrlTooLong",
                    FairLaunchError::DeploymentTemplateTooLong => {
                        "DeploymentTemplateTooLong"
                    }
                    FairLaunchError::RootTypeTooLong => "RootTypeTooLong",
                    FairLaunchError::MintedOut => "MintedOut",
                    FairLaunchError::LegacyMigrationsAreMintedOut => {
                        "LegacyMigrationsAreMintedOut"
                    }
                    FairLaunchError::MissingGlobalTreeDelegate => {
                        "MissingGlobalTreeDelegate"
                    }
                    FairLaunchError::IncorrectMintType => "IncorrectMintType",
                    FairLaunchError::InvalidMetadata => "InvalidMetadata",
                    FairLaunchError::CreatorFeeTooHigh => "CreatorFeeTooHigh",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FairLaunchError {
        #[inline]
        fn clone(&self) -> FairLaunchError {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FairLaunchError {}
    impl FairLaunchError {
        /// Gets the name of this [#enum_name].
        pub fn name(&self) -> String {
            match self {
                FairLaunchError::TickerTooLong => "TickerTooLong".to_string(),
                FairLaunchError::MintTemplateTooLong => "MintTemplateTooLong".to_string(),
                FairLaunchError::OffchainUrlTooLong => "OffchainUrlTooLong".to_string(),
                FairLaunchError::DeploymentTemplateTooLong => {
                    "DeploymentTemplateTooLong".to_string()
                }
                FairLaunchError::RootTypeTooLong => "RootTypeTooLong".to_string(),
                FairLaunchError::MintedOut => "MintedOut".to_string(),
                FairLaunchError::LegacyMigrationsAreMintedOut => {
                    "LegacyMigrationsAreMintedOut".to_string()
                }
                FairLaunchError::MissingGlobalTreeDelegate => {
                    "MissingGlobalTreeDelegate".to_string()
                }
                FairLaunchError::IncorrectMintType => "IncorrectMintType".to_string(),
                FairLaunchError::InvalidMetadata => "InvalidMetadata".to_string(),
                FairLaunchError::CreatorFeeTooHigh => "CreatorFeeTooHigh".to_string(),
            }
        }
    }
    impl From<FairLaunchError> for u32 {
        fn from(e: FairLaunchError) -> u32 {
            e as u32 + anchor_lang::error::ERROR_CODE_OFFSET
        }
    }
    impl From<FairLaunchError> for anchor_lang::error::Error {
        fn from(error_code: FairLaunchError) -> anchor_lang::error::Error {
            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                error_name: error_code.name(),
                error_code_number: error_code.into(),
                error_msg: error_code.to_string(),
                error_origin: None,
                compared_values: None,
            })
        }
    }
    impl std::fmt::Display for FairLaunchError {
        fn fmt(
            &self,
            fmt: &mut std::fmt::Formatter<'_>,
        ) -> std::result::Result<(), std::fmt::Error> {
            match self {
                FairLaunchError::TickerTooLong => {
                    fmt.write_fmt(format_args!("Ticker too long"))
                }
                FairLaunchError::MintTemplateTooLong => {
                    fmt.write_fmt(format_args!("Mint template too long"))
                }
                FairLaunchError::OffchainUrlTooLong => {
                    fmt.write_fmt(format_args!("Offchain URL too long"))
                }
                FairLaunchError::DeploymentTemplateTooLong => {
                    fmt.write_fmt(format_args!("Deployment template too long"))
                }
                FairLaunchError::RootTypeTooLong => {
                    fmt.write_fmt(format_args!("Root type too long"))
                }
                FairLaunchError::MintedOut => fmt.write_fmt(format_args!("Minted out")),
                FairLaunchError::LegacyMigrationsAreMintedOut => {
                    fmt.write_fmt(format_args!("Legacy migrations are minted out"))
                }
                FairLaunchError::MissingGlobalTreeDelegate => {
                    fmt.write_fmt(format_args!("Global tree delegate is missing"))
                }
                FairLaunchError::IncorrectMintType => {
                    fmt.write_fmt(format_args!("Incorrect mint type"))
                }
                FairLaunchError::InvalidMetadata => {
                    fmt.write_fmt(format_args!("Invalid Metadata"))
                }
                FairLaunchError::CreatorFeeTooHigh => {
                    fmt.write_fmt(format_args!("Creator fee too high"))
                }
            }
        }
    }
}
pub mod state {
    use anchor_lang::{prelude::*, Discriminator};
    use solana_program::pubkey::Pubkey;
    pub const TICKER_LIMIT: usize = 200;
    pub const TEMPLATE_LIMIT: usize = 1200;
    pub const OFFCHAIN_URL_LIMIT: usize = 1200;
    pub enum DeploymentStatus {
        Initialised,
        Deployed,
        MintedOut,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DeploymentStatus {
        #[inline]
        fn clone(&self) -> DeploymentStatus {
            match self {
                DeploymentStatus::Initialised => DeploymentStatus::Initialised,
                DeploymentStatus::Deployed => DeploymentStatus::Deployed,
                DeploymentStatus::MintedOut => DeploymentStatus::MintedOut,
            }
        }
    }
    impl borsh::de::BorshDeserialize for DeploymentStatus {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            let tag = <u8 as borsh::de::BorshDeserialize>::deserialize_reader(reader)?;
            <Self as borsh::de::EnumExt>::deserialize_variant(reader, tag)
        }
    }
    impl borsh::de::EnumExt for DeploymentStatus {
        fn deserialize_variant<R: borsh::maybestd::io::Read>(
            reader: &mut R,
            variant_idx: u8,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            let mut return_value = match variant_idx {
                0u8 => DeploymentStatus::Initialised,
                1u8 => DeploymentStatus::Deployed,
                2u8 => DeploymentStatus::MintedOut,
                _ => {
                    return Err(
                        borsh::maybestd::io::Error::new(
                            borsh::maybestd::io::ErrorKind::InvalidInput,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Unexpected variant index: {0:?}", variant_idx),
                                );
                                res
                            },
                        ),
                    );
                }
            };
            Ok(return_value)
        }
    }
    impl borsh::ser::BorshSerialize for DeploymentStatus {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            let variant_idx: u8 = match self {
                DeploymentStatus::Initialised => 0u8,
                DeploymentStatus::Deployed => 1u8,
                DeploymentStatus::MintedOut => 2u8,
            };
            writer.write_all(&variant_idx.to_le_bytes())?;
            match self {
                DeploymentStatus::Initialised => {}
                DeploymentStatus::Deployed => {}
                DeploymentStatus::MintedOut => {}
            }
            Ok(())
        }
    }
    pub struct Deployment {
        pub creator: Pubkey,
        pub limit_per_mint: u64,
        pub max_number_of_tokens: u64,
        pub number_of_tokens_issued: u64,
        pub decimals: u8,
        pub use_inscriptions: bool,
        pub deployment_type: u8,
        pub require_creator_cosign: bool,
        pub migrated_from_legacy: bool,
        pub escrow_non_fungible_count: u64,
        #[max_len(TICKER_LIMIT)]
        pub ticker: String,
        #[max_len(TEMPLATE_LIMIT)]
        pub deployment_template: String,
        #[max_len(TEMPLATE_LIMIT)]
        pub mint_template: String,
        pub fungible_mint: Pubkey,
        #[max_len(OFFCHAIN_URL_LIMIT)]
        pub offchain_url: String,
    }
    #[automatically_derived]
    impl anchor_lang::Space for Deployment {
        const INIT_SPACE: usize = 0 + 32 + 8 + 8 + 8 + 1 + 1 + 1 + 1 + 1 + 8
            + (4 + (TICKER_LIMIT as usize)) + (4 + (TEMPLATE_LIMIT as usize))
            + (4 + (TEMPLATE_LIMIT as usize)) + 32 + (4 + (OFFCHAIN_URL_LIMIT as usize));
    }
    impl borsh::ser::BorshSerialize for Deployment
    where
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u8: borsh::ser::BorshSerialize,
        bool: borsh::ser::BorshSerialize,
        u8: borsh::ser::BorshSerialize,
        bool: borsh::ser::BorshSerialize,
        bool: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.limit_per_mint, writer)?;
            borsh::BorshSerialize::serialize(&self.max_number_of_tokens, writer)?;
            borsh::BorshSerialize::serialize(&self.number_of_tokens_issued, writer)?;
            borsh::BorshSerialize::serialize(&self.decimals, writer)?;
            borsh::BorshSerialize::serialize(&self.use_inscriptions, writer)?;
            borsh::BorshSerialize::serialize(&self.deployment_type, writer)?;
            borsh::BorshSerialize::serialize(&self.require_creator_cosign, writer)?;
            borsh::BorshSerialize::serialize(&self.migrated_from_legacy, writer)?;
            borsh::BorshSerialize::serialize(&self.escrow_non_fungible_count, writer)?;
            borsh::BorshSerialize::serialize(&self.ticker, writer)?;
            borsh::BorshSerialize::serialize(&self.deployment_template, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_template, writer)?;
            borsh::BorshSerialize::serialize(&self.fungible_mint, writer)?;
            borsh::BorshSerialize::serialize(&self.offchain_url, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Deployment
    where
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u8: borsh::BorshDeserialize,
        bool: borsh::BorshDeserialize,
        u8: borsh::BorshDeserialize,
        bool: borsh::BorshDeserialize,
        bool: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                creator: borsh::BorshDeserialize::deserialize_reader(reader)?,
                limit_per_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                max_number_of_tokens: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                number_of_tokens_issued: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                decimals: borsh::BorshDeserialize::deserialize_reader(reader)?,
                use_inscriptions: borsh::BorshDeserialize::deserialize_reader(reader)?,
                deployment_type: borsh::BorshDeserialize::deserialize_reader(reader)?,
                require_creator_cosign: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                migrated_from_legacy: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                escrow_non_fungible_count: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                ticker: borsh::BorshDeserialize::deserialize_reader(reader)?,
                deployment_template: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                mint_template: borsh::BorshDeserialize::deserialize_reader(reader)?,
                fungible_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                offchain_url: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Deployment {
        #[inline]
        fn clone(&self) -> Deployment {
            Deployment {
                creator: ::core::clone::Clone::clone(&self.creator),
                limit_per_mint: ::core::clone::Clone::clone(&self.limit_per_mint),
                max_number_of_tokens: ::core::clone::Clone::clone(
                    &self.max_number_of_tokens,
                ),
                number_of_tokens_issued: ::core::clone::Clone::clone(
                    &self.number_of_tokens_issued,
                ),
                decimals: ::core::clone::Clone::clone(&self.decimals),
                use_inscriptions: ::core::clone::Clone::clone(&self.use_inscriptions),
                deployment_type: ::core::clone::Clone::clone(&self.deployment_type),
                require_creator_cosign: ::core::clone::Clone::clone(
                    &self.require_creator_cosign,
                ),
                migrated_from_legacy: ::core::clone::Clone::clone(
                    &self.migrated_from_legacy,
                ),
                escrow_non_fungible_count: ::core::clone::Clone::clone(
                    &self.escrow_non_fungible_count,
                ),
                ticker: ::core::clone::Clone::clone(&self.ticker),
                deployment_template: ::core::clone::Clone::clone(
                    &self.deployment_template,
                ),
                mint_template: ::core::clone::Clone::clone(&self.mint_template),
                fungible_mint: ::core::clone::Clone::clone(&self.fungible_mint),
                offchain_url: ::core::clone::Clone::clone(&self.offchain_url),
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for Deployment {
        fn try_serialize<W: std::io::Write>(
            &self,
            writer: &mut W,
        ) -> anchor_lang::Result<()> {
            if writer.write_all(&[66, 90, 104, 89, 183, 130, 64, 178]).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for Deployment {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [66, 90, 104, 89, 183, 130, 64, 178].len() {
                return Err(
                    anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
                );
            }
            let given_disc = &buf[..8];
            if &[66, 90, 104, 89, 183, 130, 64, 178] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/state.rs",
                                    line: 15u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_account_name("Deployment"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                })
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for Deployment {
        const DISCRIMINATOR: [u8; 8] = [66, 90, 104, 89, 183, 130, 64, 178];
    }
    #[automatically_derived]
    impl anchor_lang::Owner for Deployment {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    pub struct DeploymentConfig {
        pub deployment: Pubkey,
        pub creator_fee_treasury: Pubkey,
        pub creator_fee_per_mint_lamports: u64,
        pub deflation_rate_per_swap: u16,
        pub cosigner_program_id: Pubkey,
    }
    #[automatically_derived]
    impl anchor_lang::Space for DeploymentConfig {
        const INIT_SPACE: usize = 0 + 32 + 32 + 8 + 2 + 32;
    }
    impl borsh::ser::BorshSerialize for DeploymentConfig
    where
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u16: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
            borsh::BorshSerialize::serialize(&self.creator_fee_treasury, writer)?;
            borsh::BorshSerialize::serialize(
                &self.creator_fee_per_mint_lamports,
                writer,
            )?;
            borsh::BorshSerialize::serialize(&self.deflation_rate_per_swap, writer)?;
            borsh::BorshSerialize::serialize(&self.cosigner_program_id, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for DeploymentConfig
    where
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u16: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                deployment: borsh::BorshDeserialize::deserialize_reader(reader)?,
                creator_fee_treasury: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                creator_fee_per_mint_lamports: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                deflation_rate_per_swap: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                cosigner_program_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DeploymentConfig {
        #[inline]
        fn clone(&self) -> DeploymentConfig {
            DeploymentConfig {
                deployment: ::core::clone::Clone::clone(&self.deployment),
                creator_fee_treasury: ::core::clone::Clone::clone(
                    &self.creator_fee_treasury,
                ),
                creator_fee_per_mint_lamports: ::core::clone::Clone::clone(
                    &self.creator_fee_per_mint_lamports,
                ),
                deflation_rate_per_swap: ::core::clone::Clone::clone(
                    &self.deflation_rate_per_swap,
                ),
                cosigner_program_id: ::core::clone::Clone::clone(
                    &self.cosigner_program_id,
                ),
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for DeploymentConfig {
        fn try_serialize<W: std::io::Write>(
            &self,
            writer: &mut W,
        ) -> anchor_lang::Result<()> {
            if writer.write_all(&[13, 112, 57, 81, 43, 26, 156, 18]).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for DeploymentConfig {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [13, 112, 57, 81, 43, 26, 156, 18].len() {
                return Err(
                    anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
                );
            }
            let given_disc = &buf[..8];
            if &[13, 112, 57, 81, 43, 26, 156, 18] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/state.rs",
                                    line: 66u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_account_name("DeploymentConfig"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                })
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for DeploymentConfig {
        const DISCRIMINATOR: [u8; 8] = [13, 112, 57, 81, 43, 26, 156, 18];
    }
    #[automatically_derived]
    impl anchor_lang::Owner for DeploymentConfig {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl DeploymentConfig {
        /// leave a bit of extra space at the end in case more config is needed
        pub const SIZE: usize = 8 + 32 + 32 + 8 + 500;
    }
    pub struct NewDeploymentEvent {
        pub ticker: String,
        pub limit_per_mint: u64,
        pub max_number_of_tokens: u64,
        pub creator: Pubkey,
    }
    impl borsh::ser::BorshSerialize for NewDeploymentEvent
    where
        String: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.ticker, writer)?;
            borsh::BorshSerialize::serialize(&self.limit_per_mint, writer)?;
            borsh::BorshSerialize::serialize(&self.max_number_of_tokens, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NewDeploymentEvent
    where
        String: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                ticker: borsh::BorshDeserialize::deserialize_reader(reader)?,
                limit_per_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                max_number_of_tokens: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                creator: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Event for NewDeploymentEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [107, 171, 132, 15, 186, 30, 243, 131].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NewDeploymentEvent {
        const DISCRIMINATOR: [u8; 8] = [107, 171, 132, 15, 186, 30, 243, 131];
    }
    pub struct NewDeploymentV2 {
        pub ticker: String,
        pub limit_per_mint: u64,
        pub max_number_of_tokens: u64,
        pub creator: Pubkey,
        pub off_chain_url: String,
        pub require_co_sign: bool,
        pub deployment_template: String,
        pub mint_template: String,
        pub uses_inscriptions: bool,
        pub decimals: u8,
        pub deployment_type: u8,
        pub config: Option<DeploymentConfig>,
    }
    impl borsh::ser::BorshSerialize for NewDeploymentV2
    where
        String: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        bool: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        bool: borsh::ser::BorshSerialize,
        u8: borsh::ser::BorshSerialize,
        u8: borsh::ser::BorshSerialize,
        Option<DeploymentConfig>: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.ticker, writer)?;
            borsh::BorshSerialize::serialize(&self.limit_per_mint, writer)?;
            borsh::BorshSerialize::serialize(&self.max_number_of_tokens, writer)?;
            borsh::BorshSerialize::serialize(&self.creator, writer)?;
            borsh::BorshSerialize::serialize(&self.off_chain_url, writer)?;
            borsh::BorshSerialize::serialize(&self.require_co_sign, writer)?;
            borsh::BorshSerialize::serialize(&self.deployment_template, writer)?;
            borsh::BorshSerialize::serialize(&self.mint_template, writer)?;
            borsh::BorshSerialize::serialize(&self.uses_inscriptions, writer)?;
            borsh::BorshSerialize::serialize(&self.decimals, writer)?;
            borsh::BorshSerialize::serialize(&self.deployment_type, writer)?;
            borsh::BorshSerialize::serialize(&self.config, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for NewDeploymentV2
    where
        String: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        bool: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        bool: borsh::BorshDeserialize,
        u8: borsh::BorshDeserialize,
        u8: borsh::BorshDeserialize,
        Option<DeploymentConfig>: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                ticker: borsh::BorshDeserialize::deserialize_reader(reader)?,
                limit_per_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                max_number_of_tokens: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                creator: borsh::BorshDeserialize::deserialize_reader(reader)?,
                off_chain_url: borsh::BorshDeserialize::deserialize_reader(reader)?,
                require_co_sign: borsh::BorshDeserialize::deserialize_reader(reader)?,
                deployment_template: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                mint_template: borsh::BorshDeserialize::deserialize_reader(reader)?,
                uses_inscriptions: borsh::BorshDeserialize::deserialize_reader(reader)?,
                decimals: borsh::BorshDeserialize::deserialize_reader(reader)?,
                deployment_type: borsh::BorshDeserialize::deserialize_reader(reader)?,
                config: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Event for NewDeploymentV2 {
        fn data(&self) -> Vec<u8> {
            let mut d = [26, 55, 148, 253, 53, 0, 21, 145].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for NewDeploymentV2 {
        const DISCRIMINATOR: [u8; 8] = [26, 55, 148, 253, 53, 0, 21, 145];
    }
    pub struct DeploymentActive {
        pub ticker: String,
        pub fungible_mint: Pubkey,
    }
    impl borsh::ser::BorshSerialize for DeploymentActive
    where
        String: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.ticker, writer)?;
            borsh::BorshSerialize::serialize(&self.fungible_mint, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for DeploymentActive
    where
        String: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                ticker: borsh::BorshDeserialize::deserialize_reader(reader)?,
                fungible_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Event for DeploymentActive {
        fn data(&self) -> Vec<u8> {
            let mut d = [173, 146, 199, 31, 176, 252, 113, 32].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for DeploymentActive {
        const DISCRIMINATOR: [u8; 8] = [173, 146, 199, 31, 176, 252, 113, 32];
    }
    pub struct MintEvent {
        pub mint: Pubkey,
        pub ticker: String,
        pub tokens_minted: u64,
        pub max_number_of_tokens: u64,
    }
    impl borsh::ser::BorshSerialize for MintEvent
    where
        Pubkey: borsh::ser::BorshSerialize,
        String: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.ticker, writer)?;
            borsh::BorshSerialize::serialize(&self.tokens_minted, writer)?;
            borsh::BorshSerialize::serialize(&self.max_number_of_tokens, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MintEvent
    where
        Pubkey: borsh::BorshDeserialize,
        String: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                ticker: borsh::BorshDeserialize::deserialize_reader(reader)?,
                tokens_minted: borsh::BorshDeserialize::deserialize_reader(reader)?,
                max_number_of_tokens: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
            })
        }
    }
    impl anchor_lang::Event for MintEvent {
        fn data(&self) -> Vec<u8> {
            let mut d = [197, 144, 146, 149, 66, 164, 95, 16].to_vec();
            d.append(&mut self.try_to_vec().unwrap());
            d
        }
    }
    impl anchor_lang::Discriminator for MintEvent {
        const DISCRIMINATOR: [u8; 8] = [197, 144, 146, 149, 66, 164, 95, 16];
    }
    impl Deployment {
        pub fn get_fungible_mint_amount(&self) -> u64 {
            self.limit_per_mint
                .checked_mul(10_u64.checked_pow(self.decimals as u32).unwrap())
                .unwrap()
        }
        pub fn get_max_fungible_mint_amount(&self) -> u64 {
            self.max_number_of_tokens
                .checked_mul(self.limit_per_mint)
                .unwrap()
                .checked_mul(10_u64.checked_pow(self.decimals as u32).unwrap())
                .unwrap()
        }
    }
    pub struct MintAndOrder {
        pub mint: Pubkey,
        pub order: u64,
    }
    impl borsh::ser::BorshSerialize for MintAndOrder
    where
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.mint, writer)?;
            borsh::BorshSerialize::serialize(&self.order, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MintAndOrder
    where
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                order: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MintAndOrder {
        #[inline]
        fn clone(&self) -> MintAndOrder {
            MintAndOrder {
                mint: ::core::clone::Clone::clone(&self.mint),
                order: ::core::clone::Clone::clone(&self.order),
            }
        }
    }
    pub struct Hashlist {
        pub deployment: Pubkey,
        pub issues: Vec<MintAndOrder>,
    }
    impl borsh::ser::BorshSerialize for Hashlist
    where
        Pubkey: borsh::ser::BorshSerialize,
        Vec<MintAndOrder>: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
            borsh::BorshSerialize::serialize(&self.issues, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Hashlist
    where
        Pubkey: borsh::BorshDeserialize,
        Vec<MintAndOrder>: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                deployment: borsh::BorshDeserialize::deserialize_reader(reader)?,
                issues: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Hashlist {
        #[inline]
        fn clone(&self) -> Hashlist {
            Hashlist {
                deployment: ::core::clone::Clone::clone(&self.deployment),
                issues: ::core::clone::Clone::clone(&self.issues),
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for Hashlist {
        fn try_serialize<W: std::io::Write>(
            &self,
            writer: &mut W,
        ) -> anchor_lang::Result<()> {
            if writer.write_all(&[187, 203, 134, 6, 43, 198, 120, 186]).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for Hashlist {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [187, 203, 134, 6, 43, 198, 120, 186].len() {
                return Err(
                    anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
                );
            }
            let given_disc = &buf[..8];
            if &[187, 203, 134, 6, 43, 198, 120, 186] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/state.rs",
                                    line: 146u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_account_name("Hashlist"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                })
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for Hashlist {
        const DISCRIMINATOR: [u8; 8] = [187, 203, 134, 6, 43, 198, 120, 186];
    }
    #[automatically_derived]
    impl anchor_lang::Owner for Hashlist {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    pub struct MigrationMarker {}
    impl borsh::ser::BorshSerialize for MigrationMarker {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MigrationMarker {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MigrationMarker {
        #[inline]
        fn clone(&self) -> MigrationMarker {
            MigrationMarker {}
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for MigrationMarker {
        fn try_serialize<W: std::io::Write>(
            &self,
            writer: &mut W,
        ) -> anchor_lang::Result<()> {
            if writer.write_all(&[187, 159, 18, 140, 101, 139, 9, 106]).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for MigrationMarker {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [187, 159, 18, 140, 101, 139, 9, 106].len() {
                return Err(
                    anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
                );
            }
            let given_disc = &buf[..8];
            if &[187, 159, 18, 140, 101, 139, 9, 106] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/state.rs",
                                    line: 153u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_account_name("MigrationMarker"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                })
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for MigrationMarker {
        const DISCRIMINATOR: [u8; 8] = [187, 159, 18, 140, 101, 139, 9, 106];
    }
    #[automatically_derived]
    impl anchor_lang::Owner for MigrationMarker {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    pub struct HashlistMarker {
        pub multiplier: u16,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for HashlistMarker {
        #[inline]
        fn clone(&self) -> HashlistMarker {
            HashlistMarker {
                multiplier: ::core::clone::Clone::clone(&self.multiplier),
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::Space for HashlistMarker {
        const INIT_SPACE: usize = 0 + 2;
    }
    impl Discriminator for HashlistMarker {
        const DISCRIMINATOR: [u8; 8] = [55, 46, 160, 53, 239, 41, 223, 50];
    }
    impl anchor_lang::AccountSerialize for HashlistMarker {
        fn try_serialize<W: std::io::prelude::Write>(
            &self,
            writer: &mut W,
        ) -> Result<()> {
            if writer.write_all(&HashlistMarker::discriminator()).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(&self.multiplier, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    impl anchor_lang::Owner for HashlistMarker {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    impl anchor_lang::AccountDeserialize for HashlistMarker {
        fn try_deserialize(buf: &mut &[u8]) -> Result<Self> {
            if buf.len() < HashlistMarker::discriminator().len() {
                return Err(
                    anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
                );
            }
            let given_disc = &buf[..8];
            if &HashlistMarker::discriminator() != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/state.rs",
                                    line: 157u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_account_name("HashlistMarker"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
            let mut data: &[u8] = &buf[8..];
            if data.len() == 0 {
                return Ok(Self { multiplier: 1 });
            }
            Ok(Self {
                multiplier: AnchorDeserialize::deserialize_reader(&mut data)?,
            })
        }
    }
    pub struct MigrationCounter {
        pub deployment: Pubkey,
        pub migration_count: u64,
    }
    impl borsh::ser::BorshSerialize for MigrationCounter
    where
        Pubkey: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
            borsh::BorshSerialize::serialize(&self.migration_count, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MigrationCounter
    where
        Pubkey: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                deployment: borsh::BorshDeserialize::deserialize_reader(reader)?,
                migration_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MigrationCounter {
        #[inline]
        fn clone(&self) -> MigrationCounter {
            MigrationCounter {
                deployment: ::core::clone::Clone::clone(&self.deployment),
                migration_count: ::core::clone::Clone::clone(&self.migration_count),
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for MigrationCounter {
        fn try_serialize<W: std::io::Write>(
            &self,
            writer: &mut W,
        ) -> anchor_lang::Result<()> {
            if writer.write_all(&[112, 205, 130, 135, 57, 50, 236, 108]).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for MigrationCounter {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [112, 205, 130, 135, 57, 50, 236, 108].len() {
                return Err(
                    anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
                );
            }
            let given_disc = &buf[..8];
            if &[112, 205, 130, 135, 57, 50, 236, 108] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/state.rs",
                                    line: 233u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_account_name("MigrationCounter"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                })
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for MigrationCounter {
        const DISCRIMINATOR: [u8; 8] = [112, 205, 130, 135, 57, 50, 236, 108];
    }
    #[automatically_derived]
    impl anchor_lang::Owner for MigrationCounter {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
    pub struct Redeemable {
        pub asset: Pubkey,
        pub deployment: Pubkey,
    }
    #[automatically_derived]
    impl anchor_lang::Space for Redeemable {
        const INIT_SPACE: usize = 0 + 32 + 32;
    }
    impl borsh::ser::BorshSerialize for Redeemable
    where
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.asset, writer)?;
            borsh::BorshSerialize::serialize(&self.deployment, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Redeemable
    where
        Pubkey: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                asset: borsh::BorshDeserialize::deserialize_reader(reader)?,
                deployment: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Redeemable {
        #[inline]
        fn clone(&self) -> Redeemable {
            Redeemable {
                asset: ::core::clone::Clone::clone(&self.asset),
                deployment: ::core::clone::Clone::clone(&self.deployment),
            }
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountSerialize for Redeemable {
        fn try_serialize<W: std::io::Write>(
            &self,
            writer: &mut W,
        ) -> anchor_lang::Result<()> {
            if writer.write_all(&[206, 5, 98, 185, 147, 78, 168, 255]).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            if AnchorSerialize::serialize(self, writer).is_err() {
                return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::AccountDeserialize for Redeemable {
        fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            if buf.len() < [206, 5, 98, 185, 147, 78, 168, 255].len() {
                return Err(
                    anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
                );
            }
            let given_disc = &buf[..8];
            if &[206, 5, 98, 185, 147, 78, 168, 255] != given_disc {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/state.rs",
                                    line: 239u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_account_name("Redeemable"),
                );
            }
            Self::try_deserialize_unchecked(buf)
        }
        fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
            let mut data: &[u8] = &buf[8..];
            AnchorDeserialize::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                })
        }
    }
    #[automatically_derived]
    impl anchor_lang::Discriminator for Redeemable {
        const DISCRIMINATOR: [u8; 8] = [206, 5, 98, 185, 147, 78, 168, 255];
    }
    #[automatically_derived]
    impl anchor_lang::Owner for Redeemable {
        fn owner() -> Pubkey {
            crate::ID
        }
    }
}
pub use state::*;
use self::libreplex_fair_launch::*;
/// # Safety
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) = unsafe {
        ::solana_program::entrypoint::deserialize(input)
    };
    match entry(&program_id, &accounts, &instruction_data) {
        Ok(()) => ::solana_program::entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}
/// The Anchor codegen exposes a programming model where a user defines
/// a set of methods inside of a `#[program]` module in a way similar
/// to writing RPC request handlers. The macro then generates a bunch of
/// code wrapping these user defined methods into something that can be
/// executed on Solana.
///
/// These methods fall into one category for now.
///
/// Global methods - regular methods inside of the `#[program]`.
///
/// Care must be taken by the codegen to prevent collisions between
/// methods in these different namespaces. For this reason, Anchor uses
/// a variant of sighash to perform method dispatch, rather than
/// something like a simple enum variant discriminator.
///
/// The execution flow of the generated code can be roughly outlined:
///
/// * Start program via the entrypoint.
/// * Strip method identifier off the first 8 bytes of the instruction
///   data and invoke the identified method. The method identifier
///   is a variant of sighash. See docs.rs for `anchor_lang` for details.
/// * If the method identifier is an IDL identifier, execute the IDL
///   instructions, which are a special set of hardcoded instructions
///   baked into every Anchor program. Then exit.
/// * Otherwise, the method identifier is for a user defined
///   instruction, i.e., one of the methods in the user defined
///   `#[program]` module. Perform method dispatch, i.e., execute the
///   big match statement mapping method identifier to method handler
///   wrapper.
/// * Run the method handler wrapper. This wraps the code the user
///   actually wrote, deserializing the accounts, constructing the
///   context, invoking the user's code, and finally running the exit
///   routine, which typically persists account changes.
///
/// The `entry` function here, defines the standard entry to a Solana
/// program, where execution begins.
pub fn entry<'info>(
    program_id: &Pubkey,
    accounts: &'info [AccountInfo<'info>],
    data: &[u8],
) -> anchor_lang::solana_program::entrypoint::ProgramResult {
    try_entry(program_id, accounts, data)
        .map_err(|e| {
            e.log();
            e.into()
        })
}
fn try_entry<'info>(
    program_id: &Pubkey,
    accounts: &'info [AccountInfo<'info>],
    data: &[u8],
) -> anchor_lang::Result<()> {
    if *program_id != ID {
        return Err(anchor_lang::error::ErrorCode::DeclaredProgramIdMismatch.into());
    }
    if data.len() < 8 {
        return Err(anchor_lang::error::ErrorCode::InstructionMissing.into());
    }
    dispatch(program_id, accounts, data)
}
/// Module representing the program.
pub mod program {
    use super::*;
    /// Type representing the program.
    pub struct LibreplexFairLaunch;
    #[automatically_derived]
    impl ::core::clone::Clone for LibreplexFairLaunch {
        #[inline]
        fn clone(&self) -> LibreplexFairLaunch {
            LibreplexFairLaunch
        }
    }
    impl anchor_lang::Id for LibreplexFairLaunch {
        fn id() -> Pubkey {
            ID
        }
    }
}
/// Performs method dispatch.
///
/// Each method in an anchor program is uniquely defined by a namespace
/// and a rust identifier (i.e., the name given to the method). These
/// two pieces can be combined to creater a method identifier,
/// specifically, Anchor uses
///
/// Sha256("<namespace>:<rust-identifier>")[..8],
///
/// where the namespace can be one type. "global" for a
/// regular instruction.
///
/// With this 8 byte identifier, Anchor performs method dispatch,
/// matching the given 8 byte identifier to the associated method
/// handler, which leads to user defined code being eventually invoked.
fn dispatch<'info>(
    program_id: &Pubkey,
    accounts: &'info [AccountInfo<'info>],
    data: &[u8],
) -> anchor_lang::Result<()> {
    let mut ix_data: &[u8] = data;
    let sighash: [u8; 8] = {
        let mut sighash: [u8; 8] = [0; 8];
        sighash.copy_from_slice(&ix_data[..8]);
        ix_data = &ix_data[8..];
        sighash
    };
    use anchor_lang::Discriminator;
    match sighash {
        instruction::InitialiseV2::DISCRIMINATOR => {
            __private::__global::initialise_v2(program_id, accounts, ix_data)
        }
        instruction::DeployToken22::DISCRIMINATOR => {
            __private::__global::deploy_token22(program_id, accounts, ix_data)
        }
        instruction::Deployhybrid::DISCRIMINATOR => {
            __private::__global::deployhybrid(program_id, accounts, ix_data)
        }
        instruction::RelinquishCosigner::DISCRIMINATOR => {
            __private::__global::relinquish_cosigner(program_id, accounts, ix_data)
        }
        instruction::UpdateSymbol22::DISCRIMINATOR => {
            __private::__global::update_symbol22(program_id, accounts, ix_data)
        }
        instruction::Join::DISCRIMINATOR => {
            __private::__global::join(program_id, accounts, ix_data)
        }
        instruction::UpdateSplMetadata::DISCRIMINATOR => {
            __private::__global::update_spl_metadata(program_id, accounts, ix_data)
        }
        instruction::SwitchDeploymentType::DISCRIMINATOR => {
            __private::__global::switch_deployment_type(program_id, accounts, ix_data)
        }
        instruction::MintToken22::DISCRIMINATOR => {
            __private::__global::mint_token22(program_id, accounts, ix_data)
        }
        instruction::SwapToFungible22::DISCRIMINATOR => {
            __private::__global::swap_to_fungible22(program_id, accounts, ix_data)
        }
        instruction::SwapToNonfungible22::DISCRIMINATOR => {
            __private::__global::swap_to_nonfungible22(program_id, accounts, ix_data)
        }
        instruction::DeployLegacy::DISCRIMINATOR => {
            __private::__global::deploy_legacy(program_id, accounts, ix_data)
        }
        instruction::Initialise::DISCRIMINATOR => {
            __private::__global::initialise(program_id, accounts, ix_data)
        }
        instruction::MintLegacy::DISCRIMINATOR => {
            __private::__global::mint_legacy(program_id, accounts, ix_data)
        }
        instruction::MigrateToHashlist::DISCRIMINATOR => {
            __private::__global::migrate_to_hashlist(program_id, accounts, ix_data)
        }
        instruction::SwapToFungible::DISCRIMINATOR => {
            __private::__global::swap_to_fungible(program_id, accounts, ix_data)
        }
        instruction::SwapToNonfungible::DISCRIMINATOR => {
            __private::__global::swap_to_nonfungible(program_id, accounts, ix_data)
        }
        anchor_lang::idl::IDL_IX_TAG_LE => {
            __private::__idl::__idl_dispatch(program_id, accounts, &ix_data)
        }
        anchor_lang::event::EVENT_IX_TAG_LE => {
            Err(anchor_lang::error::ErrorCode::EventInstructionStub.into())
        }
        _ => Err(anchor_lang::error::ErrorCode::InstructionFallbackNotFound.into()),
    }
}
/// Create a private module to not clutter the program's namespace.
/// Defines an entrypoint for each individual instruction handler
/// wrapper.
mod __private {
    use super::*;
    /// __idl mod defines handlers for injected Anchor IDL instructions.
    pub mod __idl {
        use super::*;
        #[inline(never)]
        #[cfg(not(feature = "no-idl"))]
        pub fn __idl_dispatch<'info>(
            program_id: &Pubkey,
            accounts: &'info [AccountInfo<'info>],
            idl_ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            let mut accounts = accounts;
            let mut data: &[u8] = idl_ix_data;
            let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            match ix {
                anchor_lang::idl::IdlInstruction::Create { data_len } => {
                    let mut bumps = <IdlCreateAccounts as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlCreateAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Resize { data_len } => {
                    let mut bumps = <IdlResizeAccount as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlResizeAccount::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_resize_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Close => {
                    let mut bumps = <IdlCloseAccount as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlCloseAccount::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_close_account(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::CreateBuffer => {
                    let mut bumps = <IdlCreateBuffer as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlCreateBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Write { data } => {
                    let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_write(program_id, &mut accounts, data)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {
                    let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_authority(program_id, &mut accounts, new_authority)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetBuffer => {
                    let mut bumps = <IdlSetBuffer as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlSetBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
            }
            Ok(())
        }
        use anchor_lang::idl::ERASED_AUTHORITY;
        pub struct IdlAccount {
            pub authority: Pubkey,
            pub data_len: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlAccount {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "IdlAccount",
                    "authority",
                    &self.authority,
                    "data_len",
                    &&self.data_len,
                )
            }
        }
        impl borsh::ser::BorshSerialize for IdlAccount
        where
            Pubkey: borsh::ser::BorshSerialize,
            u32: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.authority, writer)?;
                borsh::BorshSerialize::serialize(&self.data_len, writer)?;
                Ok(())
            }
        }
        impl borsh::de::BorshDeserialize for IdlAccount
        where
            Pubkey: borsh::BorshDeserialize,
            u32: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    authority: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    data_len: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlAccount {
            #[inline]
            fn clone(&self) -> IdlAccount {
                IdlAccount {
                    authority: ::core::clone::Clone::clone(&self.authority),
                    data_len: ::core::clone::Clone::clone(&self.data_len),
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for IdlAccount {
            fn try_serialize<W: std::io::Write>(
                &self,
                writer: &mut W,
            ) -> anchor_lang::Result<()> {
                if writer.write_all(&[24, 70, 98, 191, 58, 144, 123, 158]).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for IdlAccount {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < [24, 70, 98, 191, 58, 144, 123, 158].len() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound
                            .into(),
                    );
                }
                let given_disc = &buf[..8];
                if &[24, 70, 98, 191, 58, 144, 123, 158] != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/libreplex_fair_launch/src/lib.rs",
                                        line: 12u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_account_name("IdlAccount"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[8..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                    })
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for IdlAccount {
            const DISCRIMINATOR: [u8; 8] = [24, 70, 98, 191, 58, 144, 123, 158];
        }
        impl IdlAccount {
            pub fn address(program_id: &Pubkey) -> Pubkey {
                let program_signer = Pubkey::find_program_address(&[], program_id).0;
                Pubkey::create_with_seed(&program_signer, IdlAccount::seed(), program_id)
                    .expect("Seed is always valid")
            }
            pub fn seed() -> &'static str {
                "anchor:idl"
            }
        }
        impl anchor_lang::Owner for IdlAccount {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        pub struct IdlCreateAccounts<'info> {
            #[account(signer)]
            pub from: AccountInfo<'info>,
            #[account(mut)]
            pub to: AccountInfo<'info>,
            #[account(seeds = [], bump)]
            pub base: AccountInfo<'info>,
            pub system_program: Program<'info, System>,
            #[account(executable)]
            pub program: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlCreateAccountsBumps>
        for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlCreateAccountsBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let from: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("from"))?;
                let to: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("to"))?;
                let base: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("base"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let program: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("program"))?;
                if !&from.is_signer {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSigner,
                            )
                            .with_account_name("from"),
                    );
                }
                if !&to.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("to"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[],
                    &__program_id,
                );
                __bumps.base = __bump;
                if base.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("base")
                            .with_pubkeys((base.key(), __pda_address)),
                    );
                }
                if !&program.executable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintExecutable,
                            )
                            .with_account_name("program"),
                    );
                }
                Ok(IdlCreateAccounts {
                    from,
                    to,
                    base,
                    system_program,
                    program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.from.to_account_infos());
                account_infos.extend(self.to.to_account_infos());
                account_infos.extend(self.base.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlCreateAccounts<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.from.to_account_metas(Some(true)));
                account_metas.extend(self.to.to_account_metas(None));
                account_metas.extend(self.base.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.to, program_id)
                    .map_err(|e| e.with_account_name("to"))?;
                Ok(())
            }
        }
        pub struct IdlCreateAccountsBumps {
            pub base: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlCreateAccountsBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "IdlCreateAccountsBumps",
                    "base",
                    &&self.base,
                )
            }
        }
        impl Default for IdlCreateAccountsBumps {
            fn default() -> Self {
                IdlCreateAccountsBumps {
                    base: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlCreateAccountsBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_create_accounts {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlCreateAccounts`].
            pub struct IdlCreateAccounts {
                pub from: Pubkey,
                pub to: Pubkey,
                pub base: Pubkey,
                pub system_program: Pubkey,
                pub program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlCreateAccounts
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.from, writer)?;
                    borsh::BorshSerialize::serialize(&self.to, writer)?;
                    borsh::BorshSerialize::serialize(&self.base, writer)?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.program, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlCreateAccounts {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.from,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.to,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.base,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_create_accounts {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlCreateAccounts`].
            pub struct IdlCreateAccounts<'info> {
                pub from: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub to: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub base: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlCreateAccounts<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.from),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.to),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.base),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateAccounts<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.from),
                        );
                    account_infos
                        .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.to));
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.base),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.program),
                        );
                    account_infos
                }
            }
        }
        pub struct IdlAccounts<'info> {
            #[account(mut, has_one = authority)]
            pub idl: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlAccountsBumps> for IdlAccounts<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlAccountsBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let idl: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                if !AsRef::<AccountInfo>::as_ref(&idl).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("idl"),
                    );
                }
                {
                    let my_key = idl.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("idl")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlAccounts { idl, authority })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlAccounts<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.idl.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlAccounts<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.idl.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlAccounts<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.idl, program_id)
                    .map_err(|e| e.with_account_name("idl"))?;
                Ok(())
            }
        }
        pub struct IdlAccountsBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlAccountsBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlAccountsBumps")
            }
        }
        impl Default for IdlAccountsBumps {
            fn default() -> Self {
                IdlAccountsBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlAccounts<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlAccountsBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_accounts {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlAccounts`].
            pub struct IdlAccounts {
                pub idl: Pubkey,
                pub authority: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlAccounts
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.idl, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlAccounts {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.idl,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_accounts {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlAccounts`].
            pub struct IdlAccounts<'info> {
                pub idl: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlAccounts<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.idl),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlAccounts<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.idl),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub struct IdlResizeAccount<'info> {
            #[account(mut, has_one = authority)]
            pub idl: Account<'info, IdlAccount>,
            #[account(mut, constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
            pub system_program: Program<'info, System>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlResizeAccountBumps>
        for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlResizeAccountBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let idl: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                if !AsRef::<AccountInfo>::as_ref(&idl).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("idl"),
                    );
                }
                {
                    let my_key = idl.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("idl")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(&authority).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("authority"),
                    );
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlResizeAccount {
                    idl,
                    authority,
                    system_program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.idl.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlResizeAccount<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.idl.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.idl, program_id)
                    .map_err(|e| e.with_account_name("idl"))?;
                anchor_lang::AccountsExit::exit(&self.authority, program_id)
                    .map_err(|e| e.with_account_name("authority"))?;
                Ok(())
            }
        }
        pub struct IdlResizeAccountBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlResizeAccountBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlResizeAccountBumps")
            }
        }
        impl Default for IdlResizeAccountBumps {
            fn default() -> Self {
                IdlResizeAccountBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlResizeAccountBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_resize_account {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlResizeAccount`].
            pub struct IdlResizeAccount {
                pub idl: Pubkey,
                pub authority: Pubkey,
                pub system_program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlResizeAccount
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.idl, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlResizeAccount {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.idl,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_resize_account {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlResizeAccount`].
            pub struct IdlResizeAccount<'info> {
                pub idl: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlResizeAccount<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.idl),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlResizeAccount<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.idl),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub struct IdlCreateBuffer<'info> {
            #[account(zero)]
            pub buffer: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlCreateBufferBumps>
        for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlCreateBufferBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let buffer = &__accounts[0];
                *__accounts = &__accounts[1..];
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let __anchor_rent = Rent::get()?;
                let buffer: anchor_lang::accounts::account::Account<IdlAccount> = {
                    let mut __data: &[u8] = &buffer.try_borrow_data()?;
                    let mut __disc_bytes = [0u8; 8];
                    __disc_bytes.copy_from_slice(&__data[..8]);
                    let __discriminator = u64::from_le_bytes(__disc_bytes);
                    if __discriminator != 0 {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintZero,
                                )
                                .with_account_name("buffer"),
                        );
                    }
                    match anchor_lang::accounts::account::Account::try_from_unchecked(
                        &buffer,
                    ) {
                        Ok(val) => val,
                        Err(e) => return Err(e.with_account_name("buffer")),
                    }
                };
                if !AsRef::<AccountInfo>::as_ref(&buffer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        buffer.to_account_info().lamports(),
                        buffer.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlCreateBuffer {
                    buffer,
                    authority,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.buffer.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlCreateBuffer<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.buffer.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.buffer, program_id)
                    .map_err(|e| e.with_account_name("buffer"))?;
                Ok(())
            }
        }
        pub struct IdlCreateBufferBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlCreateBufferBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlCreateBufferBumps")
            }
        }
        impl Default for IdlCreateBufferBumps {
            fn default() -> Self {
                IdlCreateBufferBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlCreateBufferBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_create_buffer {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlCreateBuffer`].
            pub struct IdlCreateBuffer {
                pub buffer: Pubkey,
                pub authority: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlCreateBuffer
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.buffer, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlCreateBuffer {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.buffer,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_create_buffer {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlCreateBuffer`].
            pub struct IdlCreateBuffer<'info> {
                pub buffer: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlCreateBuffer<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.buffer),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateBuffer<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.buffer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub struct IdlSetBuffer<'info> {
            #[account(mut, constraint = buffer.authority = = idl.authority)]
            pub buffer: Account<'info, IdlAccount>,
            #[account(mut, has_one = authority)]
            pub idl: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlSetBufferBumps>
        for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlSetBufferBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let buffer: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("buffer"))?;
                let idl: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                if !AsRef::<AccountInfo>::as_ref(&buffer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !(buffer.authority == idl.authority) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&idl).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("idl"),
                    );
                }
                {
                    let my_key = idl.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("idl")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlSetBuffer {
                    buffer,
                    idl,
                    authority,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.buffer.to_account_infos());
                account_infos.extend(self.idl.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlSetBuffer<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.buffer.to_account_metas(None));
                account_metas.extend(self.idl.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.buffer, program_id)
                    .map_err(|e| e.with_account_name("buffer"))?;
                anchor_lang::AccountsExit::exit(&self.idl, program_id)
                    .map_err(|e| e.with_account_name("idl"))?;
                Ok(())
            }
        }
        pub struct IdlSetBufferBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlSetBufferBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlSetBufferBumps")
            }
        }
        impl Default for IdlSetBufferBumps {
            fn default() -> Self {
                IdlSetBufferBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlSetBufferBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_set_buffer {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlSetBuffer`].
            pub struct IdlSetBuffer {
                pub buffer: Pubkey,
                pub idl: Pubkey,
                pub authority: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlSetBuffer
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.buffer, writer)?;
                    borsh::BorshSerialize::serialize(&self.idl, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlSetBuffer {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.buffer,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.idl,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_set_buffer {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlSetBuffer`].
            pub struct IdlSetBuffer<'info> {
                pub buffer: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub idl: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlSetBuffer<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.buffer),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.idl),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlSetBuffer<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.buffer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.idl),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub struct IdlCloseAccount<'info> {
            #[account(mut, has_one = authority, close = sol_destination)]
            pub account: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
            #[account(mut)]
            pub sol_destination: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlCloseAccountBumps>
        for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlCloseAccountBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let account: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("account"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let sol_destination: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("sol_destination"))?;
                if !AsRef::<AccountInfo>::as_ref(&account).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("account"),
                    );
                }
                {
                    let my_key = account.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("account")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                {
                    if account.key() == sol_destination.key() {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintClose,
                                )
                                .with_account_name("account"),
                        );
                    }
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                if !&sol_destination.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("sol_destination"),
                    );
                }
                Ok(IdlCloseAccount {
                    account,
                    authority,
                    sol_destination,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.account.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.sol_destination.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlCloseAccount<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.account.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.sol_destination.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                {
                    let sol_destination = &self.sol_destination;
                    anchor_lang::AccountsClose::close(
                            &self.account,
                            sol_destination.to_account_info(),
                        )
                        .map_err(|e| e.with_account_name("account"))?;
                }
                anchor_lang::AccountsExit::exit(&self.sol_destination, program_id)
                    .map_err(|e| e.with_account_name("sol_destination"))?;
                Ok(())
            }
        }
        pub struct IdlCloseAccountBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlCloseAccountBumps {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlCloseAccountBumps")
            }
        }
        impl Default for IdlCloseAccountBumps {
            fn default() -> Self {
                IdlCloseAccountBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlCloseAccountBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_close_account {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlCloseAccount`].
            pub struct IdlCloseAccount {
                pub account: Pubkey,
                pub authority: Pubkey,
                pub sol_destination: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlCloseAccount
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.account, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.sol_destination, writer)?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlCloseAccount {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.sol_destination,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_close_account {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlCloseAccount`].
            pub struct IdlCloseAccount<'info> {
                pub account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub sol_destination: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlCloseAccount<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.sol_destination),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCloseAccount<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.account),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.sol_destination,
                            ),
                        );
                    account_infos
                }
            }
        }
        use std::cell::{Ref, RefMut};
        pub trait IdlTrailingData<'info> {
            fn trailing_data(self) -> Ref<'info, [u8]>;
            fn trailing_data_mut(self) -> RefMut<'info, [u8]>;
        }
        impl<'a, 'info: 'a> IdlTrailingData<'a> for &'a Account<'info, IdlAccount> {
            fn trailing_data(self) -> Ref<'a, [u8]> {
                let info: &AccountInfo<'info> = self.as_ref();
                Ref::map(info.try_borrow_data().unwrap(), |d| &d[44..])
            }
            fn trailing_data_mut(self) -> RefMut<'a, [u8]> {
                let info: &AccountInfo<'info> = self.as_ref();
                RefMut::map(info.try_borrow_mut_data().unwrap(), |d| &mut d[44..])
            }
        }
        #[inline(never)]
        pub fn __idl_create_account(
            program_id: &Pubkey,
            accounts: &mut IdlCreateAccounts,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateAccount");
            if program_id != accounts.program.key {
                return Err(
                    anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into(),
                );
            }
            let from = accounts.from.key;
            let (base, nonce) = Pubkey::find_program_address(&[], program_id);
            let seed = IdlAccount::seed();
            let owner = accounts.program.key;
            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();
            let space = std::cmp::min(8 + 32 + 4 + data_len as usize, 10_000);
            let rent = Rent::get()?;
            let lamports = rent.minimum_balance(space);
            let seeds = &[&[nonce][..]];
            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(
                from,
                &to,
                &base,
                seed,
                lamports,
                space as u64,
                owner,
            );
            anchor_lang::solana_program::program::invoke_signed(
                &ix,
                &[
                    accounts.from.clone(),
                    accounts.to.clone(),
                    accounts.base.clone(),
                    accounts.system_program.to_account_info(),
                ],
                &[seeds],
            )?;
            let mut idl_account = {
                let mut account_data = accounts.to.try_borrow_data()?;
                let mut account_data_slice: &[u8] = &account_data;
                IdlAccount::try_deserialize_unchecked(&mut account_data_slice)?
            };
            idl_account.authority = *accounts.from.key;
            let mut data = accounts.to.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
            idl_account.try_serialize(&mut cursor)?;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_resize_account(
            program_id: &Pubkey,
            accounts: &mut IdlResizeAccount,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlResizeAccount");
            let data_len: usize = data_len as usize;
            if accounts.idl.data_len != 0 {
                return Err(anchor_lang::error::ErrorCode::IdlAccountNotEmpty.into());
            }
            let idl_ref = AsRef::<AccountInfo>::as_ref(&accounts.idl);
            let new_account_space = idl_ref
                .data_len()
                .checked_add(
                    std::cmp::min(
                        data_len
                            .checked_sub(idl_ref.data_len())
                            .expect(
                                "data_len should always be >= the current account space",
                            ),
                        10_000,
                    ),
                )
                .unwrap();
            if new_account_space > idl_ref.data_len() {
                let sysvar_rent = Rent::get()?;
                let new_rent_minimum = sysvar_rent.minimum_balance(new_account_space);
                anchor_lang::system_program::transfer(
                    anchor_lang::context::CpiContext::new(
                        accounts.system_program.to_account_info(),
                        anchor_lang::system_program::Transfer {
                            from: accounts.authority.to_account_info(),
                            to: accounts.idl.to_account_info().clone(),
                        },
                    ),
                    new_rent_minimum.checked_sub(idl_ref.lamports()).unwrap(),
                )?;
                idl_ref.realloc(new_account_space, false)?;
            }
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_close_account(
            program_id: &Pubkey,
            accounts: &mut IdlCloseAccount,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCloseAccount");
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_buffer(
            program_id: &Pubkey,
            accounts: &mut IdlCreateBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateBuffer");
            let mut buffer = &mut accounts.buffer;
            buffer.authority = *accounts.authority.key;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_write(
            program_id: &Pubkey,
            accounts: &mut IdlAccounts,
            idl_data: Vec<u8>,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlWrite");
            let prev_len: usize = ::std::convert::TryInto::<
                usize,
            >::try_into(accounts.idl.data_len)
                .unwrap();
            let new_len: usize = prev_len.checked_add(idl_data.len()).unwrap() as usize;
            accounts
                .idl
                .data_len = accounts
                .idl
                .data_len
                .checked_add(
                    ::std::convert::TryInto::<u32>::try_into(idl_data.len()).unwrap(),
                )
                .unwrap();
            use IdlTrailingData;
            let mut idl_bytes = accounts.idl.trailing_data_mut();
            let idl_expansion = &mut idl_bytes[prev_len..new_len];
            if idl_expansion.len() != idl_data.len() {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireEqViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireEqViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireEqViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/lib.rs",
                                    line: 12u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((idl_expansion.len(), idl_data.len())),
                );
            }
            idl_expansion.copy_from_slice(&idl_data[..]);
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_authority(
            program_id: &Pubkey,
            accounts: &mut IdlAccounts,
            new_authority: Pubkey,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetAuthority");
            accounts.idl.authority = new_authority;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_buffer(
            program_id: &Pubkey,
            accounts: &mut IdlSetBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetBuffer");
            accounts.idl.data_len = accounts.buffer.data_len;
            use IdlTrailingData;
            let buffer_len = ::std::convert::TryInto::<
                usize,
            >::try_into(accounts.buffer.data_len)
                .unwrap();
            let mut target = accounts.idl.trailing_data_mut();
            let source = &accounts.buffer.trailing_data()[..buffer_len];
            if target.len() < buffer_len {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGteViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGteViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGteViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/libreplex_fair_launch/src/lib.rs",
                                    line: 12u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((target.len(), buffer_len)),
                );
            }
            target[..buffer_len].copy_from_slice(source);
            Ok(())
        }
    }
    /// __global mod defines wrapped handlers for global instructions.
    pub mod __global {
        use super::*;
        #[inline(never)]
        pub fn initialise_v2<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: InitialiseV2");
            let ix = instruction::InitialiseV2::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::InitialiseV2 { input } = ix;
            let mut __bumps = <InitialiseV2Ctx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = InitialiseV2Ctx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::initialise_v2(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                input,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn deploy_token22<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: DeployToken22");
            let ix = instruction::DeployToken22::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::DeployToken22 = ix;
            let mut __bumps = <DeployToken2022Ctx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = DeployToken2022Ctx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::deploy_token22(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn deployhybrid<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Deployhybrid");
            let ix = instruction::Deployhybrid::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::Deployhybrid = ix;
            let mut __bumps = <DeployHybridCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = DeployHybridCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::deployhybrid(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn relinquish_cosigner<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: RelinquishCosigner");
            let ix = instruction::RelinquishCosigner::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::RelinquishCosigner = ix;
            let mut __bumps = <RelinquishCosignersCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = RelinquishCosignersCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::relinquish_cosigner(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn update_symbol22<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: UpdateSymbol22");
            let ix = instruction::UpdateSymbol22::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::UpdateSymbol22 = ix;
            let mut __bumps = <UpdateSymbol2022Ctx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = UpdateSymbol2022Ctx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::update_symbol22(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn join<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Join");
            let ix = instruction::Join::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::Join = ix;
            let mut __bumps = <JoinCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = JoinCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::join(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn update_spl_metadata<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: UpdateSplMetadata");
            let ix = instruction::UpdateSplMetadata::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::UpdateSplMetadata { new_uri } = ix;
            let mut __bumps = <UpdateSplMetadata2022Ctx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = UpdateSplMetadata2022Ctx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::update_spl_metadata(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                new_uri,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn switch_deployment_type<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SwitchDeploymentType");
            let ix = instruction::SwitchDeploymentType::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::SwitchDeploymentType { deployment_type } = ix;
            let mut __bumps = <SwitchDeploymentTypeCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = SwitchDeploymentTypeCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::switch_deployment_type(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                deployment_type,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn mint_token22<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: MintToken22");
            let ix = instruction::MintToken22::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::MintToken22 { input } = ix;
            let mut __bumps = <MintToken2022Ctx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = MintToken2022Ctx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::mint_token22(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                input,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn swap_to_fungible22<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SwapToFungible22");
            let ix = instruction::SwapToFungible22::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::SwapToFungible22 = ix;
            let mut __bumps = <SwapToFungible2022Ctx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = SwapToFungible2022Ctx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::swap_to_fungible22(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn swap_to_nonfungible22<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SwapToNonfungible22");
            let ix = instruction::SwapToNonfungible22::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::SwapToNonfungible22 = ix;
            let mut __bumps = <SwapToNonFungible2022Ctx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = SwapToNonFungible2022Ctx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::swap_to_nonfungible22(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn deploy_legacy<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: DeployLegacy");
            let ix = instruction::DeployLegacy::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::DeployLegacy = ix;
            let mut __bumps = <DeployLegacyCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = DeployLegacyCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::deploy_legacy(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn initialise<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: Initialise");
            let ix = instruction::Initialise::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::Initialise { input } = ix;
            let mut __bumps = <InitialiseCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = InitialiseCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::initialise(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                input,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn mint_legacy<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: MintLegacy");
            let ix = instruction::MintLegacy::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::MintLegacy = ix;
            let mut __bumps = <MintLegacyCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = MintLegacyCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::mint_legacy(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn migrate_to_hashlist<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: MigrateToHashlist");
            let ix = instruction::MigrateToHashlist::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::MigrateToHashlist = ix;
            let mut __bumps = <MigrateToHashlistCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = MigrateToHashlistCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::migrate_to_hashlist(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn swap_to_fungible<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SwapToFungible");
            let ix = instruction::SwapToFungible::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::SwapToFungible = ix;
            let mut __bumps = <SwapLegacyToFungibleCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = SwapLegacyToFungibleCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::swap_to_fungible(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn swap_to_nonfungible<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: SwapToNonfungible");
            let ix = instruction::SwapToNonfungible::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::SwapToNonfungible = ix;
            let mut __bumps = <SwapFungibleToLegacyCtx as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = SwapFungibleToLegacyCtx::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = libreplex_fair_launch::swap_to_nonfungible(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
            )?;
            __accounts.exit(__program_id)
        }
    }
}
pub mod libreplex_fair_launch {
    use super::*;
    pub fn initialise_v2(
        ctx: Context<InitialiseV2Ctx>,
        input: InitialiseInputV2,
    ) -> Result<()> {
        instructions::initialise_v2(ctx, input)
    }
    pub fn deploy_token22(ctx: Context<DeployToken2022Ctx>) -> Result<()> {
        instructions::deploy_token_2022(ctx)
    }
    pub fn deployhybrid(ctx: Context<DeployHybridCtx>) -> Result<()> {
        instructions::deploy_hybrid(ctx)
    }
    pub fn relinquish_cosigner(ctx: Context<RelinquishCosignersCtx>) -> Result<()> {
        instructions::relinquish_cosigner(ctx)
    }
    pub fn update_symbol22<'info>(
        ctx: Context<'_, '_, '_, 'info, UpdateSymbol2022Ctx<'info>>,
    ) -> Result<()> {
        instructions::update_symbol2022(ctx)
    }
    pub fn join<'info>(ctx: Context<'_, '_, '_, 'info, JoinCtx<'info>>) -> Result<()> {
        instructions::join_handler(ctx)
    }
    pub fn update_spl_metadata<'info>(
        ctx: Context<'_, '_, '_, 'info, UpdateSplMetadata2022Ctx<'info>>,
        new_uri: String,
    ) -> Result<()> {
        instructions::update_spl_metadata2022(ctx, new_uri)
    }
    pub fn switch_deployment_type<'info>(
        ctx: Context<'_, '_, '_, 'info, SwitchDeploymentTypeCtx<'info>>,
        deployment_type: u8,
    ) -> Result<()> {
        instructions::switch_deployment_type(ctx, deployment_type)
    }
    pub fn mint_token22<'info>(
        ctx: Context<'_, '_, '_, 'info, MintToken2022Ctx<'info>>,
        input: MintInput,
    ) -> Result<()> {
        instructions::mint_token2022(ctx, input)
    }
    pub fn swap_to_fungible22(ctx: Context<SwapToFungible2022Ctx>) -> Result<()> {
        instructions::swap_to_fungible_2022(ctx)
    }
    pub fn swap_to_nonfungible22<'a>(
        ctx: Context<'_, '_, '_, 'a, SwapToNonFungible2022Ctx<'a>>,
    ) -> Result<()> {
        instructions::swap_to_nonfungible_2022(ctx)
    }
    pub fn deploy_legacy<'f>(
        ctx: Context<'_, '_, '_, 'f, DeployLegacyCtx<'f>>,
    ) -> Result<()> {
        instructions::deploy_legacy::deploy(ctx)
    }
    pub fn initialise(
        ctx: Context<InitialiseCtx>,
        input: InitialiseInput,
    ) -> Result<()> {
        instructions::initialise::initialise(ctx, input)
    }
    pub fn mint_legacy<'info>(
        ctx: Context<'_, '_, '_, 'info, MintLegacyCtx<'info>>,
    ) -> Result<()> {
        instructions::mint_legacy::mint_legacy(ctx)
    }
    pub fn migrate_to_hashlist(ctx: Context<MigrateToHashlistCtx>) -> Result<()> {
        instructions::migrate_to_hashlist::migrate_to_hashlist(ctx)
    }
    pub fn swap_to_fungible(ctx: Context<SwapLegacyToFungibleCtx>) -> Result<()> {
        instructions::swap_metaplex_to_fungible(ctx)
    }
    pub fn swap_to_nonfungible(ctx: Context<SwapFungibleToLegacyCtx>) -> Result<()> {
        instructions::swap_to_nonfungible(ctx)
    }
}
/// An Anchor generated module containing the program's set of
/// instructions, where each method handler in the `#[program]` mod is
/// associated with a struct defining the input arguments to the
/// method. These should be used directly, when one wants to serialize
/// Anchor instruction data, for example, when speciying
/// instructions on a client.
pub mod instruction {
    use super::*;
    /// Instruction.
    pub struct InitialiseV2 {
        pub input: InitialiseInputV2,
    }
    impl borsh::ser::BorshSerialize for InitialiseV2
    where
        InitialiseInputV2: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.input, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for InitialiseV2
    where
        InitialiseInputV2: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                input: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for InitialiseV2 {
        const DISCRIMINATOR: [u8; 8] = [171, 46, 16, 23, 6, 77, 224, 137];
    }
    impl anchor_lang::InstructionData for InitialiseV2 {}
    impl anchor_lang::Owner for InitialiseV2 {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct DeployToken22;
    impl borsh::ser::BorshSerialize for DeployToken22 {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for DeployToken22 {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for DeployToken22 {
        const DISCRIMINATOR: [u8; 8] = [206, 227, 152, 1, 237, 228, 32, 64];
    }
    impl anchor_lang::InstructionData for DeployToken22 {}
    impl anchor_lang::Owner for DeployToken22 {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct Deployhybrid;
    impl borsh::ser::BorshSerialize for Deployhybrid {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Deployhybrid {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for Deployhybrid {
        const DISCRIMINATOR: [u8; 8] = [143, 85, 60, 117, 253, 94, 52, 42];
    }
    impl anchor_lang::InstructionData for Deployhybrid {}
    impl anchor_lang::Owner for Deployhybrid {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct RelinquishCosigner;
    impl borsh::ser::BorshSerialize for RelinquishCosigner {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for RelinquishCosigner {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for RelinquishCosigner {
        const DISCRIMINATOR: [u8; 8] = [69, 8, 121, 143, 73, 21, 58, 18];
    }
    impl anchor_lang::InstructionData for RelinquishCosigner {}
    impl anchor_lang::Owner for RelinquishCosigner {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct UpdateSymbol22;
    impl borsh::ser::BorshSerialize for UpdateSymbol22 {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for UpdateSymbol22 {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for UpdateSymbol22 {
        const DISCRIMINATOR: [u8; 8] = [202, 189, 223, 193, 106, 62, 27, 46];
    }
    impl anchor_lang::InstructionData for UpdateSymbol22 {}
    impl anchor_lang::Owner for UpdateSymbol22 {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct Join;
    impl borsh::ser::BorshSerialize for Join {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Join {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for Join {
        const DISCRIMINATOR: [u8; 8] = [206, 55, 2, 106, 113, 220, 17, 163];
    }
    impl anchor_lang::InstructionData for Join {}
    impl anchor_lang::Owner for Join {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct UpdateSplMetadata {
        pub new_uri: String,
    }
    impl borsh::ser::BorshSerialize for UpdateSplMetadata
    where
        String: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.new_uri, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for UpdateSplMetadata
    where
        String: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                new_uri: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for UpdateSplMetadata {
        const DISCRIMINATOR: [u8; 8] = [121, 242, 104, 72, 126, 4, 142, 26];
    }
    impl anchor_lang::InstructionData for UpdateSplMetadata {}
    impl anchor_lang::Owner for UpdateSplMetadata {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct SwitchDeploymentType {
        pub deployment_type: u8,
    }
    impl borsh::ser::BorshSerialize for SwitchDeploymentType
    where
        u8: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.deployment_type, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SwitchDeploymentType
    where
        u8: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                deployment_type: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for SwitchDeploymentType {
        const DISCRIMINATOR: [u8; 8] = [4, 48, 136, 36, 252, 203, 223, 15];
    }
    impl anchor_lang::InstructionData for SwitchDeploymentType {}
    impl anchor_lang::Owner for SwitchDeploymentType {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct MintToken22 {
        pub input: MintInput,
    }
    impl borsh::ser::BorshSerialize for MintToken22
    where
        MintInput: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.input, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MintToken22
    where
        MintInput: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                input: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for MintToken22 {
        const DISCRIMINATOR: [u8; 8] = [12, 10, 190, 68, 81, 106, 186, 221];
    }
    impl anchor_lang::InstructionData for MintToken22 {}
    impl anchor_lang::Owner for MintToken22 {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct SwapToFungible22;
    impl borsh::ser::BorshSerialize for SwapToFungible22 {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SwapToFungible22 {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for SwapToFungible22 {
        const DISCRIMINATOR: [u8; 8] = [173, 67, 166, 82, 47, 116, 79, 10];
    }
    impl anchor_lang::InstructionData for SwapToFungible22 {}
    impl anchor_lang::Owner for SwapToFungible22 {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct SwapToNonfungible22;
    impl borsh::ser::BorshSerialize for SwapToNonfungible22 {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SwapToNonfungible22 {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for SwapToNonfungible22 {
        const DISCRIMINATOR: [u8; 8] = [105, 81, 181, 80, 169, 70, 223, 42];
    }
    impl anchor_lang::InstructionData for SwapToNonfungible22 {}
    impl anchor_lang::Owner for SwapToNonfungible22 {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct DeployLegacy;
    impl borsh::ser::BorshSerialize for DeployLegacy {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for DeployLegacy {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for DeployLegacy {
        const DISCRIMINATOR: [u8; 8] = [209, 117, 194, 212, 135, 31, 248, 29];
    }
    impl anchor_lang::InstructionData for DeployLegacy {}
    impl anchor_lang::Owner for DeployLegacy {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct Initialise {
        pub input: InitialiseInput,
    }
    impl borsh::ser::BorshSerialize for Initialise
    where
        InitialiseInput: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.input, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for Initialise
    where
        InitialiseInput: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                input: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for Initialise {
        const DISCRIMINATOR: [u8; 8] = [162, 198, 118, 235, 215, 247, 25, 118];
    }
    impl anchor_lang::InstructionData for Initialise {}
    impl anchor_lang::Owner for Initialise {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct MintLegacy;
    impl borsh::ser::BorshSerialize for MintLegacy {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MintLegacy {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for MintLegacy {
        const DISCRIMINATOR: [u8; 8] = [218, 178, 22, 186, 161, 231, 80, 135];
    }
    impl anchor_lang::InstructionData for MintLegacy {}
    impl anchor_lang::Owner for MintLegacy {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct MigrateToHashlist;
    impl borsh::ser::BorshSerialize for MigrateToHashlist {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for MigrateToHashlist {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for MigrateToHashlist {
        const DISCRIMINATOR: [u8; 8] = [84, 60, 54, 13, 48, 42, 238, 5];
    }
    impl anchor_lang::InstructionData for MigrateToHashlist {}
    impl anchor_lang::Owner for MigrateToHashlist {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct SwapToFungible;
    impl borsh::ser::BorshSerialize for SwapToFungible {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SwapToFungible {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for SwapToFungible {
        const DISCRIMINATOR: [u8; 8] = [255, 175, 252, 80, 237, 109, 10, 98];
    }
    impl anchor_lang::InstructionData for SwapToFungible {}
    impl anchor_lang::Owner for SwapToFungible {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct SwapToNonfungible;
    impl borsh::ser::BorshSerialize for SwapToNonfungible {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for SwapToNonfungible {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {})
        }
    }
    impl anchor_lang::Discriminator for SwapToNonfungible {
        const DISCRIMINATOR: [u8; 8] = [227, 127, 47, 15, 41, 11, 28, 96];
    }
    impl anchor_lang::InstructionData for SwapToNonfungible {}
    impl anchor_lang::Owner for SwapToNonfungible {
        fn owner() -> Pubkey {
            ID
        }
    }
}
/// An Anchor generated module, providing a set of structs
/// mirroring the structs deriving `Accounts`, where each field is
/// a `Pubkey`. This is useful for specifying accounts for a client.
pub mod accounts {
    pub use crate::__client_accounts_deploy_token2022_ctx::*;
    pub use crate::__client_accounts_swap_legacy_to_fungible_ctx::*;
    pub use crate::__client_accounts_update_symbol2022_ctx::*;
    pub use crate::__client_accounts_join_ctx::*;
    pub use crate::__client_accounts_update_spl_metadata2022_ctx::*;
    pub use crate::__client_accounts_mint_token2022_ctx::*;
    pub use crate::__client_accounts_swap_fungible_to_legacy_ctx::*;
    pub use crate::__client_accounts_deploy_legacy_ctx::*;
    pub use crate::__client_accounts_swap_to_fungible2022_ctx::*;
    pub use crate::__client_accounts_swap_to_non_fungible2022_ctx::*;
    pub use crate::__client_accounts_initialise_ctx::*;
    pub use crate::__client_accounts_relinquish_cosigners_ctx::*;
    pub use crate::__client_accounts_initialise_v2_ctx::*;
    pub use crate::__client_accounts_migrate_to_hashlist_ctx::*;
    pub use crate::__client_accounts_switch_deployment_type_ctx::*;
    pub use crate::__client_accounts_mint_legacy_ctx::*;
    pub use crate::__client_accounts_deploy_hybrid_ctx::*;
}
